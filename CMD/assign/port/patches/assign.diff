diff -urwN assign-prev/source/assign/assign.c assign/source/assign/assign.c
--- assign-prev/source/assign/assign.c	2024-03-25 16:35:48.388855969 +0000
+++ assign/source/assign/assign.c	2024-03-25 16:33:26.602629486 +0000
@@ -58,33 +58,114 @@
 #define getdisk get_drive
 #define assert(a)
 #else
-#include <DOS.h>
+#include <dos.h>
 #include <assert.h>
 #include <ctype.h>
 #include <string.h>
-#include <dir.h>
+#include <direct.h>                                                                                     
+#include <stdlib.h>
 #endif
 #include <portable.h>
 #include <getopt.h>
-#include "yerror.h"
+//#include "yerror.h"
 
 #ifndef _MICROC_
 #define nargs() _AX
-typedef void interrupt 
+typedef void __interrupt
 #ifdef __cplusplus
 	(*fintr)(...);
 #else
 	(*fintr)();
 #endif
-#define copy_seg(s1,o1,s2,o2,len) _fmemcpy(MK_FP(s1,o1),MK_FP(s2,o2),len)
+#define copy_seg(s1,o1,s2,o2,len) memcpy(MK_FP(s1,o1),MK_FP(s2,o2),len)
 #endif
 
 #define CMD_NONE 0
 #define CMD_STATUS 1
 #define CMD_UNINSTALL 2
 
+//!! include asgn_tsr here!!!
 #include "asgn_asc.c"
 
+#define E_lowDOSVers "DOS version too low. DOS 3 required"
+#define W_highDOSVers "DOS version high. Maybe improper functioning"
+#define E_recursion "Cannot unload the module, because it is a recursion loop"
+#define E_releaseBlock "The chunk of memory could not be relased"
+#define E_internalFailure "Internal failure #%u"
+#define E_loadedModule "The module %s is not loaded with this module version"
+#define E_notOnTop "Some interrupt vectors are hooked by other programs."
+#define E_mcbChain "MCB Chain corrupt"
+#define E_assignData "Cannot locate ASSIGN data segment"
+#define M_installByte "The installation check byte is 0%02x"
+#define W_notInstalled "ASSIGN has not been installed, yet"
+#define M_inRecurs "The recursion rejection flag is 0%02x"
+#define W_mayhapInstalled "ASSIGN probably not installed"
+#define M_assignment "%c: => %c:"
+#define E_noMem "Memory full"
+
+#define E_hlpScreen "ASSIGN: Replace a drive letter by another.\n\r \
+\n\r \
+usage: %s [/SHADOW] /STATUS\n\r \
+or:    [/SHADOW] [/{mu}] [{dr1[:]=dr2[:]}]\n\r \
+\n\r \
+Options:\n\r \
+       SHADOW: Hide ASSIGN from installation check.\n\r \
+       STATUS: Display all assigned drive letters.\n\r \
+               If ASSIGN is not already loaded, a message reflects that,\n\r \
+               but ASSIGN is not loaded.\n\r \
+       M: Move the resident portion into UMB, if possible.\n\r \
+       U: Uninstall a previous installed ASSIGN.\n\r \
+\n\r \
+dr1: Drive letter to be replaced.\n\r \
+dr2: Drive letter to point to.\n\r \
+\n\r \
+The ':' characters are optional, between the drive letters and the \n\r \
+equal sign '=' no whitespaces are allowed."
+
+
+#define message(f, ...) {fprintf(f, __VA_ARGS__); exit(1);}
+#define warning(...) printf(__VA_ARGS__); exit(1)
+#define informative(...) printf(__VA_ARGS__)
+#define error(...) printf(__VA_ARGS__)
+#define fatal(...) printf(__VA_ARGS__)
+
+/*
+ *     Issue an internal failure error message
+ *     They have only a number to differ among themselves
+ */
+#define iFailure(nr) fatal(E_internalFailure, nr)
+
+#define msgErrorNumber(nr) 0
+
+//msgExitCode
+
+/*
+ * The application's name
+ */
+#ifdef MAXFILE
+       static char XappName[MAXFILE] = "";
+#define maxName MAXFILE
+#else /*#      !(defined(MAXFILE)) */
+       static char XappName[9] = "";
+#define maxName 9
+#endif /*#     defined(MAXFILE) */
+
+
+/*
+ *     Return the application's name   
+ */
+char *appName(void)
+{      return XappName;        }
+
+
+void hlpScreen()
+{
+       message(stdout, E_hlpScreen, appName());
+       exit(msgErrorNumber(E_hlpScreen));
+}
+
+
+
 #ifndef lint
 static char const rcsid[] = 
 	"$Id: ASSIGN.C 1.4 1997/01/27 08:09:37 ska Rel ska $";
@@ -105,15 +186,16 @@
 	return result;
 }
 #else
-#define cmp_seg(s1,o1,s2,o2,l) _fmemcmp(MK_FP(s1,o1),MK_FP(s2,o2),l)
+#define cmp_seg(s1,o1,s2,o2,l) memcmp(MK_FP(s1,o1),MK_FP(s2,o2),l)
 #endif
 
 unsigned Xalloc_seg(unsigned size)
 /* reserves a chunk of memory through DOS-48 & last fit */
 {	unsigned segment;
 	FLAG8 UMBLink, allocation;
+        USEREGS
 
-	asm {
+       __asm {
 		mov ax, 5800h	/* Get Allocation Strategy */
 		int 21h
 		xor ah, ah
@@ -121,7 +203,7 @@
 	allocation = nargs();
 
 	if(usehi) {
-		asm {
+		__asm {
 			mov ax, 5802h	/* Get UMB Link Status */
 			int 21h
 			rcl al, 1		/* incorporate Carry */
@@ -129,7 +211,7 @@
 		}
 		UMBLink = nargs();
 		if(UMBLink == 0) {	/* UMBs not chained, but available */
-			asm {
+			__asm {
 				mov ax, 5803h	/* Chain UMBs */
 				mov bx, 1
 				int 21h
@@ -142,19 +224,19 @@
 	}
 	else UMBLink = 0;
 
-	asm {
+	__asm {
 		mov ax, 5801h		/* Set Allocation Strategy */
 		mov bx, 2			/* Last fit */
 		int 21h
 	}
 
-	asm {
+	__asm {
 		mov bx, asmName(size, 4)
 		mov ah, 48h
 		int 21h
 		jnc allocOK
 		xor ax, ax
-	asmLabel(allocOK)
+        allocOK:
 	}
 	segment = nargs();
 
@@ -175,15 +257,17 @@
 
 int shadowed(unsigned segment)
 /* check, if this data segment is a shadowed ASSIGN segment */
-{	return cmp_seg(FP_SEG(shadowStr), FP_OFF(shadowStr)
-			, segment, 0x101 - sizeof(shadowStr), sizeof(shadowStr) - 1) == 0;
+{      return cmp_seg(FP_SEG(shadowStr), FP_OFF(shadowStr),
+                       segment, 0x101 - sizeof(shadowStr), sizeof(shadowStr) - 1) == 0;
 }
 
 unsigned getSeg(void)
 /* returns the data segment of ASSIGN */
 {	int segment;
+        USEREGS
+
+        __asm {
 
-	asm {
 		xor ax, ax
 		mov es, ax
 		mov ax, 601h		/* Get data segment */
@@ -199,8 +283,10 @@
 int installed(void)
 /* check, if ASSIGN is installed */
 {	int cond;
+        USEREGS
+
+        __asm {
 
-	asm {
 		mov ax, 600h
 		int 2fh
 		xor ah, ah
@@ -287,6 +373,7 @@
 	const char *pad;
 	word vseg, voff;
 	struct PATCHITEM const *h;
+        USEREGS
 
 #ifdef _MICROC_
 	nfo = mod + len - sizeof(struct COMinfo);
@@ -341,7 +428,7 @@
 	while(items--) {
 		--h;
 		_AX = h->intNr;
-		asm {
+		__asm {
 			mov ah, 35h
 			int 21h
 			mov vseg, es
@@ -349,7 +436,7 @@
 		}
 		pokew(segment, h->oldIntOfs, voff);
 		pokew(segment, h->oldIntSeg, vseg);
-		setvect(h->intNr, (fintr)MK_FP(segment, h->newIntOfs));
+                _dos_setvect(h->intNr, (fintr)MK_FP(segment, h->newIntOfs));
 	}
 #endif
 }
@@ -361,6 +448,7 @@
 	const char *pad;
 	word vseg, voff;
 	struct PATCHITEM const *h;
+        USEREGS
 
 #ifndef NDEBUG
 	printf("Unloading module from 0x%04x\n", segment);
@@ -398,7 +486,7 @@
 	for(h = (struct PATCHITEM*)nfo, items = nfo->intr; items--;) {
 		--h;
 		_AX = h->intNr;
-		asm {
+		__asm {
 			mov ah, 35h
 			int 21h
 			mov vseg, es
@@ -409,7 +497,7 @@
 	}
 	for(h = (struct PATCHITEM*)nfo, items = nfo->intr; items--;) {
 		--h;
-		setvect(h->intNr, (fintr)MK_FP(peekw(segment, h->oldIntSeg)
+                _dos_setvect(h->intNr, (fintr)MK_FP(peekw(segment, h->oldIntSeg)
 					, peekw(segment, h->oldIntOfs)));
 	}
 #endif
@@ -423,7 +511,7 @@
 /* no way to stuff ES into int86() function */
 
 	set_es(peekw(segment, 0x100 - 2));
-	asm {
+	__asm {
 		mov ah, 49h
 		int 21h
 		pushf
@@ -435,12 +523,12 @@
 	_AX = 0x4900;
 	geninterrupt(0x21);
 #endif
-	if(_FLAGS & 1)	/* Carry set ==> Error */
+       if(_CFLAG)      /* Carry set ==> Error */
 		fatal(E_releaseBlock);
 }
 
 void flush(void)
-{	asm {
+{	__asm {
 		mov ah, 0dh
 		int 21h
 	}
@@ -451,6 +539,7 @@
 	byte *iotbl;
 	word *p, version;
 	FLAG8 a;
+        USEREGS
 
 #ifdef _MICROC_
 	nfo = mod + len - sizeof(struct COMinfo);
@@ -462,7 +551,7 @@
 	iotbl = module - 0x100 + *p;
 
 /* Check DOS's version number */
-	asm {
+	__asm {
 		mov ah, 30h
 		int 21h
 	}
@@ -490,27 +579,30 @@
 {	int c, len;
 	char *p;
 
-	msgInit();
+	//msgInit();
 
 	while((c = getopt(argc, argv, "SHMU?", "")) != EOF)
 		switch(c) {
 			case 'U': status = CMD_UNINSTALL; break;
 			case 'M': usehi = !NUL; break;
 			case 'S':
+                        #if 0
 				if(len = strlen(p = &argv[optind][optchar])) {
 					/* differ "/STATUS" and "/SHADOW" */
 
 					++optind;		/* skip this option */
 					optchar = 0;
 
-					if(memcmpi(p, "HADOW", len) == 0) {
+					if(memicmp(p, "HADOW", len) == 0) {
 						shadow = 1;
 						continue;
 					}
-					if(memcmpi(p, "TATUS", len))
+					if(memicmp(p, "TATUS", len))
 						hlpScreen();
 				}
 
+
+                        #endif
 				/* Status */
 				status = CMD_STATUS;
 				continue;
