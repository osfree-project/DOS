diff -urwN basic/bwb_cmd.c newbasic/bwb_cmd.c
--- basic/bwb_cmd.c	Mon Apr 15 14:33:44 2024
+++ newbasic/bwb_cmd.c	Mon Apr 15 14:31:41 2024
@@ -60,7 +60,9 @@
 static void FixUp (char *Name);
 static LineType *H14_RENAME (LineType * l);
 static int line_read_matrix_redim (LineType * l, VariableType * v);
+#ifndef NO_HELP
 static void ProcessEscapeChars (const char *Input, char *Output);
+#endif
 static int xl_line (FILE * file, LineType * l);
 
 
@@ -6538,6 +6540,7 @@
   fflush (file);
 }
 
+#ifndef NO_HELP
 static void
 ProcessEscapeChars (const char *Input, char *Output)
 {
@@ -6632,6 +6635,7 @@
     Input++;
   }
 }
+#endif
 
 void
 DumpAllCommandTableDefinitions (FILE * file)
@@ -6662,6 +6666,7 @@
     fprintf (file, tbuf);
     fprintf (file, ",  /* UniqueID */\n");
 
+#ifndef NO_HELP
     fprintf (file, "  ");
     fprintf (file, "\"");
     ProcessEscapeChars (IntrinsicCommandTable[i].Syntax, tbuf);
@@ -6675,7 +6680,7 @@
     fprintf (file, tbuf);
     fprintf (file, "\"");
     fprintf (file, ",  /* Description */\n");
-
+#endif
     fprintf (file, "  ");
     fprintf (file, "\"");
     fprintf (file, IntrinsicCommandTable[i].name);
@@ -6851,6 +6856,7 @@
   {
     return;
   }
+#ifndef NO_HELP
   /* NAME */
   {
     FixDescription (file, "     SYNTAX: ", IntrinsicCommandTable[n].Syntax);
@@ -6860,6 +6866,7 @@
     FixDescription (file, "DESCRIPTION: ",
                     IntrinsicCommandTable[n].Description);
   }
+#endif
   /* COMPATIBILITY */
   if (IsXref)
   {
@@ -6964,10 +6971,14 @@
     fprintf (file, bwb_vertable[j].ID);
     fprintf (file, "</td>");
     fprintf (file, "<td>");
+#ifndef NO_HELP
     fprintf (file, bwb_vertable[j].Name);
+#endif
     fprintf (file, "</td>");
     fprintf (file, "<td>");
+#ifndef NO_HELP
     fprintf (file, bwb_vertable[j].Description);
+#endif
     fprintf (file, "</td>");
     fprintf (file, "</tr>\n");
   }
@@ -7002,7 +7013,9 @@
   {
     fprintf (file, "<tr>");
     fprintf (file, "<td>");
+#ifndef NO_HELP
     fprintf (file, (char *) IntrinsicCommandTable[i].Syntax);
+#endif
     fprintf (file, "</td>");
 
     for (j = 0; j < NUM_VERSIONS; j++)
@@ -7783,12 +7796,15 @@
     int j;
     char tbuf[MAINTAINER_BUFFER_LENGTH + 1];        /* DumpAllFuctionTableDefinitions */
     char UniqueID[MAINTAINER_BUFFER_LENGTH + 1];        /* DumpAllFuctionTableDefinitions */
+#ifndef NO_HELP
     char Syntax[MAINTAINER_BUFFER_LENGTH + 1];        /* DumpAllFuctionTableDefinitions */
+#endif
     IntrinsicFunctionType *f;
 
     f = &(IntrinsicFunctionTable[n]);
 
     IntrinsicFunctionUniqueID (f, UniqueID);
+#ifndef NO_HELP
     IntrinsicFunctionSyntax (f, Syntax);
     fprintf (file, "{\n");
     fprintf (file, "  %s, /* UniqueID */\n", UniqueID);
@@ -7799,6 +7815,7 @@
     fprintf (file, tbuf);
     fprintf (file, "\"");
     fprintf (file, ",  /* Description */\n");
+#endif
     fprintf (file, "  \"%s\", /* Name */\n", f->Name);
     switch (f->ReturnTypeCode)
     {
@@ -7973,7 +7990,9 @@
   }
   /* DESCRIPTION */
   {
+#ifndef NO_HELP
     FixDescription (file, "DESCRIPTION: ", f->Description);
+#endif
   }
   /* COMPATIBILITY */
   if (IsXref)
@@ -8024,7 +8043,9 @@
     {
       fprintf (file,
                "------------------------------------------------------------\n");
+#ifndef NO_HELP
       DumpOneFunctionSyntax (file, IsXref, i);
+#endif
     }
   }
   fprintf (file,
@@ -8077,7 +8098,9 @@
     fprintf (file, bwb_vertable[j].Name);
     fprintf (file, "</td>");
     fprintf (file, "<td>");
+#ifndef NO_HELP
     fprintf (file, bwb_vertable[j].Description);
+#endif
     fprintf (file, "</td>");
     fprintf (file, "</tr>\n");
   }
@@ -8112,7 +8135,9 @@
   {
     fprintf (file, "<tr>");
     fprintf (file, "<td>");
+#ifndef NO_HELP
     fprintf (file, (char *) IntrinsicFunctionTable[i].Syntax);
+#endif
     fprintf (file, "</td>");
 
     for (j = 0; j < NUM_VERSIONS; j++)
@@ -8381,6 +8406,7 @@
 
   fprintf (file, "OPTION VERSION \"%s\"\n", My->CurrentVersion->Name);
   fprintf (file, "REM INTERNAL ID: %s\n", My->CurrentVersion->ID);
+#ifndef NO_HELP
   fprintf (file, "REM DESCRIPTION: %s\n", My->CurrentVersion->Description);
   fprintf (file, "REM   REFERENCE: %s\n", My->CurrentVersion->ReferenceTitle);
   fprintf (file, "REM              %s\n",
@@ -8390,6 +8416,7 @@
   fprintf (file, "REM              %s\n", My->CurrentVersion->ReferenceURL1);
   fprintf (file, "REM              %s\n", My->CurrentVersion->ReferenceURL2);
   fprintf (file, "REM\n");
+#endif
 
   if (My->CurrentVersion->OptionFlags & (OPTION_STRICT_ON))
   {
diff -urwN basic/bwb_tbl.c newbasic/bwb_tbl.c
--- basic/bwb_tbl.c	Mon Apr 15 14:33:59 2024
+++ newbasic/bwb_tbl.c	Mon Apr 15 14:30:35 2024
@@ -47,12 +47,14 @@
    "BYWATER",                        /* Name */
    B15,                                /* OptionVersionBitmask */
    "B15",                        /* ID */
+#ifndef NO_HELP
    "Bywater BASIC 3",                /* Description */
    "Bywater BASIC Interpreter, version 3.20",        /* Reference Title */
    "by Ted A. Campbell, Jon B. Volkoff, Paul Edwards, et al.",        /* Reference Author */
    "(c) 2014-2017, Howard Wulf, AF5NE",        /* Reference Copyright */
    "http://wwww.sourceforge.net/bwbasic/",        /* Reference URL1 */
    "bwbasic-3.20.zip",                /* Reference URL2 */
+#endif
    OPTION_LABELS_ON | OPTION_BUGS_ON | OPTION_TRACE_ON,        /* OptionFlags */
    128,                                /* OptionReclenInteger */
    0,                                /* OptionBaseInteger */
@@ -93,12 +95,14 @@
    "BYWATER-2",                        /* Name */
    B93,                                /* OptionVersionBitmask */
    "B93",                        /* ID */
+#ifndef NO_HELP
    "Bywater BASIC 2",                /* Description */
    "Bywater BASIC Interpreter, version 2.61",        /* Reference Title */
    "by Ted A. Campbell, Jon B. Volkoff, Paul Edwards, et al.",        /* Reference Author */
    "Copyright (c) 1993-2014, Ted A. Campbell",        /* Reference Copyright */
    "http://wwww.sourceforge.net/bwbasic/",        /* Reference URL1 */
    "bwbasic-2.61.zip",                /* Reference URL2 */
+#endif
    OPTION_LABELS_ON | OPTION_BUGS_ON | OPTION_ERROR_GOSUB,        /* OptionFlags */
    128,                                /* OptionReclenInteger */
    0,                                /* OptionBaseInteger */
@@ -139,12 +143,14 @@
    "CALL/360",                        /* Name */
    S70,                                /* OptionVersionBitmask */
    "S70",                        /* ID */
+#ifndef NO_HELP
    "SBC CALL/360 Mainframe BASIC",        /* Description */
    "CALL/360: BASIC Reference Handbook",        /* Reference Title */
    "by International Business Machines Corporation",        /* Reference Author */
    "(c) 1970, The Service Bureau Corporation",        /* Reference Copyright */
    "http://bitsavers.trailing-edge.com/pdf/ibm/360/os/",        /* Reference URL1 */
    "call_360/CALL_360_BASIC_Reference_Handbook_1970.pdf",        /* Reference URL2 */
+#endif
    FALSE,                        /* OptionFlags */
    0,                                /* OptionReclenInteger */
    1,                                /* OptionBaseInteger */
@@ -185,12 +191,14 @@
    "CBASIC-II",                        /* Name */
    C77,                                /* OptionVersionBitmask */
    "C77",                        /* ID */
+#ifndef NO_HELP
    "CBASIC-II for CP/M",        /* Description */
    "CBASIC-II",                        /* Reference Title */
    "by Compiler Systems",        /* Reference Author */
    "(c) 1977, Compiler Systems",        /* Reference Copyright */
    "http://bitsavers.trailing-edge.com/pdf/digitalResearch/cb80/",        /* Reference URL1 */
    "CBASIC_Version_2_Jan81.pdf",        /* Reference URL2 */
+#endif
    OPTION_BUGS_ON,                /* OptionFlags */
    0,                                /* OptionReclenInteger */
    0,                                /* OptionBaseInteger */
@@ -231,12 +239,14 @@
    "DARTMOUTH",                        /* Name */
    D64,                                /* OptionVersionBitmask */
    "D64",                        /* ID */
+#ifndef NO_HELP
    "Dartmouth DTSS BASIC",        /* Description */
    "BASIC",                        /* Reference Title */
    "by Computation Center, Dartmouth College",        /* Reference Author */
    "(c) 1964, Trustees of Dartmouth College",        /* Reference Copyright */
    "http://www.bitsavers.org/pdf/dartmouth/",        /* Reference URL1 */
    "BASIC_Oct64.pdf",                /* Reference URL2 */
+#endif
    FALSE,                        /* OptionFlags */
    128,                                /* OptionReclenInteger */
    0,                                /* OptionBaseInteger */
@@ -277,12 +287,14 @@
    "ECMA-55",                        /* Name */
    E78,                                /* OptionVersionBitmask */
    "E78",                        /* ID */
+#ifndef NO_HELP
    "ANSI Minimal BASIC",        /* Description */
    "STANDARD ECMA-55: Minimal BASIC",        /* Reference Title */
    "by EUROPEAN COMPUTER MANUFACTURERS ASSOCIATION",        /* Reference Author */
    "(c) 1978, EUROPEAN COMPUTER MANUFACTURERS ASSOCIATION",        /* Reference Copyright */
    "http://www.ecma-international.org/publications/files/",        /* Reference URL1 */
    "ECMA-ST-WITHDRAWN/ECMA-55,%201st%20Edition,%20January%201978.pdf",        /* Reference URL2 */
+#endif
    FALSE,                        /* OptionFlags */
    128,                                /* OptionReclenInteger */
    0,                                /* OptionBaseInteger */
@@ -323,12 +335,14 @@
    "ECMA-116",                        /* Name */
    E86,                                /* OptionVersionBitmask */
    "E86",                        /* ID */
+#ifndef NO_HELP
    "ANSI Full BASIC",                /* Description */
    "STANDARD ECMA-116: Full BASIC",        /* Reference Title */
    "by EUROPEAN COMPUTER MANUFACTURERS ASSOCIATION",        /* Reference Author */
    "(c) 1986, EUROPEAN COMPUTER MANUFACTURERS ASSOCIATION",        /* Reference Copyright */
    "http://www.ecma-international.org/publications/files/",        /* Reference URL1 */
    "ECMA-ST-WITHDRAWN/ECMA-116,%201st%20edition,%20June%201986.pdf",        /* Reference URL2 */
+#endif
    OPTION_LABELS_ON | OPTION_STRICT_ON,        /* OptionFlags */
    128,                                /* OptionReclenInteger */
    1,                                /* OptionBaseInteger */
@@ -369,12 +383,14 @@
    "GCOS",                        /* Name */
    G74,                                /* OptionVersionBitmask */
    "G74",                        /* ID */
+#ifndef NO_HELP
    "GE 600 Mainframe BASIC",        /* Description */
    "TIME-SHARING SYSTEM POCKET GUIDE, SERIES 600/6000 GCOS",        /* Reference Title */
    "by Honeywell",                /* Reference Author */
    "(c) 1974, Honeywell",        /* Reference Copyright */
    "http://www.trailingedge.com/misc/",        /* Reference URL1 */
    "GCOS-TSS-PocketGuide.pdf",        /* Reference URL2 */
+#endif
    FALSE,                        /* OptionFlags */
    128,                                /* OptionReclenInteger */
    0,                                /* OptionBaseInteger */
@@ -415,12 +431,14 @@
    "HAARDT",                        /* Name */
    H14,                                /* OptionVersionBitmask */
    "H14",                        /* ID */
+#ifndef NO_HELP
    "bas 2.4 by Michael Haardt",        /* Description */
    "BAS",                        /* Reference Title */
    "by by Michael Haardt",        /* Reference Author */
    "(c) 2014, by Michael Haardt",        /* Reference Copyright */
    "http://www.moria.de/~michael/bas/",        /* Reference URL1 */
    "bas-2.4.tar.gz",                /* Reference URL2 */
+#endif
    OPTION_BUGS_ON,                /* OptionFlags */
    1,                                /* OptionReclenInteger */
    0,                                /* OptionBaseInteger */
@@ -461,12 +479,14 @@
    "HANDBOOK1",                        /* Name */
    HB1,                                /* OptionVersionBitmask */
    "HB1",                        /* ID */
+#ifndef NO_HELP
    "The BASIC Handbook, 1st Edition",        /* Description */
    "The BASIC Handbook: Encyclopedia of the BASIC Computer Language",        /* Reference Title */
    "by David A. Lien",                /* Reference Author */
    "(c) 1978, Compusoft Publishing",        /* Reference Copyright */
    "ISBN 0-932760-00-7",        /* Reference URL1 */
    "(1st Edition) 364 pages",        /* Reference URL2 */
+#endif
    OPTION_BUGS_ON,                /* OptionFlags */
    128,                                /* OptionReclenInteger */
    0,                                /* OptionBaseInteger */
@@ -507,12 +527,14 @@
    "HANDBOOK2",                        /* Name */
    HB2,                                /* OptionVersionBitmask */
    "HB2",                        /* ID */
+#ifndef NO_HELP
    "The BASIC Handbook, 2nd Edition",        /* Description */
    "The BASIC Handbook: Encyclopedia of the BASIC Computer Language",        /* Reference Title */
    "by David A. Lien",                /* Reference Author */
    "(c) 1981, CompuSoft Publishing",        /* Reference Copyright */
    "ISBN 0-932760-05-8",        /* Reference URL1 */
    "(2nd Edition) 480 pages",        /* Reference URL2 */
+#endif
    OPTION_BUGS_ON,                /* OptionFlags */
    128,                                /* OptionReclenInteger */
    0,                                /* OptionBaseInteger */
@@ -553,12 +575,14 @@
    "HEATH",                        /* Name */
    H80,                                /* OptionVersionBitmask */
    "H80",                        /* ID */
+#ifndef NO_HELP
    "Heath Benton Harbor BASIC",        /* Description */
    "Extended Benton Harbor BASIC",        /* Reference Title */
    "by Heath Company",                /* Reference Author */
    "(c) 1980, Heath Company",        /* Reference Copyright */
    "http://www.lesbird.com/sebhc/documentation/software/HDOS-2/",        /* Reference URL1 */
    "HDOS_Reference_Chapter6.pdf",        /* Reference URL2 */
+#endif
    OPTION_BUGS_ON,                /* OptionFlags */
    0,                                /* OptionReclenInteger */
    0,                                /* OptionBaseInteger */
@@ -599,12 +623,14 @@
    "MARK-I",                        /* Name */
    G65,                                /* OptionVersionBitmask */
    "G65",                        /* ID */
+#ifndef NO_HELP
    "GE 265 Mainframe BASIC",        /* Description */
    "BASIC LANGUAGE REFERENCE MANUAL",        /* Reference Title */
    "by Time-Sharing Service, Information Service Department, General Electric",        /* Reference Author */
    "(c) 1965, Trustees of Dartmouth College",        /* Reference Copyright */
    "http://www.bitsavers.org/pdf/ge/MarkI_Timesharing/",        /* Reference URL1 */
    "202026A_BASIC_Language_Reference_Manual_Jan1967.pdf",        /* Reference URL2 */
+#endif
    FALSE,                        /* OptionFlags */
    128,                                /* OptionReclenInteger */
    0,                                /* OptionBaseInteger */
@@ -645,12 +671,14 @@
    "MARK-II",                        /* Name */
    G67,                                /* OptionVersionBitmask */
    "G67",                        /* ID */
+#ifndef NO_HELP
    "GE 435 Mainframe BASIC",        /* Description */
    "BASIC Language Reference Manual",        /* Reference Title */
    "by Time-Sharing Service, Information Service Department, General Electric",        /* Reference Author */
    "(c) 1968, General Electric Company and the Trustees of Dartmouth College",        /* Reference Copyright */
    "http://www.bitsavers.org/pdf/ge/MarkI_Timesharing/",        /* Reference URL1 */
    "711224A_BASICLanguageReferenceManual_Nov1970.pdf",        /* Reference URL2 */
+#endif
    FALSE,                        /* OptionFlags */
    128,                                /* OptionReclenInteger */
    0,                                /* OptionBaseInteger */
@@ -691,12 +719,14 @@
    "MBASIC",                        /* Name */
    M80,                                /* OptionVersionBitmask */
    "M80",                        /* ID */
+#ifndef NO_HELP
    "Microsoft BASIC-80 for Xenix",        /* Description */
    "Microsoft BASIC Reference Manual",        /* Reference Title */
    "by Microsoft",                /* Reference Author */
    "(c) 1982, Microsoft",        /* Reference Copyright */
    "http://chiclassiccomp.org/docs/content/computing/Microsoft/",        /* Reference URL1 */
    "Microsoft_Basic_8086Xenix_Reference.pdf",        /* Reference URL2 */
+#endif
    OPTION_BUGS_ON,                /* OptionFlags */
    128,                                /* OptionReclenInteger */
    0,                                /* OptionBaseInteger */
@@ -737,12 +767,14 @@
    "PDP-8",                        /* Name */
    D73,                                /* OptionVersionBitmask */
    "D73",                        /* ID */
+#ifndef NO_HELP
    "DEC PDP-8 BASIC",                /* Description */
    "DEC 8K BASIC",                /* Reference Title */
    "by Digital Equipement Corporation",        /* Reference Author */
    "(c) 1973, Digital Equipement Corporation",        /* Reference Copyright */
    "http://bitsavers.trailing-edge.com/pdf/dec/pdp8/basic/",        /* Reference URL1 */
    "DEC-08-LBSMA-A-D_8K_BASIC_Jul73.pdf",        /* Reference URL2 */
+#endif
    OPTION_BUGS_ON,                /* OptionFlags */
    128,                                /* OptionReclenInteger */
    0,                                /* OptionBaseInteger */
@@ -783,12 +815,14 @@
    "PDP-11",                        /* Name */
    D70,                                /* OptionVersionBitmask */
    "D70",                        /* ID */
+#ifndef NO_HELP
    "DEC PDP-11 BASIC",                /* Description */
    "PDP-11 BASIC Programming Manual",        /* Reference Title */
    "by Digital Equipement Corporation",        /* Reference Author */
    "(c) 1970, Digital Equipement Corporation",        /* Reference Copyright */
    "http://bitsavers.trailing-edge.com/pdf/dec/pdp11/basic/",        /* Reference URL1 */
    "DEC-11-AJPB-D_PDP-11_BASIC_Programming_Manual_Dec70.pdf",        /* Reference URL2 */
+#endif
    OPTION_BUGS_ON,                /* OptionFlags */
    128,                                /* OptionReclenInteger */
    0,                                /* OptionBaseInteger */
@@ -829,12 +863,14 @@
    "RBASIC",                        /* Name */
    R86,                                /* OptionVersionBitmask */
    "R86",                        /* ID */
+#ifndef NO_HELP
    "Micronics RBASIC for 6809 FLEX",        /* Description */
    "RBASIC User's Manual",        /* Reference Title */
    "by R. Jones",                /* Reference Author */
    "(c) 1986, Micronics Research Corp.",        /* Reference Copyright */
    "http://www.evenson-consulting.com/swtpc/downloads/",        /* Reference URL1 */
    "RBASIC.zip",                /* Reference URL2 */
+#endif
    OPTION_BUGS_ON,                /* OptionFlags */
    0,                                /* OptionReclenInteger */
    0,                                /* OptionBaseInteger */
@@ -875,12 +911,14 @@
    "RSTS-11",                        /* Name */
    D71,                                /* OptionVersionBitmask */
    "D71",                        /* ID */
+#ifndef NO_HELP
    "DEC RSTS-11 BASIC-PLUS",        /* Description */
    "RSTS-11 User's Guide : BASIC-PLUS Programming Language",        /* Reference Title */
    "by Digital Equipment Corporation",        /* Reference Author */
    "(c) 1971, Digital Equipment Corporation",        /* Reference Copyright */
    "http://bitsavers.trailing-edge.com/pdf/dec/pdp11/rsts/",        /* Reference URL1 */
    "PL-11-71-01-01-A-D_RSTS-11UsersGuide_May71.pdf",        /* Reference URL2 */
+#endif
    OPTION_BUGS_ON,                /* OptionFlags */
    512,                                /* OptionReclenInteger */
    0,                                /* OptionBaseInteger */
@@ -921,12 +959,14 @@
    "SYSTEM/360",                /* Name */
    I70,                                /* OptionVersionBitmask */
    "I70",                        /* ID */
+#ifndef NO_HELP
    "IBM System/360 Mainframe BASIC",        /* Description */
    "BASIC Language Reference Manual",        /* Reference Title */
    "by International Business Machines Corporation",        /* Reference Author */
    "(c) 1970, International Business Machines Corporation",        /* Reference Copyright */
    "http://bitsavers.org/pdf/ibm/360/os/tso/",        /* Reference URL1 */
    "GC28-6837-0_BASIC_Language_Ref_Man_Jun70.pdf",        /* Reference URL2 */
+#endif
    FALSE,                        /* OptionFlags */
    0,                                /* OptionReclenInteger */
    1,                                /* OptionBaseInteger */
@@ -967,12 +1007,14 @@
    "SYSTEM/370",                /* Name */
    I73,                                /* OptionVersionBitmask */
    "I73",                        /* ID */
+#ifndef NO_HELP
    "IBM System/370 Mainframe BASIC",        /* Description */
    "IBM Virtual Machine Facility/370: BASIC Language Reference Manual",        /* Reference Title */
    "by International Business Machines Corporation",        /* Reference Author */
    "(c) 1973, International Business Machines Corporation",        /* Reference Copyright */
    "http://bitsavers.trailing-edge.com/pdf/ibm/370/VM_370/Release_1/",        /* Reference URL1 */
    "GC20-1803-1_VM370_BASIC_Language_Reference_Manual_Rel_1_Apr73.pdf",        /* Reference URL2 */
+#endif
    FALSE,                        /* OptionFlags */
    0,                                /* OptionReclenInteger */
    1,                                /* OptionBaseInteger */
@@ -1013,12 +1055,14 @@
    "TRS-80",                        /* Name */
    T80,                                /* OptionVersionBitmask */
    "T80",                        /* ID */
+#ifndef NO_HELP
    "TRS-80 Model I/III/4 LBASIC",        /* Description */
    "LBASIC USER'S GUIDE",        /* Reference Title */
    "by Galactic Software, Ltd.",        /* Reference Author */
    "(c) 1981, Galactic Software, Ltd.",        /* Reference Copyright */
    "http://www.tim-mann.org/trs80/doc/",        /* Reference URL1 */
    "lbasic.txt",                /* Reference URL2 */
+#endif
    OPTION_BUGS_ON,                /* OptionFlags */
    128,                                /* OptionReclenInteger */
    0,                                /* OptionBaseInteger */
@@ -1059,12 +1103,14 @@
    "VINTAGE",                        /* Name */
    V09,                                /* OptionVersionBitmask */
    "V09",                        /* ID */
+#ifndef NO_HELP
    "Vintage BASIC 1.0.1",        /* Description */
    "Vintage BASIC User's Guide 1.0.1",        /* Reference Title */
    "by Lyle Kopnicky",                /* Reference Author */
    "(c) 2009, Lyle Kopnicky",        /* Reference Copyright */
    "http://www.vintage-basic.net/",        /* Reference URL1 */
    "vintage-basic-1.0.1.tar.gz",        /* Reference URL2 */
+#endif
    OPTION_BUGS_ON,                /* OptionFlags */
    128,                                /* OptionReclenInteger */
    0,                                /* OptionBaseInteger */
@@ -1105,12 +1151,14 @@
    "XBASIC",                        /* Name */
    T79,                                /* OptionVersionBitmask */
    "T79",                        /* ID */
+#ifndef NO_HELP
    "TSC XBASIC for 6800 FLEX",        /* Description */
    "Extended BASIC User's Manual",        /* Reference Title */
    "by Technical Systems Consultants",        /* Reference Author */
    "(c) 1979, Technical Systems Consultants",        /* Reference Copyright */
    "http://www.swtpc.com/mholley/Setton/",        /* Reference URL1 */
    "xbasic.pdf",                /* Reference URL2 */
+#endif
    OPTION_BUGS_ON,                /* OptionFlags */
    0,                                /* OptionReclenInteger */
    0,                                /* OptionBaseInteger */
@@ -1151,12 +1199,14 @@
    "GW-BASIC",                        /* Name */
    M86,                                /* OptionVersionBitmask */
    "M86",                        /* ID */
+#ifndef NO_HELP
    "Microsoft GW-BASIC 3.23",        /* Description */
    "Microsoft BASIC Reference Manual",        /* Reference Title */
    "by Microsoft",                /* Reference Author */
    "(c) 1983, 1984, 1985, 1986, 1987, 1988, Microsoft",        /* Reference Copyright */
    "???",        /* Reference URL1 */
    "???",        /* Reference URL2 */
+#endif
    OPTION_BUGS_ON,                /* OptionFlags */
    128,                                /* OptionReclenInteger */
    0,                                /* OptionBaseInteger */
diff -urwN basic/bwb_var.c newbasic/bwb_var.c
--- basic/bwb_var.c	Mon Apr 15 14:33:59 2024
+++ newbasic/bwb_var.c	Mon Apr 15 14:32:23 2024
@@ -3432,8 +3432,10 @@
     bwb_strcpy (tbuf, "\"");
     bwb_strcat (tbuf, bwb_vertable[i].Name);
     bwb_strcat (tbuf, "\"");
+#ifndef NO_HELP
     fprintf (My->SYSOUT->cfp, "OPTION VERSION %-16s ' %s\n", tbuf,
              bwb_vertable[i].Description);
+#endif
   }
   ResetConsoleColumn ();
   line_skip_eol (l);
diff -urwN basic/bwbasic.h newbasic/bwbasic.h
--- basic/bwbasic.h	Mon Apr 15 14:33:59 2024
+++ newbasic/bwbasic.h	Mon Apr 15 14:27:32 2024
@@ -1390,8 +1390,10 @@
 struct IntrinsicFunctionStructure
 {
   const int FunctionID;                      /* F_... */
+#ifndef NO_HELP
   const char *Syntax;                        /* the syntax of the function */
   const char *Description;                   /* the description of the function */
+#endif
   const char *Name;                          /* the name of the function, such as "MID$" */
   const char ReturnTypeCode;                 /* StringTypeCode and so on */
   const unsigned char ParameterCount;        /* 0..MAX_FARGS, 255 == VARIANT (...) */
@@ -1410,8 +1412,10 @@
 struct CommandStructure
 {
   const int CommandID;                     /* C_... */
+#ifndef NO_HELP
   const char *Syntax;                      /* the syntax of the command */
   const char *Description;                 /* the description of the command */
+#endif
   const char *name;                        /* the name of the command, such as "PRINT" */
   OptionVersionType OptionVersionBitmask;  /* OPTION VERSION bitmask */
 };
@@ -1514,12 +1518,14 @@
   const char *Name;                /* OPTION VERSION name$ */
   const OptionVersionType OptionVersionValue;        /* ( D64 ,...) */
   const char *ID;                  /* ("D64",...) */
+#ifndef NO_HELP
   const char *Description;         /* short description of this dialect */
   const char *ReferenceTitle;      /* Reference document */
   const char *ReferenceAuthor;     /* Reference document */
   const char *ReferenceCopyright;  /* Reference document */
   const char *ReferenceURL1;       /* Reference document */
   const char *ReferenceURL2;       /* Reference document */
+#endif
   unsigned short OptionFlags;
   int OptionReclenInteger;         /* OPTION RECLEN      integer: Default RANDOM record length */
   int OptionBaseInteger;           /* OPTION BASE        integer: Default lower bound for arrays */
diff -urwN basic/bwd_cmd.c newbasic/bwd_cmd.c
--- basic/bwd_cmd.c	Mon Apr 15 14:33:59 2024
+++ newbasic/bwd_cmd.c	Mon Apr 15 13:48:17 2024
@@ -47,30 +47,37 @@
 {
 {
   C_APPEND,  /* UniqueID */
+#ifndef NO_HELP
   "APPEND filename$",  /* Syntax */
   "Merges the BASIC program in filename$ into the current BASIC "
   "program; lines in filename$ replace any matching lines in the "
   "current program.",  /* Description */
+#endif
   "APPEND",  /* Name */
   B15 | HB2 | R86 | T79  /* OptionVersionBitmask */
 },
 {
   C_APPEND,  /* UniqueID */
+#ifndef NO_HELP
   "APPEND # filenumber",  /* Syntax */
   "Positions filenumber at EOF and sets the file to writing; filenumber "
   "<= 0 is ignored.",  /* Description */
+#endif
   "APPEND",  /* Name */
   D64 | G74 | G65 | G67  /* OptionVersionBitmask */
 },
 {
   C_AS,  /* UniqueID */
+#ifndef NO_HELP
   "AS",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "AS",  /* Name */
   B15 | B93 | H14 | M80 | M86 | R86 | D71 | T80 | T79   /* OptionVersionBitmask */
 },
 {
   C_AUTO,  /* UniqueID */
+#ifndef NO_HELP
   "AUTO [start [, increment]]",  /* Syntax */
   "Automatic line numbering for manual program entry.  If the line "
   "already exists, then an asterisk is displayed and pressing ENTER "
@@ -79,18 +86,22 @@
   "whether the line exists, entering the command MAN will terminate "
   "AUTO mode.  AUTO mode is also terminated by any ERROR or by pressing "
   "control-C.",  /* Description */
+#endif
   "AUTO",  /* Name */
   B15 | HB1 | HB2 | M80 | M86 | D71 | T80  /* OptionVersionBitmask */
 },
 {
   C_BACKSPACE,  /* UniqueID */
+#ifndef NO_HELP
   "BACKSPACE # X",  /* Syntax */
   "Points the file to the previous item.",  /* Description */
+#endif
   "BACKSPACE",  /* Name */
   D64 | G74 | G65 | G67  /* OptionVersionBitmask */
 },
 {
   C_BREAK,  /* UniqueID */
+#ifndef NO_HELP
   "BREAK line [, ...]]",  /* Syntax */
   "Diagnostic command to stop execution at the specified line(s). "
   " BREAK only applies to user-numbered lines.  For multi-statement "
@@ -99,11 +110,13 @@
   " Once a BREAK occurrs on a specified line, it is automatically "
   "removed.  To remove all existing BREAKs, execute BREAK without "
   "any line numbers.",  /* Description */
+#endif
   "BREAK",  /* Name */
   B15 | HB1 | HB2  /* OptionVersionBitmask */
 },
 {
   C_BUILD,  /* UniqueID */
+#ifndef NO_HELP
   "BUILD [start [, increment]]",  /* Syntax */
   "Automatic line numbering for manual program entry.  If the line "
   "already exists, then an asterisk is displayed and pressing ENTER "
@@ -112,2516 +125,3185 @@
   "whether the line exists, entering the command MAN will terminate "
   "BUILD mode.  BUILD mode is also terminated by any ERROR or by "
   "pressing control-C.",  /* Description */
+#endif
   "BUILD",  /* Name */
   H80  /* OptionVersionBitmask */
 },
 {
   C_BYE,  /* UniqueID */
+#ifndef NO_HELP
   "BYE",  /* Syntax */
   "Exits to the operating system.",  /* Description */
+#endif
   "BYE",  /* Name */
   B15 | D64 | G74 | H14 | HB2 | H80 | G65 | G67 | D73 | D70 | D71  /* OptionVersionBitmask */
 },
 {
   C_CALL,  /* UniqueID */
+#ifndef NO_HELP
   "CALL subname( [parameter [, ...] ] )",  /* Syntax */
   "Calls a subroutine that was defined by SUB and END SUB.",  /* Description */
+#endif
   "CALL",  /* Name */
   B15 | B93 | H14 | HB2  /* OptionVersionBitmask */
 },
 {
   C_CASE,  /* UniqueID */
+#ifndef NO_HELP
   "CASE constant [TO constant]",  /* Syntax */
   "Introduces an element of a SELECT CASE statement.  Multiple tests "
   "must be seperated a comma.  For example:  CASE 1, 2 TO 3, IS "
   "> 4, IF < 5",  /* Description */
+#endif
   "CASE",  /* Name */
   B15 | B93 | E86 | H14  /* OptionVersionBitmask */
 },
 {
   C_CASE,  /* UniqueID */
+#ifndef NO_HELP
   "CASE IF operator constant",  /* Syntax */
   "Introduces an element of a SELECT CASE statement.  Multiple tests "
   "must be seperated a comma.  For example:  CASE 1, 2 TO 3, IS "
   "> 4, IF < 5",  /* Description */
+#endif
   "CASE",  /* Name */
   B15 | B93 | E86 | H14  /* OptionVersionBitmask */
 },
 {
   C_CASE,  /* UniqueID */
+#ifndef NO_HELP
   "CASE IS operator constant",  /* Syntax */
   "Introduces an element of a SELECT CASE statement.  Multiple tests "
   "must be seperated a comma.  For example:  CASE 1, 2 TO 3, IS "
   "> 4, IF < 5",  /* Description */
+#endif
   "CASE",  /* Name */
   B15 | B93 | E86 | H14  /* OptionVersionBitmask */
 },
 {
   C_CASE_ELSE,  /* UniqueID */
+#ifndef NO_HELP
   "CASE ELSE",  /* Syntax */
   "Introduces a default SELECT CASE element.",  /* Description */
+#endif
   "CASE ELSE",  /* Name */
   B15 | B93 | E86 | H14  /* OptionVersionBitmask */
 },
 {
   C_CHAIN,  /* UniqueID */
+#ifndef NO_HELP
   "CHAIN filename$ [, linenumber]",  /* Syntax */
   "Load and execute another BASIC program, without clearing common "
   "variables.  For System/370, the syntax is CHAIN filename$,parameter$.",  /* Description */
+#endif
   "CHAIN",  /* Name */
   B15 | B93 | S70 | C77 | G74 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | R86 | D71 | I70 | I73 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_CHANGE,  /* UniqueID */
+#ifndef NO_HELP
   "CHANGE A$ TO X",  /* Syntax */
   "Changes a string to a numeric array.",  /* Description */
+#endif
   "CHANGE",  /* Name */
   B15 | D64 | G74 | HB2 | G65 | G67 | D71  /* OptionVersionBitmask */
 },
 {
   C_CHANGE,  /* UniqueID */
+#ifndef NO_HELP
   "CHANGE X TO A$",  /* Syntax */
   "Changes a numeric array to a string.",  /* Description */
+#endif
   "CHANGE",  /* Name */
   B15 | D64 | G74 | HB2 | G65 | G67 | D71  /* OptionVersionBitmask */
 },
 {
   C_CLEAR,  /* UniqueID */
+#ifndef NO_HELP
   "CLEAR",  /* Syntax */
   "Sets all numeric variables to 0, and all string variables to "
   "empty strings.",  /* Description */
+#endif
   "CLEAR",  /* Name */
   B15 | B93 | H14 | HB1 | HB2 | H80 | M80 | M86 | R86 | D71 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_CLOAD,  /* UniqueID */
+#ifndef NO_HELP
   "CLOAD [filename$]",  /* Syntax */
   "Loads an ASCII BASIC program into memory.",  /* Description */
+#endif
   "CLOAD",  /* Name */
   B15 | HB1 | HB2 | M80 | M86 | D71 | T80  /* OptionVersionBitmask */
 },
 {
   C_CLOAD8,  /* UniqueID */
+#ifndef NO_HELP
   "CLOAD* arrayname",  /* Syntax */
   "Loads a numeric array from a file saved using CSAVE*.",  /* Description */
+#endif
   "CLOAD*",  /* Name */
   B15 | HB1 | HB2 | M80 | M86 | D71 | T80  /* OptionVersionBitmask */
 },
 {
   C_CLOSE,  /* UniqueID */
+#ifndef NO_HELP
   "CLOSE",  /* Syntax */
   "Closes all files.",  /* Description */
+#endif
   "CLOSE",  /* Name */
   S70 | I70 | I73  /* OptionVersionBitmask */
 },
 {
   C_CLOSE,  /* UniqueID */
+#ifndef NO_HELP
   "CLOSE filename$ [, ...]",  /* Syntax */
   "Closes a file.",  /* Description */
+#endif
   "CLOSE",  /* Name */
   S70 | I70 | I73  /* OptionVersionBitmask */
 },
 {
   C_CLOSE,  /* UniqueID */
+#ifndef NO_HELP
   "CLOSE filenumber [, ...]",  /* Syntax */
   "Closes a file.",  /* Description */
+#endif
   "CLOSE",  /* Name */
   S70 | I70 | I73  /* OptionVersionBitmask */
 },
 {
   C_CLR,  /* UniqueID */
+#ifndef NO_HELP
   "CLR",  /* Syntax */
   "Sets all numeric variables to 0, and all string variables to "
   "empty strings.",  /* Description */
+#endif
   "CLR",  /* Name */
   HB1 | HB2  /* OptionVersionBitmask */
 },
 {
   C_CMDS,  /* UniqueID */
+#ifndef NO_HELP
   "CMDS",  /* Syntax */
   "Prints a list of all implemented BASIC commands.",  /* Description */
+#endif
   "CMDS",  /* Name */
   B15 | B93  /* OptionVersionBitmask */
 },
 {
   C_COMMON,  /* UniqueID */
+#ifndef NO_HELP
   "COMMON variable [, ...]",  /* Syntax */
   "Designates variables to be passed to a CHAINed program.",  /* Description */
+#endif
   "COMMON",  /* Name */
   B15 | B93 | C77 | E86 | HB2 | M80 | M86 | D71 | T80  /* OptionVersionBitmask */
 },
 {
   C_CONSOLE,  /* UniqueID */
+#ifndef NO_HELP
   "CONSOLE [WIDTH width]",  /* Syntax */
   "Directs the output of PRINT commands to the console (stdout), "
   "and optionally changes the console width.",  /* Description */
+#endif
   "CONSOLE",  /* Name */
   C77  /* OptionVersionBitmask */
 },
 {
   C_CONST,  /* UniqueID */
+#ifndef NO_HELP
   "CONST variable [, ...] = value",  /* Syntax */
   "Assigns the value to variable.  Any later assignment to the variable "
   "causus a VARIABLE NOT DECLARED error.",  /* Description */
+#endif
   "CONST",  /* Name */
   B15  /* OptionVersionBitmask */
 },
 {
   C_CONT,  /* UniqueID */
+#ifndef NO_HELP
   "CONT",  /* Syntax */
   "Continue a BASIC program after a STOP has been executed.  Program "
   "resumes at the line after the STOP.",  /* Description */
+#endif
   "CONT",  /* Name */
   B15 | HB1 | HB2 | M80 | M86 | R86 | D71 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_CONTINUE,  /* UniqueID */
+#ifndef NO_HELP
   "CONTINUE",  /* Syntax */
   "Continue a BASIC program after a STOP has been executed.  Program "
   "resumes at the line after the STOP.",  /* Description */
+#endif
   "CONTINUE",  /* Name */
   H80  /* OptionVersionBitmask */
 },
 {
   C_COPY,  /* UniqueID */
+#ifndef NO_HELP
   "COPY source$ TO target$",  /* Syntax */
   "Copy an exisitng file.",  /* Description */
+#endif
   "COPY",  /* Name */
   H14  /* OptionVersionBitmask */
 },
 {
   C_CREATE,  /* UniqueID */
+#ifndef NO_HELP
   "CREATE filename$ [ RECL reclen ] AS filenum\n[ BUFF number ] [ "
   "RECS size ]",  /* Syntax */
   "Creates the file and opens it.  If the file already exists, then "
   "it is ereased.  If the file cannot be created, then an error "
   "occurs.",  /* Description */
+#endif
   "CREATE",  /* Name */
   C77  /* OptionVersionBitmask */
 },
 {
   C_CSAVE,  /* UniqueID */
+#ifndef NO_HELP
   "CSAVE [filename$]",  /* Syntax */
   "Saves the current program into the file filename$ in ASCII format.",  /* Description */
+#endif
   "CSAVE",  /* Name */
   B15 | HB1 | HB2 | M80 | M86 | D71 | T80  /* OptionVersionBitmask */
 },
 {
   C_CSAVE8,  /* UniqueID */
+#ifndef NO_HELP
   "CSAVE* ArrayName",  /* Syntax */
   "Saves a numeric array into a file for later loading by CLOAD*.",  /* Description */
+#endif
   "CSAVE*",  /* Name */
   B15 | HB1 | HB2 | M80 | M86 | D71 | T80  /* OptionVersionBitmask */
 },
 {
   C_DATA,  /* UniqueID */
+#ifndef NO_HELP
   "DATA constant [, ...]",  /* Syntax */
   "Stores numeric and string constants to be accessed by READ.",  /* Description */
+#endif
   "DATA",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_DEC,  /* UniqueID */
+#ifndef NO_HELP
   "DEC variable [,...]",  /* Syntax */
   "Decrement a numeric variable.",  /* Description */
+#endif
   "DEC",  /* Name */
   H14  /* OptionVersionBitmask */
 },
 {
   C_DEF,  /* UniqueID */
+#ifndef NO_HELP
   "DEF FNname[( arg [,...] )] = value",  /* Syntax */
   "Defines a single-line function.  Single-line functions require "
   "an equal sign.",  /* Description */
+#endif
   "DEF",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_DEF,  /* UniqueID */
+#ifndef NO_HELP
   "DEF FNname[( arg [,...] )]",  /* Syntax */
   "Defines a multiline function.  Multi-line DEF functions do not "
   "have an equal sign and must end with FNEND.",  /* Description */
+#endif
   "DEF",  /* Name */
   B15 | S70 | G74 | HB1 | HB2 | H80 | G67 | D73 | D70 | D71 | I70 | I73 | T80  /* OptionVersionBitmask */
 },
 {
   C_DEFBYT,  /* UniqueID */
+#ifndef NO_HELP
   "DEFBYT letter[-letter] [, ...]",  /* Syntax */
   "Declares variables with single-letter names as numeric variables.",  /* Description */
+#endif
   "DEFBYT",  /* Name */
   B15  /* OptionVersionBitmask */
 },
 {
   C_DEFCUR,  /* UniqueID */
+#ifndef NO_HELP
   "DEFCUR letter[-letter] [, ...]",  /* Syntax */
   "Declares variables with single-letter names as numeric variables.",  /* Description */
+#endif
   "DEFCUR",  /* Name */
   B15  /* OptionVersionBitmask */
 },
 {
   C_DEFDBL,  /* UniqueID */
+#ifndef NO_HELP
   "DEFDBL letter[-letter] [, ...]",  /* Syntax */
   "Declares variables with single-letter names as numeric variables.",  /* Description */
+#endif
   "DEFDBL",  /* Name */
   B15 | B93 | H14 | HB1 | HB2 | M80 | M86 | D71 | T80  /* OptionVersionBitmask */
 },
 {
   C_DEFINT,  /* UniqueID */
+#ifndef NO_HELP
   "DEFINT  letter[-letter] [, ...]",  /* Syntax */
   "Declares variables with single-letter names as numeric variables.",  /* Description */
+#endif
   "DEFINT",  /* Name */
   B15 | B93 | H14 | HB1 | HB2 | M80 | M86 | D71 | T80  /* OptionVersionBitmask */
 },
 {
   C_DEFLNG,  /* UniqueID */
+#ifndef NO_HELP
   "DEFLNG letter[-letter] [, ...]",  /* Syntax */
   "Declares variables with single-letter names as numeric variables.",  /* Description */
+#endif
   "DEFLNG",  /* Name */
   B15  /* OptionVersionBitmask */
 },
 {
   C_DEFSNG,  /* UniqueID */
+#ifndef NO_HELP
   "DEFSNG letter[-letter] [, ...]",  /* Syntax */
   "Declares variables with single-letter names as numeric variables.",  /* Description */
+#endif
   "DEFSNG",  /* Name */
   B15 | B93 | HB1 | HB2 | M80 | M86 | D71 | T80  /* OptionVersionBitmask */
 },
 {
   C_DEFSTR,  /* UniqueID */
+#ifndef NO_HELP
   "DEFSTR letter[-letter] [, ...]",  /* Syntax */
   "Declares variables with single-letter names as string variables.",  /* Description */
+#endif
   "DEFSTR",  /* Name */
   B15 | B93 | H14 | HB1 | HB2 | M80 | M86 | D71 | T80  /* OptionVersionBitmask */
 },
 {
   C_DELETE,  /* UniqueID */
+#ifndef NO_HELP
   "DELETE filenumber",  /* Syntax */
   "Closes and deletes the file OPEN as filenumber.",  /* Description */
+#endif
   "DELETE",  /* Name */
   C77  /* OptionVersionBitmask */
 },
 {
   C_DELETE,  /* UniqueID */
+#ifndef NO_HELP
   "DELETE line [- line]",  /* Syntax */
   "Deletes program lines indicated by the argument(s).  All program "
   "lines have a number, which is visible with the LIST command. "
   " If line numbers are not provided, they are assigned beginning "
   "with 1.  Deleting a non-existing line does not cause an error.",  /* Description */
+#endif
   "DELETE",  /* Name */
   B15 | B93 | H14 | HB1 | HB2 | H80 | M80 | M86 | D73 | D70 | D71 | T80  /* OptionVersionBitmask */
 },
 {
   C_DELIMIT,  /* UniqueID */
+#ifndef NO_HELP
   "DELIMIT # X, A$",  /* Syntax */
   "Sets the delimiter for READ # and WRITE #.",  /* Description */
+#endif
   "DELIMIT",  /* Name */
   G74 | G65 | G67  /* OptionVersionBitmask */
 },
 {
   C_DIM,  /* UniqueID */
+#ifndef NO_HELP
   "DIM [# filenum,] variable([ lower TO ] upper)",  /* Syntax */
   "Declares variables and specifies the dimensions of array variables. "
   " For array variables, if the lower bound is not provided, then "
   "the OPTION BASE value is used.  If filenum is provided, then "
   "the variable is virtual.",  /* Description */
+#endif
   "DIM",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_DISPLAY,  /* UniqueID */
+#ifndef NO_HELP
   "DISPLAY source$",  /* Syntax */
   "Display an exisitng text file.",  /* Description */
+#endif
   "DISPLAY",  /* Name */
   H14  /* OptionVersionBitmask */
 },
 {
   C_DO,  /* UniqueID */
+#ifndef NO_HELP
   "DO UNTIL value",  /* Syntax */
   "Top of a DO - LOOP structure.  Exits when value is non-zero.",  /* Description */
+#endif
   "DO",  /* Name */
   B15 | B93 | E86 | H14  /* OptionVersionBitmask */
 },
 {
   C_DO,  /* UniqueID */
+#ifndef NO_HELP
   "DO",  /* Syntax */
   "Top of a DO - LOOP structure.  If the loop is not terminated "
   "by EXIT DO or LOOP UNTIL or LOOP WHILE, then it will loop forever.",  /* Description */
+#endif
   "DO",  /* Name */
   B15 | B93 | E86 | H14  /* OptionVersionBitmask */
 },
 {
   C_DO,  /* UniqueID */
+#ifndef NO_HELP
   "DO WHILE value",  /* Syntax */
   "Top of a DO - LOOP structure.  Exits when value is zero.",  /* Description */
+#endif
   "DO",  /* Name */
   B15 | B93 | E86 | H14  /* OptionVersionBitmask */
 },
 {
   C_DOS,  /* UniqueID */
+#ifndef NO_HELP
   "DOS",  /* Syntax */
   "Exits to the operating system.",  /* Description */
+#endif
   "DOS",  /* Name */
   R86  /* OptionVersionBitmask */
 },
 {
   C_DSP,  /* UniqueID */
+#ifndef NO_HELP
   "DSP variable [, ...]]",  /* Syntax */
   "Diagnostic command to display the value every time the variable "
   "is assigned.  To remove all existing DSPs, execute DSP without "
   "any variables.",  /* Description */
+#endif
   "DSP",  /* Name */
   B15 | HB1 | HB2  /* OptionVersionBitmask */
 },
 {
   C_EDIT,  /* UniqueID */
+#ifndef NO_HELP
   "EDIT",  /* Syntax */
   "implementation defined.",  /* Description */
+#endif
   "EDIT",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | R86 | D71 | I70 | I73 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_ELSE,  /* UniqueID */
+#ifndef NO_HELP
   "ELSE",  /* Syntax */
   "Introduces a default condition in a multi-line IF statement.",  /* Description */
+#endif
   "ELSE",  /* Name */
   B15 | B93 | C77 | E86 | H14 | HB1 | HB2 | H80 | M80 | M86 | D73 | D70 | R86 | D71 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_ELSEIF,  /* UniqueID */
+#ifndef NO_HELP
   "ELSEIF",  /* Syntax */
   "Introduces a secondary condition in a multi-line IF statement.",  /* Description */
+#endif
   "ELSEIF",  /* Name */
   B15 | B93 | C77 | E86 | H14 | HB1 | HB2 | H80 | M80 | M86 | D73 | D70 | R86 | D71 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_END,  /* UniqueID */
+#ifndef NO_HELP
   "END",  /* Syntax */
   "Terminates program execution. If the BASIC program was executed "
   "from the operating system level, then control returns to the "
   "operating system, oterwise control reuturns to the BASIC prompt.",  /* Description */
+#endif
   "END",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_END_FUNCTION,  /* UniqueID */
+#ifndef NO_HELP
   "END FUNCTION",  /* Syntax */
   "Specifies the last line of a multi-line FUNCTION definition.",  /* Description */
+#endif
   "END FUNCTION",  /* Name */
   B15 | B93 | E86 | H14  /* OptionVersionBitmask */
 },
 {
   C_END_IF,  /* UniqueID */
+#ifndef NO_HELP
   "END IF",  /* Syntax */
   "Specifies the last line of a multi-line IF definition.",  /* Description */
+#endif
   "END IF",  /* Name */
   B15 | B93 | C77 | E86 | H14 | HB1 | HB2 | H80 | M80 | M86 | D73 | D70 | R86 | D71 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_END_SELECT,  /* UniqueID */
+#ifndef NO_HELP
   "END SELECT",  /* Syntax */
   "Specifies the last line of a multi-line SELECT CASE definition.",  /* Description */
+#endif
   "END SELECT",  /* Name */
   B15 | B93 | E86 | H14  /* OptionVersionBitmask */
 },
 {
   C_END_SUB,  /* UniqueID */
+#ifndef NO_HELP
   "END SUB",  /* Syntax */
   "Specifies the last line of a multi-line SUB definition.",  /* Description */
+#endif
   "END SUB",  /* Name */
   B15 | B93 | E86 | H14  /* OptionVersionBitmask */
 },
 {
   C_ERASE,  /* UniqueID */
+#ifndef NO_HELP
   "ERASE variable [, ...]",  /* Syntax */
   "Eliminates arrayed variables from a program.",  /* Description */
+#endif
   "ERASE",  /* Name */
   B15 | B93 | H14 | HB1 | HB2 | M80 | M86 | D71 | T80  /* OptionVersionBitmask */
 },
 {
   C_EXCHANGE,  /* UniqueID */
+#ifndef NO_HELP
   "EXCHANGE variable, variable",  /* Syntax */
   "Swaps the values of two variables. Both variables must be of "
   "the same type.",  /* Description */
+#endif
   "EXCHANGE",  /* Name */
   B15 | HB2  /* OptionVersionBitmask */
 },
 {
   C_EXIT,  /* UniqueID */
+#ifndef NO_HELP
   "EXIT",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "EXIT",  /* Name */
   B15 | B93 | E86 | H14 | HB2  /* OptionVersionBitmask */
 },
 {
   C_EXIT_DO,  /* UniqueID */
+#ifndef NO_HELP
   "EXIT DO",  /* Syntax */
   "Immediately exits the inner-most DO-LOOP strucure.",  /* Description */
+#endif
   "EXIT DO",  /* Name */
   B15 | B93 | E86 | H14  /* OptionVersionBitmask */
 },
 {
   C_EXIT_FOR,  /* UniqueID */
+#ifndef NO_HELP
   "EXIT FOR",  /* Syntax */
   "Immediately exits the inner-most FOR-NEXT strucure.",  /* Description */
+#endif
   "EXIT FOR",  /* Name */
   B15 | B93 | E86 | H14 | HB2  /* OptionVersionBitmask */
 },
 {
   C_EXIT_FUNCTION,  /* UniqueID */
+#ifndef NO_HELP
   "EXIT FUNCTION",  /* Syntax */
   "Immediately exits the inner-most multi-line FUNCTION strucure.",  /* Description */
+#endif
   "EXIT FUNCTION",  /* Name */
   B15 | B93 | E86 | H14  /* OptionVersionBitmask */
 },
 {
   C_EXIT_REPEAT,  /* UniqueID */
+#ifndef NO_HELP
   "EXIT REPEAT",  /* Syntax */
   "Exit a REPEAT - UNTIL structure.",  /* Description */
+#endif
   "EXIT REPEAT",  /* Name */
   B15 | H14 | HB2  /* OptionVersionBitmask */
 },
 {
   C_EXIT_SUB,  /* UniqueID */
+#ifndef NO_HELP
   "EXIT SUB",  /* Syntax */
   "Immediately exits the inner-most multi-line SUB strucure.",  /* Description */
+#endif
   "EXIT SUB",  /* Name */
   B15 | B93 | E86 | H14  /* OptionVersionBitmask */
 },
 {
   C_EXIT_WHILE,  /* UniqueID */
+#ifndef NO_HELP
   "EXIT WHILE",  /* Syntax */
   "Immediately exits the inner-most WHILE-END strucure.",  /* Description */
+#endif
   "EXIT WHILE",  /* Name */
   B15 | B93 | E86  /* OptionVersionBitmask */
 },
 {
   C_FEND,  /* UniqueID */
+#ifndef NO_HELP
   "FEND",  /* Syntax */
   "Specifies the last line of a multi-line DEF function.",  /* Description */
+#endif
   "FEND",  /* Name */
   C77  /* OptionVersionBitmask */
 },
 {
   C_FIELD,  /* UniqueID */
+#ifndef NO_HELP
   "FIELD [#] filenum, number AS variable$ [, ...]",  /* Syntax */
   "Assigns number bytes in the buffer of random file filenum to "
   "the variable variable$.  GET will automatically update the variable, "
   "and PUT will automatically use the variable.",  /* Description */
+#endif
   "FIELD",  /* Name */
   B15 | B93 | H14 | M80 | M86 | R86 | D71 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_FILE,  /* UniqueID */
+#ifndef NO_HELP
   "FILE filename$ [( reclen )]",  /* Syntax */
   "Opens the file in READ mode.",  /* Description */
+#endif
   "FILE",  /* Name */
   C77  /* OptionVersionBitmask */
 },
 {
   C_FILE,  /* UniqueID */
+#ifndef NO_HELP
   "FILE # X, A$",  /* Syntax */
   "If A$ is \"*\" then closes file # X.  If A$ is not \"*\" then opens "
   "the file named A$ in READ mode.",  /* Description */
+#endif
   "FILE",  /* Name */
   C77 | D64 | G74 | G65 | G67  /* OptionVersionBitmask */
 },
 {
   C_FILES,  /* UniqueID */
+#ifndef NO_HELP
   "FILES A$[, ...]",  /* Syntax */
   "If A$ is not \"*\" opens the file named A$ in READ mode.  The first "
   "filename of the first FILES command is assocated with file number "
   "1.  Note that multiple FILES commands accumulate.",  /* Description */
+#endif
   "FILES",  /* Name */
   D64 | G74 | G65 | G67  /* OptionVersionBitmask */
 },
 {
   C_FLEX,  /* UniqueID */
+#ifndef NO_HELP
   "FLEX",  /* Syntax */
   "Exits to the operating system.",  /* Description */
+#endif
   "FLEX",  /* Name */
   T79  /* OptionVersionBitmask */
 },
 {
   C_FNCS,  /* UniqueID */
+#ifndef NO_HELP
   "FNCS",  /* Syntax */
   "Prints a list of all pre-defined BASIC functions.",  /* Description */
+#endif
   "FNCS",  /* Name */
   B15 | B93  /* OptionVersionBitmask */
 },
 {
   C_FNEND,  /* UniqueID */
+#ifndef NO_HELP
   "FNEND",  /* Syntax */
   "Specifies the last line of a multi-line DEF function.",  /* Description */
+#endif
   "FNEND",  /* Name */
   B15 | S70 | G74 | HB1 | HB2 | H80 | G67 | D73 | D70 | D71 | I70 | I73 | T80  /* OptionVersionBitmask */
 },
 {
   C_FOR,  /* UniqueID */
+#ifndef NO_HELP
   "FOR variable = start TO finish [STEP increment]",  /* Syntax */
   "Top of a FOR - NEXT structure.  The loop will continue a fixed "
   "number of times, which is determined by the values of start, "
   "finish, and increment.",  /* Description */
+#endif
   "FOR",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_FUNCTION,  /* UniqueID */
+#ifndef NO_HELP
   "FUNCTION [ ( parameter [, ...  ] ) ]",  /* Syntax */
   "Top line of a multi-line FUNCTION definition.  The variable names "
   "specified are local to the FUNCTION definition, and are initialized "
   "BYVAL when the function is invoked by another routine.",  /* Description */
+#endif
   "FUNCTION",  /* Name */
   B15 | B93 | E86 | H14  /* OptionVersionBitmask */
 },
 {
   C_GET,  /* UniqueID */
+#ifndef NO_HELP
   "GET # file_number , [ byte_number ] , scalar [,...]",  /* Syntax */
   "Gets one (or more) values from a BINARY file.",  /* Description */
+#endif
   "GET",  /* Name */
   H14  /* OptionVersionBitmask */
 },
 {
   C_GET,  /* UniqueID */
+#ifndef NO_HELP
   "GET # file_number [ , RECORD record_number ]",  /* Syntax */
   "Gets one (or more) values from a file.",  /* Description */
+#endif
   "GET",  /* Name */
   R86 | D71 | T79  /* OptionVersionBitmask */
 },
 {
   C_GET,  /* UniqueID */
+#ifndef NO_HELP
   "GET # file_number [ , RECORD record_number ]",  /* Syntax */
   "Gets one (or more) values from a file.",  /* Description */
+#endif
   "GET",  /* Name */
   R86 | D71 | T79  /* OptionVersionBitmask */
 },
 {
   C_GET,  /* UniqueID */
+#ifndef NO_HELP
   "GET filename$ , scalar [, ...]",  /* Syntax */
   "Gets one (or more) values from a file.",  /* Description */
+#endif
   "GET",  /* Name */
   S70 | I70 | I73  /* OptionVersionBitmask */
 },
 {
   C_GET,  /* UniqueID */
+#ifndef NO_HELP
   "GET # file_number [ , record_number ]",  /* Syntax */
   "Gets one (or more) values from a RANDOM file.",  /* Description */
+#endif
   "GET",  /* Name */
   H14  /* OptionVersionBitmask */
 },
 {
   C_GO,  /* UniqueID */
+#ifndef NO_HELP
   "GO",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "GO",  /* Name */
   B15 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_GO_SUB,  /* UniqueID */
+#ifndef NO_HELP
   "GO SUB line",  /* Syntax */
   "Initiates a subroutine call to the line specified.  The subroutine "
   "must end with RETURN.  The line may be a number or a label.",  /* Description */
+#endif
   "GO SUB",  /* Name */
   B15 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_GO_TO,  /* UniqueID */
+#ifndef NO_HELP
   "GO TO line",  /* Syntax */
   "Branches program execution to the specified line.  The line may "
   "be a number or a label.",  /* Description */
+#endif
   "GO TO",  /* Name */
   B15 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_GOODBYE,  /* UniqueID */
+#ifndef NO_HELP
   "GOODBYE",  /* Syntax */
   "Exits to the operating system.",  /* Description */
+#endif
   "GOODBYE",  /* Name */
   B15 | D64 | G74 | HB2 | G65 | G67 | D71  /* OptionVersionBitmask */
 },
 {
   C_GOSUB,  /* UniqueID */
+#ifndef NO_HELP
   "GOSUB line",  /* Syntax */
   "Initiates a subroutine call to the line specified.  The subroutine "
   "must end with RETURN.  The line may be a number or a label.",  /* Description */
+#endif
   "GOSUB",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_GOTO,  /* UniqueID */
+#ifndef NO_HELP
   "GOTO line",  /* Syntax */
   "Branches program execution to the specified line.  The line may "
   "be a number or a label.",  /* Description */
+#endif
   "GOTO",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_HELP,  /* UniqueID */
+#ifndef NO_HELP
   "HELP name",  /* Syntax */
   "Provides help on the specified name which is a command name or "
   "function name.",  /* Description */
+#endif
   "HELP",  /* Name */
   B15  /* OptionVersionBitmask */
 },
 {
   C_IF,  /* UniqueID */
+#ifndef NO_HELP
   "IF value THEN line1 [ELSE line2]",  /* Syntax */
   "Single line standard IF command.  If the value is non-zero, then "
   "branh to line1.  If the value is zero and ELSE is provided, then "
   "branch to line2.  Otherwise continue to the next line.  LABELS "
   "are not allowed.",  /* Description */
+#endif
   "IF",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_IF_END,  /* UniqueID */
+#ifndef NO_HELP
   "IF END # filenum THEN line1 [ELSE line2]",  /* Syntax */
   "Single line standard IF command.  If the file is at EOF , then "
   "branch to line1.  If the file is not at EOF and ELSE is provided, "
   "then branch to line2.  Otherwise continue to the next line.  "
   "LABELS are not allowed.",  /* Description */
+#endif
   "IF END",  /* Name */
   C77 | D64 | G74 | G65 | G67  /* OptionVersionBitmask */
 },
 {
   C_IF_MORE,  /* UniqueID */
+#ifndef NO_HELP
   "IF MORE # filenum THEN line1 [ELSE line2]",  /* Syntax */
   "Single line standard IF command.  If the file is not at EOF , "
   "then branch to line1.  If the file is at EOF and ELSE is provided, "
   "then branch to line2.  Otherwise continue to the next line.  "
   "LABELS are not allowed.",  /* Description */
+#endif
   "IF MORE",  /* Name */
   D64 | G74 | G65 | G67  /* OptionVersionBitmask */
 },
 {
   C_IF8THEN,  /* UniqueID */
+#ifndef NO_HELP
   "IF value THEN",  /* Syntax */
   "Top of a multi-line IF - END IF structure.  If the value is non-zero, "
   "then the program lines upto the next ELSE or ELSE IF command "
   "are executed, otherwise the program branches to the next ELSE "
   "or ELSE IF command.",  /* Description */
+#endif
   "IF*THEN",  /* Name */
   B15 | B93 | C77 | E86 | H14 | HB1 | HB2 | H80 | M80 | M86 | D73 | D70 | R86 | D71 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_IMAGE,  /* UniqueID */
+#ifndef NO_HELP
   "IMAGE \"format string\" ",  /* Syntax */
   "Provides format string for PRINT USING linenum.",  /* Description */
+#endif
   "IMAGE",  /* Name */
   S70 | H14 | HB1 | HB2 | I70 | I73  /* OptionVersionBitmask */
 },
 {
   C_INC,  /* UniqueID */
+#ifndef NO_HELP
   "INC variable [,...]",  /* Syntax */
   "Increment a numeric variable.",  /* Description */
+#endif
   "INC",  /* Name */
   H14  /* OptionVersionBitmask */
 },
 {
   C_INPUT,  /* UniqueID */
+#ifndef NO_HELP
   "INPUT \"prompt string\" , variable [, ...]",  /* Syntax */
   "Reads input from the terminal after displaying a prompt.",  /* Description */
+#endif
   "INPUT",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_INPUT,  /* UniqueID */
+#ifndef NO_HELP
   "INPUT # filenum , variable [, ...]s",  /* Syntax */
   "Reads input from the file specified by filenum.",  /* Description */
+#endif
   "INPUT",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_INPUT,  /* UniqueID */
+#ifndef NO_HELP
   "INPUT variable [, ...]",  /* Syntax */
   "Reads input from the terminal.",  /* Description */
+#endif
   "INPUT",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_INPUT_LINE,  /* UniqueID */
+#ifndef NO_HELP
   "INPUT LINE variable$",  /* Syntax */
   "Reads entire line from the terminal into variable$.",  /* Description */
+#endif
   "INPUT LINE",  /* Name */
   B15 | H80 | M80 | M86 | R86 | D71 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_INPUT_LINE,  /* UniqueID */
+#ifndef NO_HELP
   "INPUT LINE # filenum , variable$",  /* Syntax */
   "Reads entire line from a file into variable$.",  /* Description */
+#endif
   "INPUT LINE",  /* Name */
   B15 | H80 | M80 | M86 | R86 | D71 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_INPUT_LINE,  /* UniqueID */
+#ifndef NO_HELP
   "INPUT LINE \"prompt string\" , variable$",  /* Syntax */
   "Reads entire line from the terminal into variable$ after displaying "
   "a prompt",  /* Description */
+#endif
   "INPUT LINE",  /* Name */
   B15 | H80 | M80 | M86 | R86 | D71 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_LET,  /* UniqueID */
+#ifndef NO_HELP
   "[LET] variable [, ...] = value",  /* Syntax */
   "Assigns the value to the variable.  The LET keyword is optional.",  /* Description */
+#endif
   "LET",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_LINE,  /* UniqueID */
+#ifndef NO_HELP
   "LINE",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "LINE",  /* Name */
   B15 | B93 | H14 | HB2 | H80 | M80 | M86 | R86 | D71 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_LINE_INPUT,  /* UniqueID */
+#ifndef NO_HELP
   "LINE INPUT [[#] filenum,][\"prompt string\";] variable$",  /* Syntax */
   "Reads entire line from the keyboard or a file into variable$.",  /* Description */
+#endif
   "LINE INPUT",  /* Name */
   B15 | B93 | H14 | HB2 | H80 | M80 | M86 | R86 | D71 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_LIST,  /* UniqueID */
+#ifndef NO_HELP
   "LIST line1 [- line2]",  /* Syntax */
   "Lists BASIC program lines from line1 to line2 to the console "
   "on stdout.",  /* Description */
+#endif
   "LIST",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_LISTNH,  /* UniqueID */
+#ifndef NO_HELP
   "LISTNH line1 [- line2]",  /* Syntax */
   "Lists BASIC program lines from line1 to line2 to the console "
   "on stdout.",  /* Description */
+#endif
   "LISTNH",  /* Name */
   B15 | S70 | C77 | D64 | G74 | G65 | G67 | D71 | I70 | I73  /* OptionVersionBitmask */
 },
 {
   C_LLIST,  /* UniqueID */
+#ifndef NO_HELP
   "LLIST line1 [- line2]",  /* Syntax */
   "Lists BASIC program lines from line1 to line2 to the printer "
   "on stderr.",  /* Description */
+#endif
   "LLIST",  /* Name */
   B15 | C77 | H14 | HB2 | M80 | M86 | D71 | T80  /* OptionVersionBitmask */
 },
 {
   C_LOAD,  /* UniqueID */
+#ifndef NO_HELP
   "LOAD [filename$]",  /* Syntax */
   "Loads an ASCII BASIC program into memory.",  /* Description */
+#endif
   "LOAD",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | G65 | G67 | M80 | M86 | R86 | D71 | I70 | I73 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_LOCAL,  /* UniqueID */
+#ifndef NO_HELP
   "LOCAL [# filenum,] variable([ lower TO ] upper)",  /* Syntax */
   "Declares variables and specifies the dimensions of array variables. "
   " For array variables, if the lower bound is not provided, then "
   "the OPTION BASE value is used.  If filenum is provided, then "
   "the variable is virtual.  Only supported inside a FUNCTION or "
   "SUB.",  /* Description */
+#endif
   "LOCAL",  /* Name */
   H14  /* OptionVersionBitmask */
 },
 {
   C_LOOP,  /* UniqueID */
+#ifndef NO_HELP
   "LOOP UNTIL value",  /* Syntax */
   "Bottom of a DO - LOOP structure.  Exits when value is nonz-zero.",  /* Description */
+#endif
   "LOOP",  /* Name */
   B15 | B93 | E86 | H14  /* OptionVersionBitmask */
 },
 {
   C_LOOP,  /* UniqueID */
+#ifndef NO_HELP
   "LOOP WHILE value",  /* Syntax */
   "Bottom of a DO - LOOP structure.  Exits when value is zero.",  /* Description */
+#endif
   "LOOP",  /* Name */
   B15 | B93 | E86 | H14  /* OptionVersionBitmask */
 },
 {
   C_LOOP,  /* UniqueID */
+#ifndef NO_HELP
   "LOOP",  /* Syntax */
   "Bottom of a DO - LOOP structure.  If the loop is not terminated "
   "by EXIT DO or DO UNTIL or DO WHILE, then it will loop forever.",  /* Description */
+#endif
   "LOOP",  /* Name */
   B15 | B93 | E86 | H14  /* OptionVersionBitmask */
 },
 {
   C_LPRINT,  /* UniqueID */
+#ifndef NO_HELP
   "LPRINT [USING format-string$;] value ...",  /* Syntax */
   "Send output to the printer (stderr).",  /* Description */
+#endif
   "LPRINT",  /* Name */
   B15 | S70 | E78 | E86 | H14 | HB2 | M80 | M86 | D71 | I70 | I73 | T80  /* OptionVersionBitmask */
 },
 {
   C_LPRINTER,  /* UniqueID */
+#ifndef NO_HELP
   "LPRINTER [WIDTH width]",  /* Syntax */
   "Directs the output of PRINT commands to the printer (stderr), "
   "and optionally changes the printer width.",  /* Description */
+#endif
   "LPRINTER",  /* Name */
   C77  /* OptionVersionBitmask */
 },
 {
   C_LPT,  /* UniqueID */
+#ifndef NO_HELP
   "LPT [filename$]",  /* Syntax */
   "Directs the PRINT commands to write to the printer (stderr), "
   "or optionally to the specified file.",  /* Description */
+#endif
   "LPT",  /* Name */
   D73  /* OptionVersionBitmask */
 },
 {
   C_LSET,  /* UniqueID */
+#ifndef NO_HELP
   "LSET variable$ = value",  /* Syntax */
   "Left-aligns the value into variable$.  If the length of the value "
   "is too short, then it is padded on the right with spaces.  If "
   "the length of the value is too long, then it is truncated on "
   "the right.  This is only for use with variables assigned to a "
   "random access buffer with FIELD command.",  /* Description */
+#endif
   "LSET",  /* Name */
   B15 | B93 | H14 | M80 | M86 | R86 | D71 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_MAINTAINER,  /* UniqueID */
+#ifndef NO_HELP
   "MAINTAINER",  /* Syntax */
   "This command is reserved for use by the Bywater BASIC maintainer. "
   " It is not for the BASIC programmer.",  /* Description */
+#endif
   "MAINTAINER",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_MAINTAINER_CMDS,  /* UniqueID */
+#ifndef NO_HELP
   "MAINTAINER CMDS",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "MAINTAINER CMDS",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_MAINTAINER_CMDS_HTML,  /* UniqueID */
+#ifndef NO_HELP
   "MAINTAINER CMDS HTML",  /* Syntax */
   "Dump COMMAND vs VERSION as HTML table",  /* Description */
+#endif
   "MAINTAINER CMDS HTML",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_MAINTAINER_CMDS_ID,  /* UniqueID */
+#ifndef NO_HELP
   "MAINTAINER CMDS ID",  /* Syntax */
   "Dump COMMAND #define.",  /* Description */
+#endif
   "MAINTAINER CMDS ID",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_MAINTAINER_CMDS_MANUAL,  /* UniqueID */
+#ifndef NO_HELP
   "MAINTAINER CMDS MANUAL",  /* Syntax */
   "Dump COMMAND manual.",  /* Description */
+#endif
   "MAINTAINER CMDS MANUAL",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_MAINTAINER_CMDS_SWITCH,  /* UniqueID */
+#ifndef NO_HELP
   "MAINTAINER CMDS_SWITCH",  /* Syntax */
   "Dump COMMAND switch.",  /* Description */
+#endif
   "MAINTAINER CMDS SWITCH",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_MAINTAINER_CMDS_TABLE,  /* UniqueID */
+#ifndef NO_HELP
   "MAINTAINER CMDS TABLE",  /* Syntax */
   "Dump COMMAND table.",  /* Description */
+#endif
   "MAINTAINER CMDS TABLE",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_MAINTAINER_DEBUG,  /* UniqueID */
+#ifndef NO_HELP
   "MAINTAINER DEBUG",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "MAINTAINER DEBUG",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_MAINTAINER_DEBUG_OFF,  /* UniqueID */
+#ifndef NO_HELP
   "MAINTAINER DEBUG OFF",  /* Syntax */
   "Disable degug tracing.",  /* Description */
+#endif
   "MAINTAINER DEBUG OFF",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_MAINTAINER_DEBUG_ON,  /* UniqueID */
+#ifndef NO_HELP
   "MAINTAINER DEBUG ON",  /* Syntax */
   "Enable degug tracing.",  /* Description */
+#endif
   "MAINTAINER DEBUG ON",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_MAINTAINER_FNCS,  /* UniqueID */
+#ifndef NO_HELP
   "MAINTAINER FNCS",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "MAINTAINER FNCS",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_MAINTAINER_FNCS_HTML,  /* UniqueID */
+#ifndef NO_HELP
   "MAINTAINER FNCS HTML",  /* Syntax */
   "Dump FUNCTION vs VERSION as HTML table.",  /* Description */
+#endif
   "MAINTAINER FNCS HTML",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_MAINTAINER_FNCS_ID,  /* UniqueID */
+#ifndef NO_HELP
   "MAINTAINER FNCS ID",  /* Syntax */
   "Dump FUNCTION #define.",  /* Description */
+#endif
   "MAINTAINER FNCS ID",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_MAINTAINER_FNCS_MANUAL,  /* UniqueID */
+#ifndef NO_HELP
   "MAINTAINER FNCS MANUAL",  /* Syntax */
   "Dump FUNCTION manual.",  /* Description */
+#endif
   "MAINTAINER FNCS MANUAL",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_MAINTAINER_FNCS_SWITCH,  /* UniqueID */
+#ifndef NO_HELP
   "MAINTAINER FNCS SWITCH",  /* Syntax */
   "Dump FUNCTION switch.",  /* Description */
+#endif
   "MAINTAINER FNCS SWITCH",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_MAINTAINER_FNCS_TABLE,  /* UniqueID */
+#ifndef NO_HELP
   "MAINTAINER FNCS TABLE",  /* Syntax */
   "Dump FUNCTION table.",  /* Description */
+#endif
   "MAINTAINER FNCS TABLE",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_MAINTAINER_MANUAL,  /* UniqueID */
+#ifndef NO_HELP
   "MAINTAINER MANUAL",  /* Syntax */
   "Dump manual for the currently selected OPTION VERSION.",  /* Description */
+#endif
   "MAINTAINER MANUAL",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_MAINTAINER_STACK,  /* UniqueID */
+#ifndef NO_HELP
   "MAINTAINER STACK",  /* Syntax */
   "Dump the BASIC stack.",  /* Description */
+#endif
   "MAINTAINER STACK",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_MARGIN,  /* UniqueID */
+#ifndef NO_HELP
   "MARGIN # filenumber, width",  /* Syntax */
   "Sets the file margin for writing; filenumber <= 0 is ignored.",  /* Description */
+#endif
   "MARGIN",  /* Name */
   B15 | D64 | G74 | HB2 | G65 | G67  /* OptionVersionBitmask */
 },
 {
   C_MAT,  /* UniqueID */
+#ifndef NO_HELP
   "MAT arrayname = value",  /* Syntax */
   "Matrix operations:\nMAT A = CON\nMAT A = IDN\nMAT A = ZER\nMAT A "
   "= INV B\nMAT A = TRN B\nMAT A = (k) * B\nMAT A = B\nMAT A = B + C\nMAT "
   "A = B - C\nMAT A = B * C",  /* Description */
+#endif
   "MAT",  /* Name */
   S70 | D64 | G74 | H14 | HB1 | HB2 | G65 | G67 | D71 | I70 | I73  /* OptionVersionBitmask */
 },
 {
   C_MAT_GET,  /* UniqueID */
+#ifndef NO_HELP
   "MAT GET filename$, arrayname",  /* Syntax */
   "Matrix get.",  /* Description */
+#endif
   "MAT GET",  /* Name */
   S70 | G74 | G65 | G67 | I70 | I73  /* OptionVersionBitmask */
 },
 {
   C_MAT_INPUT,  /* UniqueID */
+#ifndef NO_HELP
   "MAT INPUT arrayname",  /* Syntax */
   "Matrix input.",  /* Description */
+#endif
   "MAT INPUT",  /* Name */
   S70 | D64 | G74 | H14 | HB1 | HB2 | G65 | G67 | D71 | I70 | I73  /* OptionVersionBitmask */
 },
 {
   C_MAT_PRINT,  /* UniqueID */
+#ifndef NO_HELP
   "MAT PRINT arrayname",  /* Syntax */
   "Matrix print.",  /* Description */
+#endif
   "MAT PRINT",  /* Name */
   S70 | D64 | G74 | H14 | HB1 | HB2 | G65 | G67 | D71 | I70 | I73  /* OptionVersionBitmask */
 },
 {
   C_MAT_PUT,  /* UniqueID */
+#ifndef NO_HELP
   "MAT PUT filename$, arrayname",  /* Syntax */
   "Matrix put.",  /* Description */
+#endif
   "MAT PUT",  /* Name */
   S70 | G74 | G65 | G67 | I70 | I73  /* OptionVersionBitmask */
 },
 {
   C_MAT_READ,  /* UniqueID */
+#ifndef NO_HELP
   "MAT READ arrayname",  /* Syntax */
   "Matrix read.",  /* Description */
+#endif
   "MAT READ",  /* Name */
   S70 | D64 | G74 | H14 | HB1 | HB2 | G65 | G67 | D71 | I70 | I73  /* OptionVersionBitmask */
 },
 {
   C_MAT_WRITE,  /* UniqueID */
+#ifndef NO_HELP
   "MAT WRITE arrayname",  /* Syntax */
   "Matrix write.",  /* Description */
+#endif
   "MAT WRITE",  /* Name */
   D64 | G74 | H14 | HB1 | HB2 | G65 | G67  /* OptionVersionBitmask */
 },
 {
   C_MERGE,  /* UniqueID */
+#ifndef NO_HELP
   "MERGE filename$",  /* Syntax */
   "Merges the BASIC program in filename$ into the current BASIC "
   "program.  Lines in filename$ replace any matching lines in the "
   "current program.",  /* Description */
+#endif
   "MERGE",  /* Name */
   B15 | B93 | C77 | M80 | M86 | D71 | T80  /* OptionVersionBitmask */
 },
 {
   C_MID4,  /* UniqueID */
+#ifndef NO_HELP
   "MID$( variable$, start [, count ] ) = value",  /* Syntax */
   "Replaces a subtring of variable$ with value.",  /* Description */
+#endif
   "MID$",  /* Name */
   B15 | B93 | C77 | H14 | H80 | M80 | M86 | D71 | T80  /* OptionVersionBitmask */
 },
 {
   C_MON,  /* UniqueID */
+#ifndef NO_HELP
   "MON",  /* Syntax */
   "Exits to the operating system.",  /* Description */
+#endif
   "MON",  /* Name */
   R86  /* OptionVersionBitmask */
 },
 {
   C_NAME,  /* UniqueID */
+#ifndef NO_HELP
   "NAME old$ AS new$",  /* Syntax */
   "Changes the name of an existing file.",  /* Description */
+#endif
   "NAME",  /* Name */
   B15 | B93 | H14 | M80 | M86 | D71 | T80  /* OptionVersionBitmask */
 },
 {
   C_NEW,  /* UniqueID */
+#ifndef NO_HELP
   "NEW",  /* Syntax */
   "Deletes the program in memory and clears all variables.",  /* Description */
+#endif
   "NEW",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_NEXT,  /* UniqueID */
+#ifndef NO_HELP
   "NEXT [variable]",  /* Syntax */
   "The bottom line of a FOR - NEXT structure.",  /* Description */
+#endif
   "NEXT",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OF,  /* UniqueID */
+#ifndef NO_HELP
   "OF",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "OF",  /* Name */
   B15 | S70 | C77 | D64 | E78 | E86 | G74 | HB1 | HB2 | G65 | G67 | M80 | M86 | R86 | D71 | I70 | I73 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_OLD,  /* UniqueID */
+#ifndef NO_HELP
   "OLD [filename$]",  /* Syntax */
   "Loads an ASCII BASIC program into memory.",  /* Description */
+#endif
   "OLD",  /* Name */
   D64 | G74 | H80 | G65 | G67 | D73 | D70 | D71  /* OptionVersionBitmask */
 },
 {
   C_ON,  /* UniqueID */
+#ifndef NO_HELP
   "ON value GOSUB line [, ...]",  /* Syntax */
   "Calls based on the rounded value.",  /* Description */
+#endif
   "ON",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_ON,  /* UniqueID */
+#ifndef NO_HELP
   "ON value GOTO line [, ...]",  /* Syntax */
   "Branches based on the rounded value.",  /* Description */
+#endif
   "ON",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_ON_ERROR,  /* UniqueID */
+#ifndef NO_HELP
   "ON ERROR",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "ON ERROR",  /* Name */
   B15 | B93 | H14 | HB1 | HB2 | M80 | M86 | R86 | D71 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_ON_ERROR_GOSUB,  /* UniqueID */
+#ifndef NO_HELP
   "ON ERROR GOSUB errline",  /* Syntax */
   "When a trappable error occurs, execute GOSUB errline.  The error "
   "handler must terminate with a RETURN command.  If the line number "
   "is 0 (zerp), then use the default error handler.  Valid when "
   "OPTION ERROR GOSUB.",  /* Description */
+#endif
   "ON ERROR GOSUB",  /* Name */
   B15 | B93  /* OptionVersionBitmask */
 },
 {
   C_ON_ERROR_GOTO,  /* UniqueID */
+#ifndef NO_HELP
   "ON ERROR GOTO errline",  /* Syntax */
   "When a trappable error occurs, execute GOTO errline.  The error "
   "handler must terminate with a RESUME command.  If the line number "
   "is 0 (zerp), then use the default error handler.  Valid when "
   "OPTION ERROR GOTO.",  /* Description */
+#endif
   "ON ERROR GOTO",  /* Name */
   B15 | H14 | HB1 | HB2 | M80 | M86 | R86 | D71 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_ON_ERROR_RESUME,  /* UniqueID */
+#ifndef NO_HELP
   "ON ERROR RESUME",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "ON ERROR RESUME",  /* Name */
   B15 | H14 | M80 | M86 | R86 | D71 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_ON_ERROR_RESUME_NEXT,  /* UniqueID */
+#ifndef NO_HELP
   "ON ERROR RESUME NEXT",  /* Syntax */
   "When a trappable error occurs, execution continues with the next "
   "line.  Valid when OPTION ERROR GOTO.",  /* Description */
+#endif
   "ON ERROR RESUME NEXT",  /* Name */
   B15 | H14 | M80 | M86 | R86 | D71 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_ON_ERROR_RETURN,  /* UniqueID */
+#ifndef NO_HELP
   "ON ERROR RETURN",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "ON ERROR RETURN",  /* Name */
   B15  /* OptionVersionBitmask */
 },
 {
   C_ON_ERROR_RETURN_NEXT,  /* UniqueID */
+#ifndef NO_HELP
   "ON ERROR RETURN NEXT",  /* Syntax */
   "When a trappable error occurs, execution continues with the next "
   "line.  Valid when OPTION ERROR GOSUB.",  /* Description */
+#endif
   "ON ERROR RETURN NEXT",  /* Name */
   B15  /* OptionVersionBitmask */
 },
 {
   C_ON_TIMER,  /* UniqueID */
+#ifndef NO_HELP
   "ON TIMER count GOSUB line",  /* Syntax */
   "Specifies a line (or label) to gosub when count seconds have "
   "elaspsed after TIMER ON is executed.  The interrupt routine should "
   "end with a RETURN command.  Timer events only occur in running "
   "BASIC programs.  The resolution of the clock is implementation "
   "defined.",  /* Description */
+#endif
   "ON TIMER",  /* Name */
   B15  /* OptionVersionBitmask */
 },
 {
   C_OPEN,  /* UniqueID */
+#ifndef NO_HELP
   "OPEN NEW|OLD|VIRTUAL filename$\nAS filenumber",  /* Syntax */
   "Opens a file for use.",  /* Description */
+#endif
   "OPEN",  /* Name */
   R86 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPEN,  /* UniqueID */
+#ifndef NO_HELP
   "OPEN filename$\nFOR INPUT|OUTPUT|APPEND|BINARY|RANDOM|VIRTUAL\nAS [#] "
   "fileenumber\n[LEN [=] record-length]",  /* Syntax */
   "Opens a file for use.\nRANDOM requires LEN.",  /* Description */
+#endif
   "OPEN",  /* Name */
   B15 | B93 | H14 | HB2 | M80 | M86 | T80  /* OptionVersionBitmask */
 },
 {
   C_OPEN,  /* UniqueID */
+#ifndef NO_HELP
   "OPEN filename$\nFOR INPUT|OUTPUT|APPEND|BINARY|RANDOM|VIRTUAL\nAS FILE "
   "filenumber\n[ ,RECORDSIZE ignored ]\n[ ,CLUSTERSIZE ignored ]\n[ "
   ",MODE ignored ]",  /* Syntax */
   "Opens a file for use.",  /* Description */
+#endif
   "OPEN",  /* Name */
   D71  /* OptionVersionBitmask */
 },
 {
   C_OPEN,  /* UniqueID */
+#ifndef NO_HELP
   "OPEN filename\nFOR READ|WRITE|VIRTUAL\nAS FILE filenumber",  /* Syntax */
   "Opens a file for use.",  /* Description */
+#endif
   "OPEN",  /* Name */
   H80  /* OptionVersionBitmask */
 },
 {
   C_OPEN,  /* UniqueID */
+#ifndef NO_HELP
   "OPEN filename$\n[ RECL reclen ]\nAS filenumber\n[ BUFF ignored ]\n[ "
   "RECS ignored ]",  /* Syntax */
   "Opens a file for use.",  /* Description */
+#endif
   "OPEN",  /* Name */
   C77  /* OptionVersionBitmask */
 },
 {
   C_OPEN,  /* UniqueID */
+#ifndef NO_HELP
   "OPEN filenumber,\nfilename$,\nINPUT|OUTPUT|APPEND|VIRTUAL",  /* Syntax */
   "Opens a file for use.",  /* Description */
+#endif
   "OPEN",  /* Name */
   S70 | I70 | I73  /* OptionVersionBitmask */
 },
 {
   C_OPTION,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "OPTION",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_ANGLE,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION ANGLE",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "OPTION ANGLE",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_ANGLE_DEGREES,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION ANGLE DEGREES",  /* Syntax */
   "Configures these math functions to accept and return angles in "
   "degrees:  ACOS, ACS, ANGLE, ARCSIN, ASIN, ASN, ARCTAN, ATN, ATAN, "
   "COS, COT, CSC, SEC, SIN and TAN.",  /* Description */
+#endif
   "OPTION ANGLE DEGREES",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_ANGLE_GRADIANS,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION ANGLE GRADIANS",  /* Syntax */
   "Configures these math functions to accept and return angles in "
   "gradians:  ACOS, ANGLE, ASIN, ASN, ATN, ATAN, COS, COT, CSC, "
   "SEC, SIN and TAN.",  /* Description */
+#endif
   "OPTION ANGLE GRADIANS",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_ANGLE_RADIANS,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION ANGLE RADIANS",  /* Syntax */
   "Configures these math functions to accept and return angles in "
   "radians:  ACOS, ANGLE, ASIN, ASN, ATN, ATAN, COS, COT, CSC, SEC, "
   "SIN and TAN.",  /* Description */
+#endif
   "OPTION ANGLE RADIANS",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_ARITHMETIC,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION ARITHMETIC",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "OPTION ARITHMETIC",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_ARITHMETIC_DECIMAL,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION ARITHMETIC DECIMAL",  /* Syntax */
   "Currently has no effect.",  /* Description */
+#endif
   "OPTION ARITHMETIC DECIMAL",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_ARITHMETIC_FIXED,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION ARITHMETIC FIXED",  /* Syntax */
   "Currently has no effect.",  /* Description */
+#endif
   "OPTION ARITHMETIC FIXED",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_ARITHMETIC_NATIVE,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION ARITHMETIC NATIVE",  /* Syntax */
   "Currently has no effect.",  /* Description */
+#endif
   "OPTION ARITHMETIC NATIVE",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_BASE,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION BASE integer",  /* Syntax */
   "Sets the default lowest array subscript.",  /* Description */
+#endif
   "OPTION BASE",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_BUGS,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION BUGS",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "OPTION BUGS",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_BUGS_BOOLEAN,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION BUGS BOOLEAN",  /* Syntax */
   "Boolean results are 1 or 0 instead of bitwise.",  /* Description */
+#endif
   "OPTION BUGS BOOLEAN",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_BUGS_OFF,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION BUGS OFF",  /* Syntax */
   "Disables bugs commonly found in many BASIC dialects.",  /* Description */
+#endif
   "OPTION BUGS OFF",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_BUGS_ON,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION BUGS ON",  /* Syntax */
   "Enables bugs commonly found in many BASIC dialects.",  /* Description */
+#endif
   "OPTION BUGS ON",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_COMPARE,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION COMPARE",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "OPTION COMPARE",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_COMPARE_BINARY,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION COMPARE BINARY",  /* Syntax */
   "Causes string comparisons to be case-sensitive.",  /* Description */
+#endif
   "OPTION COMPARE BINARY",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_COMPARE_DATABASE,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION COMPARE DATABASE",  /* Syntax */
   "Causes string comparisons to be case-insensitive.",  /* Description */
+#endif
   "OPTION COMPARE DATABASE",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_COMPARE_TEXT,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION COMPARE TEXT",  /* Syntax */
   "Causes string comparisons to be case-insensitive.",  /* Description */
+#endif
   "OPTION COMPARE TEXT",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_COVERAGE,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION COVERAGE",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "OPTION COVERAGE",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_COVERAGE_OFF,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION COVERAGE OFF",  /* Syntax */
   "Disables BASIC code coverage recording, displayed using the LIST "
   "command.",  /* Description */
+#endif
   "OPTION COVERAGE OFF",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_COVERAGE_ON,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION COVERAGE ON",  /* Syntax */
   "Enables BASIC code coverage recording, displayed using the LIST "
   "command.",  /* Description */
+#endif
   "OPTION COVERAGE ON",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_DATE,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION DATE format$",  /* Syntax */
   "Sets the date format string used by C strftime() for DATE$.",  /* Description */
+#endif
   "OPTION DATE",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_DIGITS,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION DIGITS integer",  /* Syntax */
   "Sets the number of significant digits for PRINT.  Setting the "
   "value to zero restores the default.",  /* Description */
+#endif
   "OPTION DIGITS",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_DISABLE,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION DISABLE",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "OPTION DISABLE",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_DISABLE_COMMAND,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION DISABLE COMMAND name$",  /* Syntax */
   "Disables the specified BASIC command.",  /* Description */
+#endif
   "OPTION DISABLE COMMAND",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_DISABLE_FUNCTION,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION DISABLE FUNCTION name$",  /* Syntax */
   "Disables the specified BASIC function.",  /* Description */
+#endif
   "OPTION DISABLE FUNCTION",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_DISABLE_OPERATOR,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION DISABLE OPERATOR name$",  /* Syntax */
   "Disables the specified BASIC operator.",  /* Description */
+#endif
   "OPTION DISABLE OPERATOR",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_EDIT,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION EDIT string$",  /* Syntax */
   "Sets the program name used by the EDIT command.",  /* Description */
+#endif
   "OPTION EDIT",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_ENABLE,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION ENABLE",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "OPTION ENABLE",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_ENABLE_COMMAND,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION ENABLE COMMAND name$",  /* Syntax */
   "Enables the specified BASIC command.",  /* Description */
+#endif
   "OPTION ENABLE COMMAND",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_ENABLE_FUNCTION,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION ENABLE FUNCTION name$",  /* Syntax */
   "Enables the specified BASIC function.",  /* Description */
+#endif
   "OPTION ENABLE FUNCTION",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_ENABLE_OPERATOR,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION ENABLE OPERATOR name$",  /* Syntax */
   "Enables the specified BASIC operator.",  /* Description */
+#endif
   "OPTION ENABLE OPERATOR",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_ERROR,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION ERROR",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "OPTION ERROR",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_ERROR_GOSUB,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION ERROR GOSUB",  /* Syntax */
   "When an error occurs, GOSUB to the error handler.  The error "
   "handler exits with RETURN.",  /* Description */
+#endif
   "OPTION ERROR GOSUB",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_ERROR_GOTO,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION ERROR GOTO",  /* Syntax */
   "When an error occurs, GOTO to the error handler.  The error handler "
   "exits with RESUME.",  /* Description */
+#endif
   "OPTION ERROR GOTO",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_EXPLICIT,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION EXPLICIT",  /* Syntax */
   "All variables must be declared using DIM.",  /* Description */
+#endif
   "OPTION EXPLICIT",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_EXTENSION,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION EXTENSION string$",  /* Syntax */
   "Sets the BASIC filename extension, commonly \".bas\".",  /* Description */
+#endif
   "OPTION EXTENSION",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_FILES,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION FILES string$",  /* Syntax */
   "Sets the program name used by the FILES command.",  /* Description */
+#endif
   "OPTION FILES",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_IMPLICIT,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION IMPLICIT",  /* Syntax */
   "Variables need not be declared using DIM, provided arrays have "
   "no more that 10 elements.  This is the opposite of OPTION EXPLICIT, "
   "and is the default for all versions of BASIC.",  /* Description */
+#endif
   "OPTION IMPLICIT",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_INDENT,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION INDENT integer",  /* Syntax */
   "Sets indention level for LIST.  Zero means no indention.  Default "
   "is 2.",  /* Description */
+#endif
   "OPTION INDENT",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_LABELS,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION LABELS",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "OPTION LABELS",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_LABELS_OFF,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION LABELS OFF",  /* Syntax */
   "Disables text labels.",  /* Description */
+#endif
   "OPTION LABELS OFF",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_LABELS_ON,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION LABELS ON",  /* Syntax */
   "Enables text labels.",  /* Description */
+#endif
   "OPTION LABELS ON",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_PROMPT,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION PROMPT string$",  /* Syntax */
   "Sets the BASIC prompt.",  /* Description */
+#endif
   "OPTION PROMPT",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_PUNCT,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION PUNCT",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "OPTION PUNCT",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_PUNCT_AT,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION PUNCT AT char$",  /* Syntax */
   "Sets the PRINT AT character, commonly \"@\".",  /* Description */
+#endif
   "OPTION PUNCT AT",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_PUNCT_BYTE,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION PUNCT BYTE char$",  /* Syntax */
   "Sets the suffix character that indicates a variable is of type "
   "BYTE, commonly \"~\".",  /* Description */
+#endif
   "OPTION PUNCT BYTE",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_PUNCT_COMMENT,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION PUNCT COMMENT char$",  /* Syntax */
   "Sets the shortcut COMMENT character.",  /* Description */
+#endif
   "OPTION PUNCT COMMENT",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_PUNCT_CURRENCY,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION PUNCT CURRENCY char$",  /* Syntax */
   "Sets the suffix character that indicates a variable is of type "
   "CURRENCY, commonly \"@\".",  /* Description */
+#endif
   "OPTION PUNCT CURRENCY",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_PUNCT_DOUBLE,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION PUNCT DOUBLE char$",  /* Syntax */
   "Sets the suffix character that indicates a variable is of type "
   "DOUBLE, commonly \"#\".",  /* Description */
+#endif
   "OPTION PUNCT DOUBLE",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_PUNCT_FILENUM,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION PUNCT FILENUM char$",  /* Syntax */
   "Sets the FILE NUMBER prefix character, commonly \"#\".",  /* Description */
+#endif
   "OPTION PUNCT FILENUM",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_PUNCT_IMAGE,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION PUNCT IMAGE char$",  /* Syntax */
   "Sets the shortcut IMAGE character, commonly \":\".",  /* Description */
+#endif
   "OPTION PUNCT IMAGE",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_PUNCT_INPUT,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION PUNCT INPUT char$",  /* Syntax */
   "Sets the shortcut INPUT character, commonly \"!\".",  /* Description */
+#endif
   "OPTION PUNCT INPUT",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_PUNCT_INTEGER,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION PUNCT INTEGER char$",  /* Syntax */
   "Sets the suffix character that indicates a variable is of type "
   "INTEGER, commonly \"%\".",  /* Description */
+#endif
   "OPTION PUNCT INTEGER",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_PUNCT_LONG,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION PUNCT LONG char$",  /* Syntax */
   "Sets the suffix character that indicates a variable is of type "
   "LONG, commonly \"&\".",  /* Description */
+#endif
   "OPTION PUNCT LONG",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_PUNCT_LPAREN,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION PUNCT LPAREN char$",  /* Syntax */
   "Sets the LEFT PARENTHESIS character, commonly \"(\".",  /* Description */
+#endif
   "OPTION PUNCT LPAREN",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_PUNCT_PRINT,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION PUNCT_PRINT char$",  /* Syntax */
   "Sets the shortcut PRINT character, commonly \"?\".",  /* Description */
+#endif
   "OPTION PUNCT PRINT",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_PUNCT_QUOTE,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION PUNCT QUOTE char$",  /* Syntax */
   "Sets the QUOTE character, commonly \"\"\"",  /* Description */
+#endif
   "OPTION PUNCT QUOTE",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_PUNCT_RPAREN,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION PUNCT RPAREN char$",  /* Syntax */
   "Sets the RIGHT PARENTHESIS character, commonly \")\".",  /* Description */
+#endif
   "OPTION PUNCT RPAREN",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_PUNCT_SINGLE,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION PUNCT SINGLE char$",  /* Syntax */
   "Sets the suffix character that indicates a variable is of type "
   "SINGLE, commonly \"!\".",  /* Description */
+#endif
   "OPTION PUNCT SINGLE",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_PUNCT_STATEMENT,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION PUNCT STATEMENT char$",  /* Syntax */
   "Sets the statement seperator character, commonly \":\".",  /* Description */
+#endif
   "OPTION PUNCT STATEMENT",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_PUNCT_STRING,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION PUNCT STRING char$",  /* Syntax */
   "Sets the suffix character that indicates a variable is of type "
   "STRING, commonly \"$\".",  /* Description */
+#endif
   "OPTION PUNCT STRING",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_RECLEN,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION RECLEN integer",  /* Syntax */
   "Sets the default RANDOM record length.",  /* Description */
+#endif
   "OPTION RECLEN",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_RENUM,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION RENUM string$",  /* Syntax */
   "Sets the program name used by the RENUM command.",  /* Description */
+#endif
   "OPTION RENUM",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_ROUND,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION ROUND",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "OPTION ROUND",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_ROUND_BANK,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION ROUND BANK",  /* Syntax */
   "Round using the Banker rule.",  /* Description */
+#endif
   "OPTION ROUND BANK",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_ROUND_MATH,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION ROUND MATH",  /* Syntax */
   "Round using mathematical rules.",  /* Description */
+#endif
   "OPTION ROUND MATH",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_ROUND_TRUNCATE,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION ROUND TRUNCATE",  /* Syntax */
   "Round using truncation.",  /* Description */
+#endif
   "OPTION ROUND TRUNCATE",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_SCALE,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION SCALE integer",  /* Syntax */
   "Sets the number of digits to round after the decimal point for "
   "PRINT.  Setting the value to zero disables rounding.",  /* Description */
+#endif
   "OPTION SCALE",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_SLEEP,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION SLEEP double",  /* Syntax */
   "Sets multiplier for SLEEP and WAIT.  Zero means no waiting.  "
   "Default is 1.",  /* Description */
+#endif
   "OPTION SLEEP",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_STDERR,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION STDERR filename$",  /* Syntax */
   "Sets the file used for STDERR, which is used by LPRINT commands.",  /* Description */
+#endif
   "OPTION STDERR",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_STDIN,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION STDIN filename$",  /* Syntax */
   "Sets the file used for STDIN, which is used by INPUT commands.",  /* Description */
+#endif
   "OPTION STDIN",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_STDOUT,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION STDOUT filename$",  /* Syntax */
   "Sets the file used for STDOUT, which is used by PRINT commands.",  /* Description */
+#endif
   "OPTION STDOUT",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_STRICT,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION STRICT",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "OPTION STRICT",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_STRICT_OFF,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION STRICT OFF",  /* Syntax */
   "Disables checking for implicit array creation without using the "
   "DIM command.",  /* Description */
+#endif
   "OPTION STRICT OFF",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_STRICT_ON,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION STRICT ON",  /* Syntax */
   "Enables checking for implicit array creation without using the "
   "DIM command.",  /* Description */
+#endif
   "OPTION STRICT ON",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_TERMINAL,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION TERMINAL",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "OPTION TERMINAL",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_TERMINAL_ADM,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION TERMINAL ADM",  /* Syntax */
   "Enables ADM-3A terminal control codes for CLS, COLOR, and LOCATE.",  /* Description */
+#endif
   "OPTION TERMINAL ADM",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_TERMINAL_ANSI,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION TERMINAL ANSI",  /* Syntax */
   "Enables ANSI terminal control codes for CLS, COLOR, and LOCATE.",  /* Description */
+#endif
   "OPTION TERMINAL ANSI",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_TERMINAL_PC,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION TERMINAL PC",  /* Syntax */
   "Enables IBM PC terminal control codes for CLS, COLOR, and LOCATE.",  /* Description */
+#endif
   "OPTION TERMINAL PC",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_TERMINAL_NONE,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION TERMINAL NONE",  /* Syntax */
   "Disables terminal control codes for CLS, COLOR, and LOCATE.",  /* Description */
+#endif
   "OPTION TERMINAL NONE",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_TIME,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION TIME format$",  /* Syntax */
   "Sets the time format string used by C strftime() for TIME$.",  /* Description */
+#endif
   "OPTION TIME",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_TRACE,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION TRACE",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "OPTION TRACE",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_TRACE_OFF,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION TRACE OFF",  /* Syntax */
   "Disables displaying a stack trace when an ERROR occurs.",  /* Description */
+#endif
   "OPTION TRACE OFF",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_TRACE_ON,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION TRACE ON",  /* Syntax */
   "Enables displaying a stack trace when an ERROR occurs.",  /* Description */
+#endif
   "OPTION TRACE ON",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_USING,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION USING",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "OPTION USING",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_USING_ALL,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION USING ALL char$",  /* Syntax */
   "Specifies the magic ALL character for the PRINT USING command. "
   " A common value is \"&\".",  /* Description */
+#endif
   "OPTION USING ALL",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_USING_COMMA,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION USING COMMA char$",  /* Syntax */
   "Specifies the magic COMMA character for the PRINT USING command. "
   " A common value is \",\".",  /* Description */
+#endif
   "OPTION USING COMMA",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_USING_DIGIT,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION USING DIGIT char$",  /* Syntax */
   "Specifies the magic DIGIT character for the PRINT USING command. "
   " A common value is \"#\".",  /* Description */
+#endif
   "OPTION USING DIGIT",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_USING_DOLLAR,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION USING DOLLAR char$",  /* Syntax */
   "Specifies the magic DOLLAR character for the PRINT USING command. "
   " A common value is \"$\".",  /* Description */
+#endif
   "OPTION USING DOLLAR",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_USING_EXRAD,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION USING EXRAD char$",  /* Syntax */
   "Specifies the magic EXRAD character for the PRINT USING command. "
   " A common value is \"^\".",  /* Description */
+#endif
   "OPTION USING EXRAD",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_USING_FILLER,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION USING FILLER char$",  /* Syntax */
   "Specifies the magic FILLER character for the PRINT USING command. "
   " A common value is \"*\".",  /* Description */
+#endif
   "OPTION USING FILLER",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_USING_FIRST,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION USING FIRST char$",  /* Syntax */
   "Specifies the magic FIRST character for the PRINT USING command. "
   " A common value is \"!\".",  /* Description */
+#endif
   "OPTION USING FIRST",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_USING_LENGTH,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION USING LENGTH char$",  /* Syntax */
   "Specifies the magic LENGTH character for the PRINT USING command. "
   " A common value is \"\\\".",  /* Description */
+#endif
   "OPTION USING LENGTH",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_USING_LITERAL,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION USING LITERAL char$",  /* Syntax */
   "Specifies the magic LITERAL character for the PRINT USING command. "
   " A common value is \"_\".",  /* Description */
+#endif
   "OPTION USING LITERAL",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_USING_MINUS,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION USING MINUS char$",  /* Syntax */
   "Specifies the magic MINUS character for the PRINT USING command. "
   " A common value is \"-\".",  /* Description */
+#endif
   "OPTION USING MINUS",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_USING_PERIOD,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION USING PERIOD char$",  /* Syntax */
   "Specifies the magic PERIOD character for the PRINT USING command. "
   " A common value is \".\".",  /* Description */
+#endif
   "OPTION USING PERIOD",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_USING_PLUS,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION USING PLUS char$",  /* Syntax */
   "Specifies the magic PLUS character for the PRINT USING command. "
   " A common value is \"+\".",  /* Description */
+#endif
   "OPTION USING PLUS",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_OPTION_VERSION,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION VERSION version$",  /* Syntax */
   "Selects a specific BASIC version, which is a "
   "combination of OPTION settings, commands, "
   "functions and operators.  If no version is specified, displays "
   "a list of the available versions.",  /* Description */
+#endif
   "OPTION VERSION",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79 | M86 /* OptionVersionBitmask */
 },
 {
   C_OPTION_ZONE,  /* UniqueID */
+#ifndef NO_HELP
   "OPTION ZONE integer",  /* Syntax */
   "Sets the PRINT zone width.  Setting the value to zero restores "
   "the default.",  /* Description */
+#endif
   "OPTION ZONE",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_PAUSE,  /* UniqueID */
+#ifndef NO_HELP
   "PAUSE [comment]",  /* Syntax */
   "Pauses processing until the ENTER key is presseed.",  /* Description */
+#endif
   "PAUSE",  /* Name */
   S70 | I70 | I73  /* OptionVersionBitmask */
 },
 {
   C_PDEL,  /* UniqueID */
+#ifndef NO_HELP
   "PDEL line [- line]",  /* Syntax */
   "Deletes program lines indicated by the argument(s).  All program "
   "lines have a number, which is visible with the LIST command. "
   " If line numbers are not provided, they are assigned beginning "
   "with 1.  Deleting a non-existing line does not cause an error. "
   "",  /* Description */
+#endif
   "PDEL",  /* Name */
   R86 | T79  /* OptionVersionBitmask */
 },
 {
   C_POP,  /* UniqueID */
+#ifndef NO_HELP
   "POP",  /* Syntax */
   "Pops one GOSUB from the return stack.",  /* Description */
+#endif
   "POP",  /* Name */
   B15 | HB2  /* OptionVersionBitmask */
 },
 {
   C_PRINT,  /* UniqueID */
+#ifndef NO_HELP
   "PRINT # filenum , [USING format$;] value ...",  /* Syntax */
   "Sends output to a file.",  /* Description */
+#endif
   "PRINT",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_PRINT,  /* UniqueID */
+#ifndef NO_HELP
   "PRINT [USING format$;] value ...",  /* Syntax */
   "Sends output to the screen.",  /* Description */
+#endif
   "PRINT",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_PTP,  /* UniqueID */
+#ifndef NO_HELP
   "PTP [filename$]",  /* Syntax */
   "Directs the PRINT commands to write to the paper tape punch file "
   "(\"PTP\"), or optionally to the specified file.",  /* Description */
+#endif
   "PTP",  /* Name */
   D73  /* OptionVersionBitmask */
 },
 {
   C_PTR,  /* UniqueID */
+#ifndef NO_HELP
   "PTR [filename$]",  /* Syntax */
   "Directs the INPUT commands to read from the paper tape reader "
   "file (\"PTR\"), or optionally from the specified file.",  /* Description */
+#endif
   "PTR",  /* Name */
   D73  /* OptionVersionBitmask */
 },
 {
   C_PUT,  /* UniqueID */
+#ifndef NO_HELP
   "PUT # file_number , [ byte_number ] , scalar [,...]",  /* Syntax */
   "Puts one (or more) values into a BINARY file.",  /* Description */
+#endif
   "PUT",  /* Name */
   H14  /* OptionVersionBitmask */
 },
 {
   C_PUT,  /* UniqueID */
+#ifndef NO_HELP
   "PUT filename$ , value [, ...]",  /* Syntax */
   "Puts one (or more) values into a file.",  /* Description */
+#endif
   "PUT",  /* Name */
   S70 | I70 | I73  /* OptionVersionBitmask */
 },
 {
   C_PUT,  /* UniqueID */
+#ifndef NO_HELP
   "PUT # file_number [ , RECORD record_number ]",  /* Syntax */
   "Puts one (or more) values into a file.",  /* Description */
+#endif
   "PUT",  /* Name */
   R86 | D71 | T79  /* OptionVersionBitmask */
 },
 {
   C_PUT,  /* UniqueID */
+#ifndef NO_HELP
   "PUT # file_number [ , record_number ]",  /* Syntax */
   "Puts one (or more) values into a RANDOM file.",  /* Description */
+#endif
   "PUT",  /* Name */
   H14  /* OptionVersionBitmask */
 },
 {
   C_QUIT,  /* UniqueID */
+#ifndef NO_HELP
   "QUIT",  /* Syntax */
   "Exits to the operating system.",  /* Description */
+#endif
   "QUIT",  /* Name */
   B15 | S70 | C77 | D64 | E78 | E86 | G74 | G65 | G67 | D71 | I70 | I73  /* OptionVersionBitmask */
 },
 {
   C_READ,  /* UniqueID */
+#ifndef NO_HELP
   "READ variable [, ...]",  /* Syntax */
   "Reads values from DATA statements.",  /* Description */
+#endif
   "READ",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_RECALL,  /* UniqueID */
+#ifndef NO_HELP
   "RECALL ArrayName",  /* Syntax */
   "Loads a numeric array from a file saved using STORE.",  /* Description */
+#endif
   "RECALL",  /* Name */
   B15 | HB2  /* OptionVersionBitmask */
 },
 {
   C_REM,  /* UniqueID */
+#ifndef NO_HELP
   "REM ...",  /* Syntax */
   "Remark.",  /* Description */
+#endif
   "REM",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_RENAME,  /* UniqueID */
+#ifndef NO_HELP
   "RENAME from$ TO to$",  /* Syntax */
   "Rename a file.",  /* Description */
+#endif
   "RENAME",  /* Name */
   H14  /* OptionVersionBitmask */
 },
 {
   C_RENAME,  /* UniqueID */
+#ifndef NO_HELP
   "RENAME [filename$]",  /* Syntax */
   "Changes the file name which will be used by SAVE.  Does not save "
   "the file.",  /* Description */
+#endif
   "RENAME",  /* Name */
   D64 | G74 | G65 | G67 | D71  /* OptionVersionBitmask */
 },
 {
   C_RENUM,  /* UniqueID */
+#ifndef NO_HELP
   "RENUM",  /* Syntax */
   "Implementation defined.",  /* Description */
+#endif
   "RENUM",  /* Name */
   B15 | B93 | H14 | HB1 | HB2 | M80 | M86 | R86 | D71 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_RENUMBER,  /* UniqueID */
+#ifndef NO_HELP
   "RENUMBER",  /* Syntax */
   "Implementation defined.",  /* Description */
+#endif
   "RENUMBER",  /* Name */
   HB1 | HB2  /* OptionVersionBitmask */
 },
 {
   C_REPEAT,  /* UniqueID */
+#ifndef NO_HELP
   "REPEAT",  /* Syntax */
   "Top of a REPEAT - UNTIL structure.",  /* Description */
+#endif
   "REPEAT",  /* Name */
   B15 | H14 | HB2  /* OptionVersionBitmask */
 },
 {
   C_REPLACE,  /* UniqueID */
+#ifndef NO_HELP
   "REPLACE [filename$]",  /* Syntax */
   "Saves the current program into the file filename$ in ASCII format.",  /* Description */
+#endif
   "REPLACE",  /* Name */
   H80  /* OptionVersionBitmask */
 },
 {
   C_RESET,  /* UniqueID */
+#ifndef NO_HELP
   "RESET filename$ [, ...]",  /* Syntax */
   "Positions an input or output file to the bcginning.",  /* Description */
+#endif
   "RESET",  /* Name */
   S70 | I70 | I73  /* OptionVersionBitmask */
 },
 {
   C_RESTORE,  /* UniqueID */
+#ifndef NO_HELP
   "RESTORE [line]",  /* Syntax */
   "Resets the line used for the next READ statement.  line may be "
   "either a number or a label.",  /* Description */
+#endif
   "RESTORE",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_RESUME,  /* UniqueID */
+#ifndef NO_HELP
   "RESUME",  /* Syntax */
   "Used in an error handler to specify the next line to execute. "
   " Branch to ERL.",  /* Description */
+#endif
   "RESUME",  /* Name */
   B15 | H14 | HB1 | HB2 | M80 | M86 | R86 | D71 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_RESUME,  /* UniqueID */
+#ifndef NO_HELP
   "RESUME line",  /* Syntax */
   "Used in an error handler to specify the next line to execute. "
   " Branch to the specified line.",  /* Description */
+#endif
   "RESUME",  /* Name */
   B15 | H14 | HB1 | HB2 | M80 | M86 | R86 | D71 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_RESUME,  /* UniqueID */
+#ifndef NO_HELP
   "RESUME NEXT",  /* Syntax */
   "Used in an error handler to specify the next line to execute. "
   " Branch to the line after ERL.",  /* Description */
+#endif
   "RESUME",  /* Name */
   B15 | H14 | HB1 | HB2 | M80 | M86 | R86 | D71 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_RESUME,  /* UniqueID */
+#ifndef NO_HELP
   "RESUME 0",  /* Syntax */
   "Used in an error handler to specify the next line to execute. "
   " Branch to ERL.",  /* Description */
+#endif
   "RESUME",  /* Name */
   B15 | H14 | HB1 | HB2 | M80 | M86 | R86 | D71 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_RETURN,  /* UniqueID */
+#ifndef NO_HELP
   "RETURN",  /* Syntax */
   "Concludes a subroutine called by GOSUB.",  /* Description */
+#endif
   "RETURN",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_RSET,  /* UniqueID */
+#ifndef NO_HELP
   "RSET variable$ = value",  /* Syntax */
   "Right-aligns the value into variable$.  If the length of the "
   "value is too short, then it is padded on the left with spaces. "
   " If the length of the value is too long, then it is truncated "
   "on the right.  This is only for use with variables assigned to "
   "a random access buffer with FIELD command.",  /* Description */
+#endif
   "RSET",  /* Name */
   B15 | B93 | H14 | M80 | M86 | R86 | D71 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_RUN,  /* UniqueID */
+#ifndef NO_HELP
   "RUN filename$",  /* Syntax */
   "Loads a new BAASIC program and executes the program from the "
   "start.",  /* Description */
+#endif
   "RUN",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_RUN,  /* UniqueID */
+#ifndef NO_HELP
   "RUN line",  /* Syntax */
   "Executes the program in memory beginning at line.",  /* Description */
+#endif
   "RUN",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_RUN,  /* UniqueID */
+#ifndef NO_HELP
   "RUN",  /* Syntax */
   "Executes the program in memory from the start.",  /* Description */
+#endif
   "RUN",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_RUNNH,  /* UniqueID */
+#ifndef NO_HELP
   "RUNNH line",  /* Syntax */
   "Executes the program in memory beginning at line.",  /* Description */
+#endif
   "RUNNH",  /* Name */
   B15 | S70 | C77 | D64 | G74 | G65 | G67 | D71 | I70 | I73  /* OptionVersionBitmask */
 },
 {
   C_RUNNH,  /* UniqueID */
+#ifndef NO_HELP
   "RUNNH filename$",  /* Syntax */
   "Loads a new BAASIC program and executes the program from the "
   "start.",  /* Description */
+#endif
   "RUNNH",  /* Name */
   B15 | S70 | C77 | D64 | G74 | G65 | G67 | D71 | I70 | I73  /* OptionVersionBitmask */
 },
 {
   C_RUNNH,  /* UniqueID */
+#ifndef NO_HELP
   "RUNNH",  /* Syntax */
   "Executes the program in memory from the start.",  /* Description */
+#endif
   "RUNNH",  /* Name */
   B15 | S70 | C77 | D64 | G74 | G65 | G67 | D71 | I70 | I73  /* OptionVersionBitmask */
 },
 {
   C_SAVE,  /* UniqueID */
+#ifndef NO_HELP
   "SAVE [filename$]",  /* Syntax */
   "Saves the current program into the file filename$ in ASCII format.",  /* Description */
+#endif
   "SAVE",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_SCRATCH,  /* UniqueID */
+#ifndef NO_HELP
   "SCRATCH [# X]",  /* Syntax */
   "SCRATCH Deletes the program in memory and clears all variables. "
   " SCRATCH # X Sets the file mode to writing.",  /* Description */
+#endif
   "SCRATCH",  /* Name */
   G74 | HB2 | H80 | G65 | G67  /* OptionVersionBitmask */
 },
 {
   C_SELECT,  /* UniqueID */
+#ifndef NO_HELP
   "SELECT",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "SELECT",  /* Name */
   B15 | B93 | E86 | H14  /* OptionVersionBitmask */
 },
 {
   C_SELECT_CASE,  /* UniqueID */
+#ifndef NO_HELP
   "SELECT CASE value",  /* Syntax */
   "Introduces a multi-line conditional selection statement.",  /* Description */
+#endif
   "SELECT CASE",  /* Name */
   B15 | B93 | E86 | H14  /* OptionVersionBitmask */
 },
 {
   C_STEP,  /* UniqueID */
+#ifndef NO_HELP
   "STEP",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "STEP",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_STOP,  /* UniqueID */
+#ifndef NO_HELP
   "STOP",  /* Syntax */
   "Interrupts program execution and displays the line number of "
   "the STOP command.  For use when debugging BASIC programs.  Whether "
   "STOP issues a SIGINT signal is implementation defined.",  /* Description */
+#endif
   "STOP",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_STORE,  /* UniqueID */
+#ifndef NO_HELP
   "STORE ArrayName",  /* Syntax */
   "Saves a numeric array into a file for later loading by RECALL.",  /* Description */
+#endif
   "STORE",  /* Name */
   B15 | HB2  /* OptionVersionBitmask */
 },
 {
   C_SUB,  /* UniqueID */
+#ifndef NO_HELP
   "SUB name [ ( parameter [,...] ) ]",  /* Syntax */
   "Top line of a multi-line SUB definition.  The variable names "
   "specified are local to the SUB definition, and are initialized "
   "BYVAL when the subroutine is invoked by another routine.",  /* Description */
+#endif
   "SUB",  /* Name */
   B15 | B93 | E86 | H14 | HB2  /* OptionVersionBitmask */
 },
 {
   C_SUB_END,  /* UniqueID */
+#ifndef NO_HELP
   "SUB END",  /* Syntax */
   "Specifies the last line of a multi-line SUB definition.  Same "
   "as END SUB.",  /* Description */
+#endif
   "SUB END",  /* Name */
   H14  /* OptionVersionBitmask */
 },
 {
   C_SUB_EXIT,  /* UniqueID */
+#ifndef NO_HELP
   "SUB EXIT",  /* Syntax */
   "Immediately exits the inner-most multi-line SUB strucure.  Same "
   "as EXIT SUB.",  /* Description */
+#endif
   "SUB EXIT",  /* Name */
   H14  /* OptionVersionBitmask */
 },
 {
   C_SUBEND,  /* UniqueID */
+#ifndef NO_HELP
   "SUBEND",  /* Syntax */
   "Specifies the last line of a multi-line SUB definition.  Same "
   "as END SUB.",  /* Description */
+#endif
   "SUBEND",  /* Name */
   B15 | H14 | HB2  /* OptionVersionBitmask */
 },
 {
   C_SUBEXIT,  /* UniqueID */
+#ifndef NO_HELP
   "SUBEXIT",  /* Syntax */
   "Immediately exits the inner-most multi-line SUB strucure.  Same "
   "as EXIT SUB.",  /* Description */
+#endif
   "SUBEXIT",  /* Name */
   H14  /* OptionVersionBitmask */
 },
 {
   C_SWAP,  /* UniqueID */
+#ifndef NO_HELP
   "SWAP variable, variable",  /* Syntax */
   "Swaps the values of two variables. Both variables must be of "
   "the same type.",  /* Description */
+#endif
   "SWAP",  /* Name */
   B15 | B93 | H14 | HB2 | M80 | M86 | R86 | D71 | T80 | T79  /* OptionVersionBitmask */
 },
 {
   C_SYSTEM,  /* UniqueID */
+#ifndef NO_HELP
   "SYSTEM",  /* Syntax */
   "Exits to the operating system.",  /* Description */
+#endif
   "SYSTEM",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | G65 | G67 | M80 | M86 | D71 | I70 | I73 | T80 | V09  /* OptionVersionBitmask */
 },
 {
   C_TEXT,  /* UniqueID */
+#ifndef NO_HELP
   "TEXT letter[-letter] [, ...]",  /* Syntax */
   "Declares variables with single-letter names as string variables.",  /* Description */
+#endif
   "TEXT",  /* Name */
   HB1 | HB2  /* OptionVersionBitmask */
 },
 {
   C_THEN,  /* UniqueID */
+#ifndef NO_HELP
   "THEN",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "THEN",  /* Name */
   B15 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_TIMER,  /* UniqueID */
+#ifndef NO_HELP
   "TIMER",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "TIMER",  /* Name */
   B15  /* OptionVersionBitmask */
 },
 {
   C_TIMER_OFF,  /* UniqueID */
+#ifndef NO_HELP
   "TIMER OFF",  /* Syntax */
   "TIMER OFF terminates the timer interrupt.",  /* Description */
+#endif
   "TIMER OFF",  /* Name */
   B15  /* OptionVersionBitmask */
 },
 {
   C_TIMER_ON,  /* UniqueID */
+#ifndef NO_HELP
   "TIMER ON",  /* Syntax */
   "TIMER ON enables the timer interrupt.  When the specified seconds "
   "have elapsed, TIMER STOP is internaly executed before the interrupt "
   "is taken.  TIMER ON should be executed just before the RETURN "
   "command if you want the interrupt to occur again.",  /* Description */
+#endif
   "TIMER ON",  /* Name */
   B15  /* OptionVersionBitmask */
 },
 {
   C_TIMER_STOP,  /* UniqueID */
+#ifndef NO_HELP
   "TIMER STOP",  /* Syntax */
   "TIMER STOP disables the interrupt, but the count continues.",  /* Description */
+#endif
   "TIMER STOP",  /* Name */
   B15  /* OptionVersionBitmask */
 },
 {
   C_TLOAD,  /* UniqueID */
+#ifndef NO_HELP
   "TLOAD [filename$]",  /* Syntax */
   "Loads an ASCII BASIC program into memory.",  /* Description */
+#endif
   "TLOAD",  /* Name */
   B15 | HB2  /* OptionVersionBitmask */
 },
 {
   C_TO,  /* UniqueID */
+#ifndef NO_HELP
   "TO",  /* Syntax */
   "Syntax Error.",  /* Description */
+#endif
   "TO",  /* Name */
   B15 | B93 | S70 | C77 | D64 | E78 | E86 | G74 | H14 | HB1 | HB2 | H80 | G65 | G67 | M80 | M86 | D73 | D70 | R86 | D71 | I70 | I73 | T80 | V09 | T79  /* OptionVersionBitmask */
 },
 {
   C_TRACE,  /* UniqueID */
+#ifndef NO_HELP
   "TRACE",  /* Syntax */
   "Enables tracing.",  /* Description */
+#endif
   "TRACE",  /* Name */
   G74 | HB1 | HB2 | G67  /* OptionVersionBitmask */
 },
 {
   C_TRACE_OFF,  /* UniqueID */
+#ifndef NO_HELP
   "TRACE OFF",  /* Syntax */
   "Disables tracing.",  /* Description */
+#endif
   "TRACE OFF",  /* Name */
   G74 | HB1 | HB2 | G67  /* OptionVersionBitmask */
 },
 {
   C_TRACE_ON,  /* UniqueID */
+#ifndef NO_HELP
   "TRACE ON",  /* Syntax */
   "Enables tracing.",  /* Description */
+#endif
   "TRACE ON",  /* Name */
   G74 | HB1 | HB2 | G67  /* OptionVersionBitmask */
 },
 {
   C_TSAVE,  /* UniqueID */
+#ifndef NO_HELP
   "TSAVE [filename$]",  /* Syntax */
   "Saves the current program into the file filename$ in ASCII format.",  /* Description */
+#endif
   "TSAVE",  /* Name */
   B15 | HB2  /* OptionVersionBitmask */
 },
 {
   C_TTY,  /* UniqueID */
+#ifndef NO_HELP
   "TTY",  /* Syntax */
   "Directs the PRINT commands to write to the console (stdout), "
   "and the INPUT commands to read from.the console (stdin).  This "
   "cancels LPT, PTP and PTR.",  /* Description */
+#endif
   "TTY",  /* Name */
   D73  /* OptionVersionBitmask */
 },
 {
   C_TTY_IN,  /* UniqueID */
+#ifndef NO_HELP
   "TTY IN",  /* Syntax */
   "Directs the INPUT commands to read from.the console (stdin). "
   " This cancels PTR.  It does not cancel LPT or PTP.",  /* Description */
+#endif
   "TTY IN",  /* Name */
   D73  /* OptionVersionBitmask */
 },
 {
   C_TTY_OUT,  /* UniqueID */
+#ifndef NO_HELP
   "TTY OUT",  /* Syntax */
   "Directs the PRINT commands to write to the console (stdout). "
   " This cancels LPT or PTP.  It does not cancel PTR.",  /* Description */
+#endif
   "TTY OUT",  /* Name */
   D73  /* OptionVersionBitmask */
 },
 {
   C_UNTIL,  /* UniqueID */
+#ifndef NO_HELP
   "UNTIL value",  /* Syntax */
   "Bottom of a REPEAT - UNTIL.  If the value is non-zero, then the "
   "loop is terminated.",  /* Description */
+#endif
   "UNTIL",  /* Name */
   B15 | H14 | HB2  /* OptionVersionBitmask */
 },
 {
   C_USE,  /* UniqueID */
+#ifndef NO_HELP
   "USE parameter$",  /* Syntax */
   "Receives the value from the calling CHAINing program.",  /* Description */
+#endif
   "USE",  /* Name */
   S70 | I70 | I73  /* OptionVersionBitmask */
 },
 {
   C_VARS,  /* UniqueID */
+#ifndef NO_HELP
   "VARS",  /* Syntax */
   "Prints a list of all global variables.",  /* Description */
+#endif
   "VARS",  /* Name */
   B15 | B93  /* OptionVersionBitmask */
 },
 {
   C_WEND,  /* UniqueID */
+#ifndef NO_HELP
   "WEND",  /* Syntax */
   "Bottom of a WHILE - WEND structure.",  /* Description */
+#endif
   "WEND",  /* Name */
   B15 | B93 | C77 | H14 | HB1 | HB2 | M80 | M86 | D71 | T80  /* OptionVersionBitmask */
 },
 {
   C_WHILE,  /* UniqueID */
+#ifndef NO_HELP
   "WHILE value",  /* Syntax */
   "Top of a WHILE - WEND structure.  If the value is non-zero, then "
   "the loop is terminated.",  /* Description */
+#endif
   "WHILE",  /* Name */
   B15 | B93 | C77 | H14 | HB1 | HB2 | M80 | M86 | D71 | T80  /* OptionVersionBitmask */
 },
 {
   C_WRITE,  /* UniqueID */
+#ifndef NO_HELP
   "WRITE # filenum, value [, .... ]",  /* Syntax */
   "Outputs value to a file.    Strings are quoted and each value "
   "is seperated by a omma.",  /* Description */
+#endif
   "WRITE",  /* Name */
   B15 | B93 | G74 | H14 | G65 | G67 | M80 | M86 | D71 | T80  /* OptionVersionBitmask */
 },
 {
   C_WRITE,  /* UniqueID */
+#ifndef NO_HELP
   "WRITE value [, .... ]",  /* Syntax */
   "Outputs value to the screen.  Strings are quoted and each value "
   "is seperated by a comma.",  /* Description */
+#endif
   "WRITE",  /* Name */
   B15 | B93 | G74 | H14 | G65 | G67 | M80 | M86 | D71 | T80  /* OptionVersionBitmask */
 },
diff -urwN basic/bwd_fun.c newbasic/bwd_fun.c
--- basic/bwd_fun.c	Mon Apr 15 14:33:59 2024
+++ newbasic/bwd_fun.c	Mon Apr 15 14:21:43 2024
@@ -47,8 +47,10 @@
 {
 {
   F_ABS_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ABS( X )", /* Syntax */
   "The absolute value of X.",  /* Description */
+#endif
   "ABS", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -58,9 +60,11 @@
 },
 {
   F_ACOS_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ACOS( X )", /* Syntax */
   "The arccosine of X in radians, where 0 <= ACOS(X) <= PI.  X shall "
   "be in the range -1 <= X <= 1.",  /* Description */
+#endif
   "ACOS", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -70,9 +74,11 @@
 },
 {
   F_ACS_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ACS( X )", /* Syntax */
   "The arccosine of X in radians, where 0 <= ACS(X) <= PI.  X shall "
   "be in the range -1 <= X <= 1.",  /* Description */
+#endif
   "ACS", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -82,9 +88,11 @@
 },
 {
   F_ACSD_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ACSD( X )", /* Syntax */
   "The arccosine of X in degrees, where 0 <= ACSD(X) <= 180.  X "
   "shall be in the range -1 <= X <= 1.",  /* Description */
+#endif
   "ACSD", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -94,9 +102,11 @@
 },
 {
   F_ACSG_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ACSG( X )", /* Syntax */
   "The arccosine of X in gradians, where 0 <= ACS(X) <= 200.  X "
   "shall be in the range -1 <= X <= 1.",  /* Description */
+#endif
   "ACSG", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -106,11 +116,13 @@
 },
 {
   F_ANGLE_X_Y_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ANGLE( X, Y )", /* Syntax */
   "The angle in radians between the positive x-axis and the vector "
   "joining the origin to the point with coordinates (X, Y), where "
   "-PI < ANGLE(X,Y) <= PI.  X and Y must not both be 0.  Note that "
   "the counterclockwise is positive, e.g., ANGLE(1,1) = 45 degrees.",  /* Description */
+#endif
   "ANGLE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -120,9 +132,11 @@
 },
 {
   F_ARCCOS_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ARCCOS( X )", /* Syntax */
   "The arccosine of X in radians, where 0 <= ARCCOS(X) <= PI.  X "
   "shall be in the range -1 <= X <= 1.",  /* Description */
+#endif
   "ARCCOS", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -132,9 +146,11 @@
 },
 {
   F_ARCSIN_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ARCSIN( X )", /* Syntax */
   "The arcsine of X in radians, where -PI/2 <= ARCSIN(X) <= PI/2; "
   "X shall be in the range -1 <= X <= 1.",  /* Description */
+#endif
   "ARCSIN", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -144,9 +160,11 @@
 },
 {
   F_ARCTAN_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ARCTAN( X )", /* Syntax */
   "The arctangent of X in radians, i.e. the angle whose tangent "
   "is X, where -PI/2 < ARCTAN(X) < PI/2.",  /* Description */
+#endif
   "ARCTAN", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -156,9 +174,11 @@
 },
 {
   F_ARGC_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ARGC", /* Syntax */
   "The number of parameters passed to a FUNCTION or SUB.  If not "
   "in a FUNCTION or SUB, returns -1.",  /* Description */
+#endif
   "ARGC", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -168,10 +188,12 @@
 },
 {
   F_ARGT4_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = ARGT$( X )", /* Syntax */
   "The type of the Xth parameter to a FUNCTION or SUB.  If the Xth "
   "parameter is a string, then return value is \"$\".  If the Xth "
   "parameter is a number, then return value is not \"$\".  X in [1,ARGC].",  /* Description */
+#endif
   "ARGT$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -181,9 +203,11 @@
 },
 {
   F_ARGV_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ARGV( X )", /* Syntax */
   "The numeric value of the Xth parameter to a FUNCTION or SUB. "
   " X in [1,ARGC] and ARGT$( X ) <> \"$\".",  /* Description */
+#endif
   "ARGV", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -193,9 +217,11 @@
 },
 {
   F_ARGV4_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = ARGV$( X )", /* Syntax */
   "The string value of the Xth parameter to a FUNCTION or SUB.  "
   "X in [1,ARGC] and ARGT$( X ) = \"$\".",  /* Description */
+#endif
   "ARGV$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -205,9 +231,11 @@
 },
 {
   F_ASC_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ASC( A$ )", /* Syntax */
   "The numeric code for the first letter in A$.  For example, ASC(\"ABC\") "
   "returns 65 on ASCII systems.",  /* Description */
+#endif
   "ASC", /* Name */
   ByteTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -217,8 +245,10 @@
 },
 {
   F_ASC_A_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ASC( A$, X )", /* Syntax */
   "The numeric code of the Xth character in A$.  Same as ASC(MID$(A$,X)).",  /* Description */
+#endif
   "ASC", /* Name */
   ByteTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -228,9 +258,11 @@
 },
 {
   F_ASCII_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ASCII( A$ )", /* Syntax */
   "The numeric code for the first letter in A$.  For example, ASCII(\"ABC\") "
   "returns 65 on ASCII systems.",  /* Description */
+#endif
   "ASCII", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -240,9 +272,11 @@
 },
 {
   F_ASIN_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ASIN( X )", /* Syntax */
   "The arcsine of X in radians, where -PI/2 <= ASIN(X) <= PI/2; "
   "X shall be in the range -1 <= X <= 1.",  /* Description */
+#endif
   "ASIN", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -252,9 +286,11 @@
 },
 {
   F_ASN_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ASN( X )", /* Syntax */
   "The arcsine of X in radians, where -PI/2 <= ASN(X) <= PI/2; X "
   "shall be in the range -1 <= X <= 1.",  /* Description */
+#endif
   "ASN", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -264,9 +300,11 @@
 },
 {
   F_ASND_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ASND( X )", /* Syntax */
   "The arcsine of X in degrees, where -90 <= ASN(X) <= 90; X shall "
   "be in the range -1 <= X <= 1.",  /* Description */
+#endif
   "ASND", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -276,9 +314,11 @@
 },
 {
   F_ASNG_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ASNG( X )", /* Syntax */
   "The arcsine of X in gradians, where -100 <= ASNG(X) <= 100; X "
   "shall be in the range -1 <= X <= 1.",  /* Description */
+#endif
   "ASNG", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -288,9 +328,11 @@
 },
 {
   F_ATAN_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ATAN( X )", /* Syntax */
   "The arctangent of X in radians, i.e. the angle whose tangent "
   "is X, where -PI/2 < ATAN(X) < PI/2.",  /* Description */
+#endif
   "ATAN", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -300,9 +342,11 @@
 },
 {
   F_ATN_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ATN( X )", /* Syntax */
   "The arctangent of X in radians, i.e. the angle whose tangent "
   "is X, where -PI/2 < ATN(X) < PI/2.",  /* Description */
+#endif
   "ATN", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -312,9 +356,11 @@
 },
 {
   F_ATND_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ATND( X )", /* Syntax */
   "The arctangent of X in degrees, i.e. the angle whose tangent "
   "is X, where -90 < ATND(X) < 90.",  /* Description */
+#endif
   "ATND", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -324,9 +370,11 @@
 },
 {
   F_ATNG_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ATNG( X )", /* Syntax */
   "The arctangent of X in gradians, i.e. the angle whose tangent "
   "is X, where -100 < ATND(X) < 100.",  /* Description */
+#endif
   "ATNG", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -336,8 +384,10 @@
 },
 {
   F_BASE_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = BASE", /* Syntax */
   "The current OPTION BASE setting.",  /* Description */
+#endif
   "BASE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -347,8 +397,10 @@
 },
 {
   F_BIN4_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = BIN$( X )", /* Syntax */
   "The the binary (base 2) representation of X.",  /* Description */
+#endif
   "BIN$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -358,9 +410,11 @@
 },
 {
   F_BIN4_X_Y_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = BIN$( X, Y )", /* Syntax */
   "The the binary (base 2) representation of X.  The result will "
   "be at least Y digits long. ",  /* Description */
+#endif
   "BIN$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -370,8 +424,10 @@
 },
 {
   F_CATALOG_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = CATALOG", /* Syntax */
   "Displays all the file names.",  /* Description */
+#endif
   "CATALOG", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -381,8 +437,10 @@
 },
 {
   F_CATALOG_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = CATALOG( A$ )", /* Syntax */
   "Displays all the file names matching A$.",  /* Description */
+#endif
   "CATALOG", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -392,8 +450,10 @@
 },
 {
   F_CCUR_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = CCUR( X )", /* Syntax */
   "The currency (64-bit) integer value of X.",  /* Description */
+#endif
   "CCUR", /* Name */
   CurrencyTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -403,8 +463,10 @@
 },
 {
   F_CDBL_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = CDBL( X )", /* Syntax */
   "The double-precision value of X.",  /* Description */
+#endif
   "CDBL", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -414,8 +476,10 @@
 },
 {
   F_CEIL_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = CEIL( X )", /* Syntax */
   "The smallest integer not less than X.",  /* Description */
+#endif
   "CEIL", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -425,8 +489,10 @@
 },
 {
   F_CHAR_X_Y_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = CHAR( X, Y )", /* Syntax */
   "The string Y bytes long consisting of CHR$(X).  Same as STRING$(Y,X).",  /* Description */
+#endif
   "CHAR", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -436,9 +502,11 @@
 },
 {
   F_CHAR4_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = CHAR$( X )", /* Syntax */
   "The one-character string with the character corresponding to "
   "the numeric code X.  On ASCII systems, CHAR$(65) returns \"A\".",  /* Description */
+#endif
   "CHAR$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -448,8 +516,10 @@
 },
 {
   F_CHDIR_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = CHDIR( A$ )", /* Syntax */
   "Changes to the directory named to A$.",  /* Description */
+#endif
   "CHDIR", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -459,9 +529,11 @@
 },
 {
   F_CHR_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = CHR( X )", /* Syntax */
   "The one-character string with the character corresponding to "
   "the numeric code X.  On ASCII systems, CHR(65) returns \"A\".",  /* Description */
+#endif
   "CHR", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -471,8 +543,10 @@
 },
 {
   F_CHR_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = CHR( X )", /* Syntax */
   "The output of PRINT X.  A$ = CHR(X) is the opposite of X = NUM(A$).",  /* Description */
+#endif
   "CHR", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -482,9 +556,11 @@
 },
 {
   F_CHR4_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = CHR$( X )", /* Syntax */
   "The one-character string with the character corresponding to "
   "the numeric code X.  On ASCII systems, CHR$(65) returns \"A\".",  /* Description */
+#endif
   "CHR$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -494,10 +570,12 @@
 },
 {
   F_CIN_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = CIN( X )", /* Syntax */
   "If file # X is <= 0 then returns -1.  If file # X is not opened "
   "for reading then returns -1.  If file # X is at EOF then returns "
   "-1,  Otherwise returns the next byte value read from file X.",  /* Description */
+#endif
   "CIN", /* Name */
   IntegerTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -507,8 +585,10 @@
 },
 {
   F_CINT_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = CINT( X )", /* Syntax */
   "The short (16-bit) integer value of X.",  /* Description */
+#endif
   "CINT", /* Name */
   IntegerTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -518,8 +598,10 @@
 },
 {
   F_CLG_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = CLG( X )", /* Syntax */
   "The common logarithm of X; X shall be greater than zero.",  /* Description */
+#endif
   "CLG", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -529,11 +611,13 @@
 },
 {
   F_CLK_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = CLK( X )", /* Syntax */
   "The time elapsed since the previous midnight, expressed in hours; "
   "e.g., the value of CLK at 3:15 PM is 15.25.  If there is no clock "
   "available, then the value of CLK shall be -1.  The value of CLK "
   "at midnight shall be zero (not 24).  The value of X is ignored.",  /* Description */
+#endif
   "CLK", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -543,12 +627,14 @@
 },
 {
   F_CLK_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = CLK( X )", /* Syntax */
   "The time of day in 24-hour notation according to ISO 3307.  For "
   "example, the value of CLK at 11:15 AM is \"11:15:00\".  If there "
   "is no clock available, then the value of CLK shall be \"99:99:99\". "
   " The value of TIME$ at midnight is \"00:00:00\".  The value of "
   "parameter X is ignored.",  /* Description */
+#endif
   "CLK", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -558,11 +644,13 @@
 },
 {
   F_CLK4_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = CLK$", /* Syntax */
   "The time of day in 24-hour notation according to ISO 3307.  For "
   "example, the value of TIME$ at 11:15 AM is \"11:15:00\".  If there "
   "is no clock available, then the value of TIME$ shall be \"99:99:99\". "
   " The value of TIME$ at midnight is \"00:00:00\".",  /* Description */
+#endif
   "CLK$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -572,8 +660,10 @@
 },
 {
   F_CLNG_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = CLNG( X )", /* Syntax */
   "The long (32-bit) integer value of X.",  /* Description */
+#endif
   "CLNG", /* Name */
   LongTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -583,8 +673,10 @@
 },
 {
   F_CLOG_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = CLOG( X )", /* Syntax */
   "The common logarithm of X; X shall be greater than zero.",  /* Description */
+#endif
   "CLOG", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -594,8 +686,10 @@
 },
 {
   F_CLOSE_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = CLOSE", /* Syntax */
   "Close all open files.",  /* Description */
+#endif
   "CLOSE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -605,8 +699,10 @@
 },
 {
   F_CLOSE_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = CLOSE( X )", /* Syntax */
   "Close file number X.",  /* Description */
+#endif
   "CLOSE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -616,8 +712,10 @@
 },
 {
   F_CLS_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = CLS", /* Syntax */
   "Clears the screen. Cursor is positioned at row 1, column 1.",  /* Description */
+#endif
   "CLS", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -627,9 +725,11 @@
 },
 {
   F_CNTRL_X_Y_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = CNTRL( X, Y )", /* Syntax */
   "CNTRL 1,Y sets the number of significant digits to print.  CNTRL "
   "3,Y sets the width of the print zones.",  /* Description */
+#endif
   "CNTRL", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -639,9 +739,11 @@
 },
 {
   F_CODE_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = CODE( A$ )", /* Syntax */
   "The numeric code for the first letter in A$.  For example, CODE(\"ABC\") "
   "returns 65 on ASCII systems.",  /* Description */
+#endif
   "CODE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -651,9 +753,11 @@
 },
 {
   F_COLOR_X_Y_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = COLOR( X, Y )", /* Syntax */
   "Sets the foreground text color to X, and the background text "
   "color to Y.",  /* Description */
+#endif
   "COLOR", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -663,10 +767,12 @@
 },
 {
   F_COMMAND4_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = COMMAND$", /* Syntax */
   "All command line parameters, concatenated with one space between "
   "each.  Support for parameters varies by operating system, compiler, "
   "and so on.",  /* Description */
+#endif
   "COMMAND$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -676,11 +782,13 @@
 },
 {
   F_COMMAND4_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = COMMAND$( X )", /* Syntax */
   "The command line parameters.  COMMAND$(0) is the BASIC program "
   "name.  COMMAND$(1) is the first parameter after the BASIC program "
   "name, and so on.  Support for parameters varies by operating "
   "system, compiler, and so on.  X in [0..9]  ",  /* Description */
+#endif
   "COMMAND$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -690,8 +798,10 @@
 },
 {
   F_COS_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = COS( X )", /* Syntax */
   "The cosine of X, where X is in radians.",  /* Description */
+#endif
   "COS", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -701,8 +811,10 @@
 },
 {
   F_COSD_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = COSD( X )", /* Syntax */
   "The cosine of X, where X is in degrees.",  /* Description */
+#endif
   "COSD", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -712,8 +824,10 @@
 },
 {
   F_COSG_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = COSG( X )", /* Syntax */
   "The cosine of X, where X is in gradians.",  /* Description */
+#endif
   "COSG", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -723,8 +837,10 @@
 },
 {
   F_COSH_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = COSH( X )", /* Syntax */
   "The hyperbolic cosine of X.",  /* Description */
+#endif
   "COSH", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -734,8 +850,10 @@
 },
 {
   F_COT_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = COT( X )", /* Syntax */
   "The cotangent of X, where X is in radians.",  /* Description */
+#endif
   "COT", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -745,8 +863,10 @@
 },
 {
   F_COUNT_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = COUNT", /* Syntax */
   "The current cursor position in the line.",  /* Description */
+#endif
   "COUNT", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -756,8 +876,10 @@
 },
 {
   F_CSC_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = CSC( X )", /* Syntax */
   "The cosecant of X, where X is in radians.",  /* Description */
+#endif
   "CSC", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -767,8 +889,10 @@
 },
 {
   F_CSH_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = CSH( X )", /* Syntax */
   "The hyperbolic cosine of X.",  /* Description */
+#endif
   "CSH", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -778,8 +902,10 @@
 },
 {
   F_CSNG_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = CSNG( X )", /* Syntax */
   "The single-precision value of X.",  /* Description */
+#endif
   "CSNG", /* Name */
   SingleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -789,8 +915,10 @@
 },
 {
   F_CUR_X_Y_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = CUR( X, Y )", /* Syntax */
   "Locates the cursor to row X, column Y.",  /* Description */
+#endif
   "CUR", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -800,9 +928,11 @@
 },
 {
   F_CVC_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = CVC( A$ )", /* Syntax */
   "The currency (64-bit) integer value in A$, which was created "
   "by MKC$.",  /* Description */
+#endif
   "CVC", /* Name */
   CurrencyTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -812,8 +942,10 @@
 },
 {
   F_CVD_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = CVD( A$ )", /* Syntax */
   "The double-precision value in A$, which was created by MKD$.",  /* Description */
+#endif
   "CVD", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -823,9 +955,11 @@
 },
 {
   F_CVI_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = CVI( A$ )", /* Syntax */
   "The short (16-bit) integer value in A$, which was created by "
   "MKI$.",  /* Description */
+#endif
   "CVI", /* Name */
   IntegerTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -835,8 +969,10 @@
 },
 {
   F_CVL_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = CVL( A$ )", /* Syntax */
   "The long (32-bit) integer value in A$, which was created by MKL$.",  /* Description */
+#endif
   "CVL", /* Name */
   LongTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -846,8 +982,10 @@
 },
 {
   F_CVS_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = CVS( A$ )", /* Syntax */
   "The single-precision value in A$, which was created by MKS$.",  /* Description */
+#endif
   "CVS", /* Name */
   SingleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -857,9 +995,11 @@
 },
 {
   F_DAT4_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = DAT$", /* Syntax */
   "The current date based on the internal clock as a string in the "
   "format set by OPTION DATE.",  /* Description */
+#endif
   "DAT$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -869,12 +1009,14 @@
 },
 {
   F_DATE_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = DATE", /* Syntax */
   "The current date in decimal form YYYDDD, where YYY are the number "
   "of years since 1900 and DDD is the ordinal number of the current "
   "day of the year; e.g., the value of DATE on May 9, 1977 was 77129. "
   " If there is no calendar available, then the value of DATE shall "
   "be -1.",  /* Description */
+#endif
   "DATE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -884,9 +1026,11 @@
 },
 {
   F_DATE4_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = DATE$", /* Syntax */
   "The current date based on the internal clock as a string in the "
   "format set by OPTION DATE.",  /* Description */
+#endif
   "DATE$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -896,9 +1040,11 @@
 },
 {
   F_DATE4_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = DATE$( X )", /* Syntax */
   "The current date based on the internal clock as a string in the "
   "format set by OPTION DATE.  The value of parameter X is ignored.",  /* Description */
+#endif
   "DATE$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -908,9 +1054,11 @@
 },
 {
   F_DEG_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = DEG", /* Syntax */
   "Configures the math functions to accept and return angles in "
   "degrees.",  /* Description */
+#endif
   "DEG", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -920,8 +1068,10 @@
 },
 {
   F_DEG_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = DEG( X )", /* Syntax */
   "When X is zero sets RADIANS.  When X is non-zero sets DEGREES.",  /* Description */
+#endif
   "DEG", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -931,8 +1081,10 @@
 },
 {
   F_DEG_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = DEG( X )", /* Syntax */
   "The number of degrees in X radians.",  /* Description */
+#endif
   "DEG", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -942,9 +1094,11 @@
 },
 {
   F_DEGREE_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = DEGREE", /* Syntax */
   "Configures the math functions to accept and return angles in "
   "degrees.",  /* Description */
+#endif
   "DEGREE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -954,8 +1108,10 @@
 },
 {
   F_DEGREE_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = DEGREE( X )", /* Syntax */
   "The number of degrees in X radians.",  /* Description */
+#endif
   "DEGREE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -965,8 +1121,10 @@
 },
 {
   F_DET_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = DET", /* Syntax */
   "The determinant of the last MAT INV.  Zero means error.",  /* Description */
+#endif
   "DET", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -976,9 +1134,11 @@
 },
 {
   F_DIGITS_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = DIGITS( X )", /* Syntax */
   "X is the number of significiant digits to print for numbers (0..17). "
   " If X = 0 then disabled.  ",  /* Description */
+#endif
   "DIGITS", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -988,10 +1148,12 @@
 },
 {
   F_DIGITS_X_Y_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = DIGITS( X, Y )", /* Syntax */
   "X is the number of significiant digits to print for numbers (0..17). "
   " If X = 0 then disabled.  Y is the number of decimal places to "
   "round (0..17).  If Y = 0 then disabled.",  /* Description */
+#endif
   "DIGITS", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -1001,8 +1163,10 @@
 },
 {
   F_DIM_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = DIM( ... )", /* Syntax */
   "DIM( arrayname ).  The total number of dimensions of the array.",  /* Description */
+#endif
   "DIM", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   255, /* ParameterCount */
@@ -1012,8 +1176,10 @@
 },
 {
   F_DPEEK_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = DPEEK( X )", /* Syntax */
   "The value read from hardware address X. Causes ERROR 73.",  /* Description */
+#endif
   "DPEEK", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1023,8 +1189,10 @@
 },
 {
   F_DPOKE_X_Y_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = DPOKE( X, Y )", /* Syntax */
   "Sends Y to hardware address X.  Causes ERROR 73.",  /* Description */
+#endif
   "DPOKE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -1034,6 +1202,7 @@
 },
 {
   F_EDIT4_A_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = EDIT$( A$, X )", /* Syntax */
   "Edits the characters of A$, according to the bits set in X.\n1 "
   "= discard parity bit.\n2 = discard all spaces.\n4 = discard all "
@@ -1043,6 +1212,7 @@
   "[ to ( and change ] to ).\n128 = discard trailing spacess.\n256 "
   "= suppress editing within quotes.\nThe order in which edits occur "
   "is implementation defined.",  /* Description */
+#endif
   "EDIT$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -1052,9 +1222,11 @@
 },
 {
   F_ENVIRON_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ENVIRON( A$ )", /* Syntax */
   "Sends the environment variable expression contained in A$ to "
   "the host operating system.  A$ must contain the  \"=\" character.",  /* Description */
+#endif
   "ENVIRON", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1064,8 +1236,10 @@
 },
 {
   F_ENVIRON4_A_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = ENVIRON$( A$ )", /* Syntax */
   "The value of the environment variable named A$.",  /* Description */
+#endif
   "ENVIRON$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1075,9 +1249,11 @@
 },
 {
   F_EOF_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = EOF( X )", /* Syntax */
   "If device number X is at the end-of-file, then -1, otherwise "
   "0.",  /* Description */
+#endif
   "EOF", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1087,6 +1263,7 @@
 },
 {
   F_EPS_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = EPS( X )", /* Syntax */
   "The maximum of (X-X1,X2-X, sigma) where X1 and X2 are the predecessor "
   "and successor of X and signma is the smallest positive value "
@@ -1095,6 +1272,7 @@
   "number representable by the implementation, and is therefor implementation-defined. "
   " Note also that EPS may produce different results for different "
   "arithmetic options (see OPTION ARITHMETIC).",  /* Description */
+#endif
   "EPS", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1104,8 +1282,10 @@
 },
 {
   F_ERL_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ERL", /* Syntax */
   "The line number of the most recent error.",  /* Description */
+#endif
   "ERL", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -1115,8 +1295,10 @@
 },
 {
   F_ERR_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ERR", /* Syntax */
   "The error number of the most recent error.",  /* Description */
+#endif
   "ERR", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -1126,8 +1308,10 @@
 },
 {
   F_ERR4_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = ERR$", /* Syntax */
   "The last error message.",  /* Description */
+#endif
   "ERR$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -1137,8 +1321,10 @@
 },
 {
   F_ERRL_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ERRL", /* Syntax */
   "The line number of the most recent error.",  /* Description */
+#endif
   "ERRL", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -1148,8 +1334,10 @@
 },
 {
   F_ERRN_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ERRN", /* Syntax */
   "The error number of the most recent error.",  /* Description */
+#endif
   "ERRN", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -1159,8 +1347,10 @@
 },
 {
   F_ERROR_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ERROR( X )", /* Syntax */
   "Simulate the error number in X.",  /* Description */
+#endif
   "ERROR", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1170,8 +1360,10 @@
 },
 {
   F_ERROR_X_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ERROR( X, A$ )", /* Syntax */
   "Simulate the error number in X, with a custom message in A$.",  /* Description */
+#endif
   "ERROR", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -1181,8 +1373,10 @@
 },
 {
   F_ERROR4_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = ERROR$", /* Syntax */
   "The last error message.",  /* Description */
+#endif
   "ERROR$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -1192,8 +1386,10 @@
 },
 {
   F_EXAM_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = EXAM( X )", /* Syntax */
   "The value read from hardware address X.  Causes ERROR 73.",  /* Description */
+#endif
   "EXAM", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1203,9 +1399,11 @@
 },
 {
   F_EXEC_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = EXEC( A$ )", /* Syntax */
   "The exit code resulting from the execution of an operating system "
   "command.",  /* Description */
+#endif
   "EXEC", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1215,8 +1413,10 @@
 },
 {
   F_EXF_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = EXF( ... )", /* Syntax */
   "Execute hardware program.  Causes ERROR 73.",  /* Description */
+#endif
   "EXF", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   255, /* ParameterCount */
@@ -1226,11 +1426,13 @@
 },
 {
   F_EXP_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = EXP( X )", /* Syntax */
   "The exponential value of X, i.e., the value of the base of natural "
   "logarithms (e = 2.71828) raised to the power of X;  if EXP(X) "
   "is less that machine infinitesimal, then its value shall be replaced "
   "with zero.",  /* Description */
+#endif
   "EXP", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1240,8 +1442,10 @@
 },
 {
   F_FALSE_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = FALSE", /* Syntax */
   "The value of FALSE.",  /* Description */
+#endif
   "FALSE", /* Name */
   IntegerTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -1251,8 +1455,10 @@
 },
 {
   F_FETCH_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = FETCH( X )", /* Syntax */
   "The value read from hardware address X.  Causes ERROR 73.",  /* Description */
+#endif
   "FETCH", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1262,9 +1468,11 @@
 },
 {
   F_FILEATTR_X_Y_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = FILEATTR( X, Y )", /* Syntax */
   "For file X, if Y = 1 then returns open mode, otherwise returns "
   "zero.",  /* Description */
+#endif
   "FILEATTR", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -1274,8 +1482,10 @@
 },
 {
   F_FILES_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = FILES", /* Syntax */
   "Displays all the file names.",  /* Description */
+#endif
   "FILES", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -1285,8 +1495,10 @@
 },
 {
   F_FILES_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = FILES( A$ )", /* Syntax */
   "Displays all the file names matching A$.",  /* Description */
+#endif
   "FILES", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1296,8 +1508,10 @@
 },
 {
   F_FILL_X_Y_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = FILL( X, Y )", /* Syntax */
   "Sends Y to hardware address X.  Causes ERROR 73.",  /* Description */
+#endif
   "FILL", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -1307,10 +1521,12 @@
 },
 {
   F_FIX_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = FIX( X )", /* Syntax */
   "The truncated integer, part of X. FIX (X) is equivalent to SGN(X)*INT(ABS(X)). "
   "The major difference between FIX and INT is that FIX does not "
   "return the next lower number for negative X.",  /* Description */
+#endif
   "FIX", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1320,8 +1536,10 @@
 },
 {
   F_FLOAT_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = FLOAT( X )", /* Syntax */
   "The rounded integer valuet of X.",  /* Description */
+#endif
   "FLOAT", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1331,8 +1549,10 @@
 },
 {
   F_FLOW_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = FLOW", /* Syntax */
   "Turn tracing ON",  /* Description */
+#endif
   "FLOW", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -1342,8 +1562,10 @@
 },
 {
   F_FP_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = FP( X )", /* Syntax */
   "The fractional part of X, i.e. X - IP(X).",  /* Description */
+#endif
   "FP", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1353,8 +1575,10 @@
 },
 {
   F_FRAC_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = FRAC( X )", /* Syntax */
   "The fractional part of X, i.e. X - IP(X).",  /* Description */
+#endif
   "FRAC", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1364,10 +1588,12 @@
 },
 {
   F_FRE_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = FRE", /* Syntax */
   "The number of bytes of available memory.  This function is provided "
   "for backward compatibility only and it always returns a fixed "
   "value of 32000.",  /* Description */
+#endif
   "FRE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -1377,10 +1603,12 @@
 },
 {
   F_FRE_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = FRE( A$ )", /* Syntax */
   "The number of bytes of available memory.  This function is provided "
   "for backward compatibility only and it always returns a fixed "
   "value of 32000.The value of A$ is ignored.",  /* Description */
+#endif
   "FRE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1390,10 +1618,12 @@
 },
 {
   F_FRE_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = FRE( X )", /* Syntax */
   "The number of bytes of available memory.  This function is provided "
   "for backward compatibility only and it always returns a fixed "
   "value of 32000.  The value of X is ignored.",  /* Description */
+#endif
   "FRE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1403,10 +1633,12 @@
 },
 {
   F_FREE_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = FREE", /* Syntax */
   "The number of bytes of available memory.  This function is provided "
   "for backward compatibility only and it always returns a fixed "
   "value of 32000.",  /* Description */
+#endif
   "FREE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -1416,10 +1648,12 @@
 },
 {
   F_FREE_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = FREE( X )", /* Syntax */
   "The number of bytes of available memory.  This function is provided "
   "for backward compatibility only and it always returns a fixed "
   "value of 32000.  The value of X is ignored.",  /* Description */
+#endif
   "FREE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1429,10 +1663,12 @@
 },
 {
   F_FREE_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = FREE( A$ )", /* Syntax */
   "The number of bytes of available memory.  This function is provided "
   "for backward compatibility only and it always returns a fixed "
   "value of 32000.The value of A$ is ignored.",  /* Description */
+#endif
   "FREE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1442,8 +1678,10 @@
 },
 {
   F_FREEFILE_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = FREEFILE", /* Syntax */
   "The next available file number.",  /* Description */
+#endif
   "FREEFILE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -1453,8 +1691,10 @@
 },
 {
   F_GET_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = GET( X )", /* Syntax */
   "For file X, gets the next available record.",  /* Description */
+#endif
   "GET", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1464,9 +1704,11 @@
 },
 {
   F_GET_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = GET( X )", /* Syntax */
   "Get character code from input.  The value of X is ignored. Similar "
   "to ASC(INKEY$).",  /* Description */
+#endif
   "GET", /* Name */
   IntegerTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1476,9 +1718,11 @@
 },
 {
   F_GET_X_Y_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = GET( X, Y )", /* Syntax */
   "For file X, gets record number Y.  The first record number is "
   "1.",  /* Description */
+#endif
   "GET", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -1488,9 +1732,11 @@
 },
 {
   F_GRAD_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = GRAD", /* Syntax */
   "Configures the math functions to accept and return angles in "
   "gradians.",  /* Description */
+#endif
   "GRAD", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -1500,9 +1746,11 @@
 },
 {
   F_GRADIAN_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = GRADIAN", /* Syntax */
   "Configures the math functions to accept and return angles in "
   "gradians.",  /* Description */
+#endif
   "GRADIAN", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -1512,8 +1760,10 @@
 },
 {
   F_HCS_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = HCS( X )", /* Syntax */
   "The hyperbolic cosine of X.",  /* Description */
+#endif
   "HCS", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1523,9 +1773,11 @@
 },
 {
   F_HEX_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = HEX( A$ )", /* Syntax */
   "The numeric value of the hexadecimal string in A$.  For example, "
   "HEX(\"FFFF\") returns 65535.",  /* Description */
+#endif
   "HEX", /* Name */
   ByteTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1535,8 +1787,10 @@
 },
 {
   F_HEX4_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = HEX$( X )", /* Syntax */
   "The the hexadecimal (base 16) representation of X.",  /* Description */
+#endif
   "HEX$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1546,9 +1800,11 @@
 },
 {
   F_HEX4_X_Y_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = HEX$( X, Y )", /* Syntax */
   "The the hexadecimal (base 16) representation of X.  The result "
   "will be at least Y digits long. ",  /* Description */
+#endif
   "HEX$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -1558,8 +1814,10 @@
 },
 {
   F_HOME_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = HOME", /* Syntax */
   "Clears the screen. Cursor is positioned at row 1, column 1.",  /* Description */
+#endif
   "HOME", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -1569,8 +1827,10 @@
 },
 {
   F_HSN_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = HSN( X )", /* Syntax */
   "The hyperbolic sine of X.",  /* Description */
+#endif
   "HSN", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1580,8 +1840,10 @@
 },
 {
   F_HTN_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = HTN( X )", /* Syntax */
   "The hyperbolic tangent of X.",  /* Description */
+#endif
   "HTN", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1591,11 +1853,13 @@
 },
 {
   F_INCH4_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = INCH$", /* Syntax */
   "The keypress, if available. If a keypress is not available, then "
   "immediately returns an empty string.  If not supported by the "
   "platform, then always returns an empty string, so use INPUT$(1) "
   "instead.",  /* Description */
+#endif
   "INCH$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -1605,9 +1869,11 @@
 },
 {
   F_INDEX_A_B_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = INDEX( A$, B$ )", /* Syntax */
   "The position at which B$ occurs in A$, beginning at position "
   "1.",  /* Description */
+#endif
   "INDEX", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -1617,9 +1883,11 @@
 },
 {
   F_INITIALIZE_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = INITIALIZE", /* Syntax */
   "This function is provided for backward compatibility only and "
   "it always returns a fixed value of 0.",  /* Description */
+#endif
   "INITIALIZE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -1629,11 +1897,13 @@
 },
 {
   F_INKEY4_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = INKEY$", /* Syntax */
   "The keypress, if available. If a keypress is not available, then "
   "immediately returns an empty string.  If not supported by the "
   "platform, then always returns an empty string, so use INPUT$(1) "
   "instead.",  /* Description */
+#endif
   "INKEY$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -1643,8 +1913,10 @@
 },
 {
   F_INP_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = INP( X )", /* Syntax */
   "The value read from machine port X.  Causes ERROR 73.",  /* Description */
+#endif
   "INP", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1654,8 +1926,10 @@
 },
 {
   F_INPUT4_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = INPUT$( X )", /* Syntax */
   "The string of X characters, read from the terminal.",  /* Description */
+#endif
   "INPUT$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1665,8 +1939,10 @@
 },
 {
   F_INPUT4_X_Y_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = INPUT$( X, Y )", /* Syntax */
   "The string of X characters, read from file Y.",  /* Description */
+#endif
   "INPUT$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -1676,9 +1952,11 @@
 },
 {
   F_INSTR_A_B_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = INSTR( A$, B$ )", /* Syntax */
   "The position at which B$ occurs in A$, beginning at position "
   "1.",  /* Description */
+#endif
   "INSTR", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -1688,9 +1966,11 @@
 },
 {
   F_INSTR_A_B_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = INSTR( A$, B$, X )", /* Syntax */
   "The position at which B$ occurs in A$, beginning at position "
   "X.",  /* Description */
+#endif
   "INSTR", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   3, /* ParameterCount */
@@ -1700,9 +1980,11 @@
 },
 {
   F_INSTR_X_A_B_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = INSTR( X, A$, B$ )", /* Syntax */
   "The position at which B$ occurs in A$, beginning at position "
   "X.",  /* Description */
+#endif
   "INSTR", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   3, /* ParameterCount */
@@ -1712,9 +1994,11 @@
 },
 {
   F_INT_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = INT( X )", /* Syntax */
   "The largest integer not greater than X; e.g. INT(1.3) = 1 and "
   "INT(-1.3) = 2.",  /* Description */
+#endif
   "INT", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1724,8 +2008,10 @@
 },
 {
   F_INT5_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = INT%( X )", /* Syntax */
   "The rounded integer valuet of X.",  /* Description */
+#endif
   "INT%", /* Name */
   LongTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1735,8 +2021,10 @@
 },
 {
   F_IP_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = IP( X )", /* Syntax */
   "The integer part of X, i.e., SGN(X)*INT(ABS(X)).",  /* Description */
+#endif
   "IP", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1746,11 +2034,13 @@
 },
 {
   F_KEY_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = KEY", /* Syntax */
   "The keypress, if available. If a keypress is not available, then "
   "immediately returns an empty string.  If not supported by the "
   "platform, then always returns an empty string, so use INPUT$(1) "
   "instead.",  /* Description */
+#endif
   "KEY", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -1760,11 +2050,13 @@
 },
 {
   F_KEY4_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = KEY$", /* Syntax */
   "The keypress, if available. If a keypress is not available, then "
   "immediately returns an empty string.  If not supported by the "
   "platform, then always returns an empty string, so use INPUT$(1) "
   "instead.",  /* Description */
+#endif
   "KEY$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -1774,8 +2066,10 @@
 },
 {
   F_KILL_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = KILL( A$ )", /* Syntax */
   "Removes the file named in A$.",  /* Description */
+#endif
   "KILL", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1785,9 +2079,11 @@
 },
 {
   F_LBOUND_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = LBOUND( ... )", /* Syntax */
   "LBOUND( arrayname [, dimension] ).  The lower bound of the array. "
   " The dimension defaults to 1.  dimension in [1,DIM(arrayname)]",  /* Description */
+#endif
   "LBOUND", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   255, /* ParameterCount */
@@ -1797,10 +2093,12 @@
 },
 {
   F_LCASE4_A_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = LCASE$( A$ )", /* Syntax */
   "The string of characters from the value associatedwith A$ by "
   "replacing each upper-case-letter in the string by its lower-case "
   "version.",  /* Description */
+#endif
   "LCASE$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1810,8 +2108,10 @@
 },
 {
   F_LEFT_A_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = LEFT( A$, X )", /* Syntax */
   "The X left-most characters of A$, beginning from postion 1.",  /* Description */
+#endif
   "LEFT", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -1821,8 +2121,10 @@
 },
 {
   F_LEFT4_A_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = LEFT$( A$, X )", /* Syntax */
   "The X left-most characters of A$, beginning from postion 1.",  /* Description */
+#endif
   "LEFT$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -1832,8 +2134,10 @@
 },
 {
   F_LEN_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = LEN( A$ )", /* Syntax */
   "The length of A$.",  /* Description */
+#endif
   "LEN", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1843,8 +2147,10 @@
 },
 {
   F_LGT_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = LGT( X )", /* Syntax */
   "The common logarithm of X; X shall be greater than zero.",  /* Description */
+#endif
   "LGT", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1854,8 +2160,10 @@
 },
 {
   F_LIN_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = LIN( X )", /* Syntax */
   "The string X bytes long of newline characters.",  /* Description */
+#endif
   "LIN", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1865,8 +2173,10 @@
 },
 {
   F_LN_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = LN( X )", /* Syntax */
   "The natural logarithm of X; X shall be greater than zero.",  /* Description */
+#endif
   "LN", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1876,8 +2186,10 @@
 },
 {
   F_LNO_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = LNO( X )", /* Syntax */
   "Returns X.",  /* Description */
+#endif
   "LNO", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1887,9 +2199,11 @@
 },
 {
   F_LOC_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = LOC( X )", /* Syntax */
   "The location of file X; the next record that GET or PUT statements "
   "will use.",  /* Description */
+#endif
   "LOC", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1899,8 +2213,10 @@
 },
 {
   F_LOCATE_X_Y_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = LOCATE( X, Y )", /* Syntax */
   "Locates the cursor to row X, column Y.",  /* Description */
+#endif
   "LOCATE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -1910,8 +2226,10 @@
 },
 {
   F_LOCK_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = LOCK( X )", /* Syntax */
   "Lock file number X.  Causes ERROR 73.",  /* Description */
+#endif
   "LOCK", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1921,8 +2239,10 @@
 },
 {
   F_LOF_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = LOF( X )", /* Syntax */
   "The length of file X.",  /* Description */
+#endif
   "LOF", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1932,8 +2252,10 @@
 },
 {
   F_LOG_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = LOG( X )", /* Syntax */
   "The natural logarithm of X; X shall be greater than zero.",  /* Description */
+#endif
   "LOG", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1943,8 +2265,10 @@
 },
 {
   F_LOG10_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = LOG10( X )", /* Syntax */
   "The common logarithm of X; X shall be greater than zero.",  /* Description */
+#endif
   "LOG10", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1954,8 +2278,10 @@
 },
 {
   F_LOG2_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = LOG2( X )", /* Syntax */
   "The base 2 logarithm of X; X shall be greater than zero.",  /* Description */
+#endif
   "LOG2", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1965,8 +2291,10 @@
 },
 {
   F_LOGE_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = LOGE( X )", /* Syntax */
   "The natural logarithm of X; X shall be greater than zero.",  /* Description */
+#endif
   "LOGE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1976,10 +2304,12 @@
 },
 {
   F_LOWER4_A_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = LOWER$( A$ )", /* Syntax */
   "The string of characters from the value associatedwith A$ by "
   "replacing each upper-case-letter in the string by its lower-case "
   "version.",  /* Description */
+#endif
   "LOWER$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -1989,8 +2319,10 @@
 },
 {
   F_LPOS_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = LPOS", /* Syntax */
   "The current cursor position in the line for the printer.",  /* Description */
+#endif
   "LPOS", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2000,9 +2332,11 @@
 },
 {
   F_LTRIM4_A_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = LTRIM$( A$ )", /* Syntax */
   "The string of characters resulting from the value associated "
   "with A$ by deleting all leading space characters.",  /* Description */
+#endif
   "LTRIM$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2012,8 +2346,10 @@
 },
 {
   F_LTW_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = LTW( X )", /* Syntax */
   "The base 2 logarithm of X; X shall be greater than zero.",  /* Description */
+#endif
   "LTW", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2023,9 +2359,11 @@
 },
 {
   F_LWIDTH_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = LWIDTH( X )", /* Syntax */
   "For printer, sets the line width to X. Zero means no wrapping "
   "will occur.",  /* Description */
+#endif
   "LWIDTH", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2035,11 +2373,13 @@
 },
 {
   F_MATCH_A_B_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = MATCH( A$, B$, X )", /* Syntax */
   "The character position, within the value assocated with A$, of "
   "the first character of the first occurence of the value associated "
   "with B$, starting at the Xth character of A$.  If there is not "
   "such occurence, then the value returned is zero.",  /* Description */
+#endif
   "MATCH", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   3, /* ParameterCount */
@@ -2049,8 +2389,10 @@
 },
 {
   F_MAX_A_B_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = MAX( A$, B$ )", /* Syntax */
   "The larger of the parameters.",  /* Description */
+#endif
   "MAX", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -2060,8 +2402,10 @@
 },
 {
   F_MAX_X_Y_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = MAX( X, Y )", /* Syntax */
   "The larger of the parameters.",  /* Description */
+#endif
   "MAX", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -2071,8 +2415,10 @@
 },
 {
   F_MAXBYT_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = MAXBYT", /* Syntax */
   "The largest finite positive number representable as a BYTE; implementation-defined.",  /* Description */
+#endif
   "MAXBYT", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2082,9 +2428,11 @@
 },
 {
   F_MAXCUR_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = MAXCUR", /* Syntax */
   "The largest finite positive number representable as a CURRENCY; "
   "implementation-defined.",  /* Description */
+#endif
   "MAXCUR", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2094,9 +2442,11 @@
 },
 {
   F_MAXDBL_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = MAXDBL", /* Syntax */
   "The largest finite positive number representable as a DOUBLE; "
   "implementation-defined.",  /* Description */
+#endif
   "MAXDBL", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2106,9 +2456,11 @@
 },
 {
   F_MAXDEV_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = MAXDEV", /* Syntax */
   "The largest finite positive number useable as a FILE NUMBER; "
   "implementation-defined.",  /* Description */
+#endif
   "MAXDEV", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2118,9 +2470,11 @@
 },
 {
   F_MAXINT_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = MAXINT", /* Syntax */
   "The largest finite positive number representable as an INTEGER; "
   "implementation-defined.",  /* Description */
+#endif
   "MAXINT", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2130,8 +2484,10 @@
 },
 {
   F_MAXLEN_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = MAXLEN", /* Syntax */
   "The maximum string length.",  /* Description */
+#endif
   "MAXLEN", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2141,9 +2497,11 @@
 },
 {
   F_MAXLEN_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = MAXLEN( A$ )", /* Syntax */
   "The maximum length associated with the simple-string-variable "
   "A$.",  /* Description */
+#endif
   "MAXLEN", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2153,8 +2511,10 @@
 },
 {
   F_MAXLNG_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = MAXLNG", /* Syntax */
   "The largest finite positive number representable as a LONG; implementation-defined.",  /* Description */
+#endif
   "MAXLNG", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2164,8 +2524,10 @@
 },
 {
   F_MAXLVL_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = MAXLVL", /* Syntax */
   "The maximum stack level; implementation-defined.",  /* Description */
+#endif
   "MAXLVL", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2175,10 +2537,12 @@
 },
 {
   F_MAXNUM_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = MAXNUM", /* Syntax */
   "The largest finite positive number representable and manipulable "
   "by the implementation; implementation-defined.  MAXNUM may represent "
   "diffent number for different arithmetic options (see OPTION ARITHMETIC).",  /* Description */
+#endif
   "MAXNUM", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2188,9 +2552,11 @@
 },
 {
   F_MAXSNG_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = MAXSNG", /* Syntax */
   "The largest finite positive number representable as a SINGLE; "
   "implementation-defined.",  /* Description */
+#endif
   "MAXSNG", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2200,10 +2566,12 @@
 },
 {
   F_MEM_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = MEM", /* Syntax */
   "The number of bytes of available memory.  This function is provided "
   "for backward compatibility only and it always returns a fixed "
   "value of 32000.",  /* Description */
+#endif
   "MEM", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2213,8 +2581,10 @@
 },
 {
   F_MID_A_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = MID( A$, X )", /* Syntax */
   "The characters of A$, starting from postion X.",  /* Description */
+#endif
   "MID", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -2224,8 +2594,10 @@
 },
 {
   F_MID_A_X_Y_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = MID( A$, X, Y )", /* Syntax */
   "The Y characters of A$, starting from postion X.",  /* Description */
+#endif
   "MID", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   3, /* ParameterCount */
@@ -2235,8 +2607,10 @@
 },
 {
   F_MID4_A_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = MID$( A$, X )", /* Syntax */
   "The characters of A$, starting from postion X.",  /* Description */
+#endif
   "MID$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -2246,8 +2620,10 @@
 },
 {
   F_MID4_A_X_Y_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = MID$( A$, X, Y )", /* Syntax */
   "The Y characters of A$, starting from postion X.",  /* Description */
+#endif
   "MID$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   3, /* ParameterCount */
@@ -2257,8 +2633,10 @@
 },
 {
   F_MIN_X_Y_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = MIN( X, Y )", /* Syntax */
   "The smaller of the parameters.",  /* Description */
+#endif
   "MIN", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -2268,8 +2646,10 @@
 },
 {
   F_MIN_A_B_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = MIN( A$, B$ )", /* Syntax */
   "The smaller of the parameters.",  /* Description */
+#endif
   "MIN", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -2279,8 +2659,10 @@
 },
 {
   F_MINBYT_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = MINBYT", /* Syntax */
   "The largest finite negative number representable as a BYTE; implementation-defined.",  /* Description */
+#endif
   "MINBYT", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2290,9 +2672,11 @@
 },
 {
   F_MINCUR_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = MINCUR", /* Syntax */
   "The largest finite negative number representable as a CURRENCY; "
   "implementation-defined.",  /* Description */
+#endif
   "MINCUR", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2302,9 +2686,11 @@
 },
 {
   F_MINDBL_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = MINDBL", /* Syntax */
   "The largest finite negative number representable as a DOUBLE; "
   "implementation-defined.",  /* Description */
+#endif
   "MINDBL", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2314,9 +2700,11 @@
 },
 {
   F_MINDEV_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = MINDEV", /* Syntax */
   "The largest finite negative number useable as a FILE NUMBER; "
   "implementation-defined.",  /* Description */
+#endif
   "MINDEV", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2326,9 +2714,11 @@
 },
 {
   F_MININT_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = MININT", /* Syntax */
   "The largest finite negative number representable as an INTEGER; "
   "implementation-defined.",  /* Description */
+#endif
   "MININT", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2338,8 +2728,10 @@
 },
 {
   F_MINLNG_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = MINLNG", /* Syntax */
   "The largest finite negative number representable as a LONG; implementation-defined.",  /* Description */
+#endif
   "MINLNG", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2349,10 +2741,12 @@
 },
 {
   F_MINNUM_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = MINNUM", /* Syntax */
   "The largest finite negative number representable and manipulable "
   "by the implementation; implementation-defined.  MINNUM may represent "
   "diffent number for different arithmetic options (see OPTION ARITHMETIC).",  /* Description */
+#endif
   "MINNUM", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2362,9 +2756,11 @@
 },
 {
   F_MINSNG_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = MINSNG", /* Syntax */
   "The largest finite negative number representable as a SINGLE; "
   "implementation-defined.",  /* Description */
+#endif
   "MINSNG", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2374,9 +2770,11 @@
 },
 {
   F_MKC4_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = MKC$( X )", /* Syntax */
   "The internal representation of the currency (64-bit) integer "
   "X as a string.",  /* Description */
+#endif
   "MKC$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2386,8 +2784,10 @@
 },
 {
   F_MKD4_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = MKD$( X )", /* Syntax */
   "The internal representation of X as a string.",  /* Description */
+#endif
   "MKD$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2397,8 +2797,10 @@
 },
 {
   F_MKDIR_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = MKDIR( A$ )", /* Syntax */
   "Makes the directory named in A$.",  /* Description */
+#endif
   "MKDIR", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2408,9 +2810,11 @@
 },
 {
   F_MKI4_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = MKI$( X )", /* Syntax */
   "The internal representation of the short (16-bit) integer X as "
   "a string.",  /* Description */
+#endif
   "MKI$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2420,9 +2824,11 @@
 },
 {
   F_MKL4_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = MKL$( X )", /* Syntax */
   "The internal representation of the long (32-bit) integer X as "
   "a string.",  /* Description */
+#endif
   "MKL$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2432,8 +2838,10 @@
 },
 {
   F_MKS4_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = MKS$( X )", /* Syntax */
   "The internal representation of X as a string.",  /* Description */
+#endif
   "MKS$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2443,8 +2851,10 @@
 },
 {
   F_MOD_X_Y_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = MOD( X, Y )", /* Syntax */
   "X modulo Y, i.e., X-Y*INT(X/Y).  Y shall not equal zero.",  /* Description */
+#endif
   "MOD", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -2454,8 +2864,10 @@
 },
 {
   F_NAME_A_B_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = NAME( A$, B$ )", /* Syntax */
   "Rename the file named A$ into B$.",  /* Description */
+#endif
   "NAME", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -2465,8 +2877,10 @@
 },
 {
   F_NAME_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = NAME( ... )", /* Syntax */
   "Returns hardware address of variable.  Causes ERROR 73.",  /* Description */
+#endif
   "NAME", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   255, /* ParameterCount */
@@ -2476,8 +2890,10 @@
 },
 {
   F_NOFLOW_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = NOFLOW", /* Syntax */
   "Turn tracing OFF",  /* Description */
+#endif
   "NOFLOW", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2487,8 +2903,10 @@
 },
 {
   F_NOTRACE_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = NOTRACE", /* Syntax */
   "Turn tracing OFF",  /* Description */
+#endif
   "NOTRACE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2498,9 +2916,11 @@
 },
 {
   F_NULL_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = NULL( X )", /* Syntax */
   "Appends X null characters after each line printed by LPRINT or "
   "LLIST.",  /* Description */
+#endif
   "NULL", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2510,9 +2930,11 @@
 },
 {
   F_NUM_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = NUM", /* Syntax */
   "The number of values processed by the last MAT INPUT.  Zero means "
   "error.",  /* Description */
+#endif
   "NUM", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2522,6 +2944,7 @@
 },
 {
   F_NUM_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = NUM( A$ )", /* Syntax */
   "The value of the numeric-constant associated with A$, if the "
   "string associated with A$ is a numeric-constant.  Leading and "
@@ -2530,6 +2953,7 @@
   "an underflow, then the value returned shall be zero.  For example, "
   "NUM( \" 123.5 \" ) = 123.5, NUM( \"2.E-99\" ) could be zero, and "
   "NUM( \"MCMXVII\" ) causes an exception.",  /* Description */
+#endif
   "NUM", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2539,9 +2963,11 @@
 },
 {
   F_NUM4_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = NUM$( X )", /* Syntax */
   "The string generated by the print-statement as the numeric-representation "
   "of the value associated with X.",  /* Description */
+#endif
   "NUM$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2551,8 +2977,10 @@
 },
 {
   F_OCT4_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = OCT$( X )", /* Syntax */
   "The the octal (base 8) representation of X.",  /* Description */
+#endif
   "OCT$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2562,9 +2990,11 @@
 },
 {
   F_OCT4_X_Y_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = OCT$( X, Y )", /* Syntax */
   "The the octal (base 8) representation of X.  The result will "
   "be at least Y digits long. ",  /* Description */
+#endif
   "OCT$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -2574,9 +3004,11 @@
 },
 {
   F_OPEN_A_X_B_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = OPEN( A$, X, B$ )", /* Syntax */
   "Open file number X.  A$ is the mode: \"I\", \"O\", \"A\", \"R\".  B$ "
   "is the file name.  Default the record length.",  /* Description */
+#endif
   "OPEN", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   3, /* ParameterCount */
@@ -2586,9 +3018,11 @@
 },
 {
   F_OPEN_A_X_B_Y_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = OPEN( A$, X, B$, Y )", /* Syntax */
   "Open file number X.  A$ is the mode: \"I\", \"O\", \"A\", \"R\".  B$ "
   "is the file name.  Y is the record length.",  /* Description */
+#endif
   "OPEN", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   4, /* ParameterCount */
@@ -2598,12 +3032,14 @@
 },
 {
   F_ORD_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ORD( A$ )", /* Syntax */
   "The ordinal position of the character named by the string associated "
   "with A$ in the collating sequence of ASCII character set, where "
   "the first member of the character set is in position zero.  The "
   "acceptable values for the standard character set are shown in "
   "Table 1.",  /* Description */
+#endif
   "ORD", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2613,8 +3049,10 @@
 },
 {
   F_OUT_X_Y_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = OUT( X, Y )", /* Syntax */
   "Sends Y to hardware port X.  Causes ERROR 73.",  /* Description */
+#endif
   "OUT", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -2624,8 +3062,10 @@
 },
 {
   F_PAD_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = PAD( X )", /* Syntax */
   "Returns zero.",  /* Description */
+#endif
   "PAD", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2635,10 +3075,12 @@
 },
 {
   F_PAUSE_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = PAUSE( X )", /* Syntax */
   "The program pauses for X times the value of OPTION SLEEP seconds. "
   " If the result is zero, negative, or more than INT_MAX then PAUSE "
   "does nothing.  The resolution is implementation defined.",  /* Description */
+#endif
   "PAUSE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2648,8 +3090,10 @@
 },
 {
   F_PDL_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = PDL( X )", /* Syntax */
   "The value read from machine port X.  Causes ERROR 73.",  /* Description */
+#endif
   "PDL", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2659,8 +3103,10 @@
 },
 {
   F_PEEK_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = PEEK( X )", /* Syntax */
   "The value read from hardware address X.  Causes ERROR 73.",  /* Description */
+#endif
   "PEEK", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2670,9 +3116,11 @@
 },
 {
   F_PI_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = PI", /* Syntax */
   "The constant 3.14159 which is the ratio of the circumference "
   "of a circle to its diameter.",  /* Description */
+#endif
   "PI", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2682,9 +3130,11 @@
 },
 {
   F_PI_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = PI( X )", /* Syntax */
   "The constant 3.14159 which is the ratio of the circumference "
   "of a circle to its diameter, times X.",  /* Description */
+#endif
   "PI", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2694,8 +3144,10 @@
 },
 {
   F_PIN_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = PIN( X )", /* Syntax */
   "The value read from machine port X.  Causes ERROR 73.",  /* Description */
+#endif
   "PIN", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2705,8 +3157,10 @@
 },
 {
   F_POKE_X_Y_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = POKE( X, Y )", /* Syntax */
   "Sends Y to hardware address X.  Causes ERROR 73.",  /* Description */
+#endif
   "POKE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -2716,8 +3170,10 @@
 },
 {
   F_POS_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = POS", /* Syntax */
   "The current cursor position in the line.",  /* Description */
+#endif
   "POS", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2727,8 +3183,10 @@
 },
 {
   F_POS_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = POS( X )", /* Syntax */
   "The current cursor position in the line for file X.",  /* Description */
+#endif
   "POS", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2738,11 +3196,13 @@
 },
 {
   F_POS_A_B_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = POS( A$, B$ )", /* Syntax */
   "The character position, within the value assocated with A$, of "
   "the first character of the first occurence of the value associated "
   "with B$, starting at the first character of A$.  If there is "
   "not such occurence, then the value returned is zero.",  /* Description */
+#endif
   "POS", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -2752,11 +3212,13 @@
 },
 {
   F_POS_A_B_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = POS( A$, B$, X )", /* Syntax */
   "The character position, within the value assocated with A$, of "
   "the first character of the first occurence of the value associated "
   "with B$, starting at the Xth character of A$.  If there is not "
   "such occurence, then the value returned is zero.",  /* Description */
+#endif
   "POS", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   3, /* ParameterCount */
@@ -2766,9 +3228,11 @@
 },
 {
   F_PRECISION_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = PRECISION( X )", /* Syntax */
   "X is the number of decimal places to round (0..17).  If X = 0 "
   "then disabled.",  /* Description */
+#endif
   "PRECISION", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2778,8 +3242,10 @@
 },
 {
   F_PTR_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = PTR( ... )", /* Syntax */
   "Returns hardware address of variable.  Causes ERROR 73.",  /* Description */
+#endif
   "PTR", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   255, /* ParameterCount */
@@ -2789,9 +3255,11 @@
 },
 {
   F_PUT_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = PUT( X )", /* Syntax */
   "Send character code to output.  Returns the value of X.  Similar "
   "to PRINT CHR$(X).",  /* Description */
+#endif
   "PUT", /* Name */
   IntegerTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2801,8 +3269,10 @@
 },
 {
   F_PUT_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = PUT( X )", /* Syntax */
   "For file X, puts the next available record.",  /* Description */
+#endif
   "PUT", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2812,9 +3282,11 @@
 },
 {
   F_PUT_X_Y_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = PUT( X, Y )", /* Syntax */
   "For file X, puts record number Y.  The first record number is "
   "1.",  /* Description */
+#endif
   "PUT", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -2824,9 +3296,11 @@
 },
 {
   F_RAD_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = RAD", /* Syntax */
   "Configures the math functions to accept and return angles in "
   "radians.",  /* Description */
+#endif
   "RAD", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2836,8 +3310,10 @@
 },
 {
   F_RAD_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = RAD( X )", /* Syntax */
   "The number of radians in X degrees.",  /* Description */
+#endif
   "RAD", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2847,9 +3323,11 @@
 },
 {
   F_RADIAN_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = RADIAN", /* Syntax */
   "Configures the math functions to accept and return angles in "
   "radians.",  /* Description */
+#endif
   "RADIAN", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2859,8 +3337,10 @@
 },
 {
   F_RAN_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = RAN", /* Syntax */
   "Seeds the pseudo-random number generator with TIME.",  /* Description */
+#endif
   "RAN", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2870,8 +3350,10 @@
 },
 {
   F_RAN_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = RAN( X )", /* Syntax */
   "Seeds the pseudo-random number generator with X.",  /* Description */
+#endif
   "RAN", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2881,8 +3363,10 @@
 },
 {
   F_RANDOM_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = RANDOM", /* Syntax */
   "Seeds the pseudo-random number generator with TIME.",  /* Description */
+#endif
   "RANDOM", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2892,8 +3376,10 @@
 },
 {
   F_RANDOM_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = RANDOM( X )", /* Syntax */
   "Seeds the pseudo-random number generator with X.",  /* Description */
+#endif
   "RANDOM", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2903,8 +3389,10 @@
 },
 {
   F_RANDOMIZE_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = RANDOMIZE", /* Syntax */
   "Seeds the pseudo-random number generator with TIME.",  /* Description */
+#endif
   "RANDOMIZE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2914,8 +3402,10 @@
 },
 {
   F_RANDOMIZE_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = RANDOMIZE( X )", /* Syntax */
   "Seeds the pseudo-random number generator with X.",  /* Description */
+#endif
   "RANDOMIZE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -2925,9 +3415,11 @@
 },
 {
   F_REMAINDER_X_Y_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = REMAINDER( X, Y )", /* Syntax */
   "The remainder function, i.e., X-Y*IP(X/Y).  Y shall not equal "
   "zero.",  /* Description */
+#endif
   "REMAINDER", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -2937,9 +3429,11 @@
 },
 {
   F_RENAME_A_B_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = RENAME( A$, B$ )", /* Syntax */
   "Rename file A$ to B$.  If successful, the returns -1 else returns "
   "0.",  /* Description */
+#endif
   "RENAME", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -2949,8 +3443,10 @@
 },
 {
   F_REPEAT4_X_A_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = REPEAT$( X, A$ )", /* Syntax */
   "The string consisting of X copies of LEFT$(A$,1); X > 0.",  /* Description */
+#endif
   "REPEAT$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -2960,8 +3456,10 @@
 },
 {
   F_REPEAT4_X_Y_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = REPEAT$( X, Y )", /* Syntax */
   "The string consisting of X copies of CHR$(Y); X > 0.",  /* Description */
+#endif
   "REPEAT$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -2971,8 +3469,10 @@
 },
 {
   F_RESET_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = RESET", /* Syntax */
   "Close all open files.",  /* Description */
+#endif
   "RESET", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2982,10 +3482,12 @@
 },
 {
   F_RESIDUE_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = RESIDUE", /* Syntax */
   "The residue of the last Integer Divide operation.  The RESIDUE "
   "of -17 / 5 is -2.  For X / Y, RESIDUE = CINT( X - Y * CINT( X "
   "/ Y ) ).",  /* Description */
+#endif
   "RESIDUE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -2995,8 +3497,10 @@
 },
 {
   F_RIGHT_A_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = RIGHT( A$, X )", /* Syntax */
   "The right-most X characters of A$.",  /* Description */
+#endif
   "RIGHT", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -3006,8 +3510,10 @@
 },
 {
   F_RIGHT4_A_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = RIGHT$( A$, X )", /* Syntax */
   "The right-most X characters of A$.",  /* Description */
+#endif
   "RIGHT$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -3017,8 +3523,10 @@
 },
 {
   F_RMDIR_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = RMDIR( A$ )", /* Syntax */
   "Removes the directory named in A$.",  /* Description */
+#endif
   "RMDIR", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3028,10 +3536,12 @@
 },
 {
   F_RND_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = RND", /* Syntax */
   "The next pseudo-random number in an implementation-defined sequence "
   "of pseudo-random numbers uniformly distributed in the range 0 "
   "<= RND < 1.",  /* Description */
+#endif
   "RND", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -3041,9 +3551,11 @@
 },
 {
   F_RND_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = RND( X )", /* Syntax */
   "Returns a pseudorandom number in the range [0,1].  The value "
   "of X is ignored.",  /* Description */
+#endif
   "RND", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3053,10 +3565,12 @@
 },
 {
   F_ROUND_X_Y_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ROUND( X, Y )", /* Syntax */
   "The value of X rounded to Y decimal digits to the right of the "
   "decimal point (or -Y digits to the left if Y < 0); i.e., INT(X*10^Y+.5)/10^Y. "
   " Y must be in [-32,32].",  /* Description */
+#endif
   "ROUND", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -3066,9 +3580,11 @@
 },
 {
   F_RTRIM4_A_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = RTRIM$( A$ )", /* Syntax */
   "The string of characters resulting from the value associated "
   "with A$ by deleting all trailing space characters.",  /* Description */
+#endif
   "RTRIM$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3078,9 +3594,11 @@
 },
 {
   F_SCALE_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = SCALE( X )", /* Syntax */
   "X is the number of decimal places to round (0..17).  If X = 0 "
   "then disabled.",  /* Description */
+#endif
   "SCALE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3090,8 +3608,10 @@
 },
 {
   F_SEC_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = SEC( X )", /* Syntax */
   "The secant of X, where X is in radians.",  /* Description */
+#endif
   "SEC", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3101,9 +3621,11 @@
 },
 {
   F_SEEK_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = SEEK( X )", /* Syntax */
   "The location of file X; the next record that GET or PUT statements "
   "will use.",  /* Description */
+#endif
   "SEEK", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3113,9 +3635,11 @@
 },
 {
   F_SEEK_X_Y_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = SEEK( X, Y )", /* Syntax */
   "For file X, move to record number Y; the first record number "
   "is 1.",  /* Description */
+#endif
   "SEEK", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -3125,8 +3649,10 @@
 },
 {
   F_SEG_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = SEG( X )", /* Syntax */
   "Returns zero.",  /* Description */
+#endif
   "SEG", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3136,8 +3662,10 @@
 },
 {
   F_SEG_A_X_Y_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = SEG( A$, X, Y )", /* Syntax */
   "The Y characters of A$, starting from postion X.",  /* Description */
+#endif
   "SEG", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   3, /* ParameterCount */
@@ -3147,8 +3675,10 @@
 },
 {
   F_SEG4_A_X_Y_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = SEG$( A$, X, Y )", /* Syntax */
   "The Y characters of A$, starting from postion X.",  /* Description */
+#endif
   "SEG$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   3, /* ParameterCount */
@@ -3158,8 +3688,10 @@
 },
 {
   F_SGN_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = SGN( X )", /* Syntax */
   "The sign of X: -1 if X < 0, 0 if X = 0, and +1 if X > 0.",  /* Description */
+#endif
   "SGN", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3169,9 +3701,11 @@
 },
 {
   F_SHELL_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = SHELL( A$ )", /* Syntax */
   "The exit code resulting from the execution of an operating system "
   "command.",  /* Description */
+#endif
   "SHELL", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3181,8 +3715,10 @@
 },
 {
   F_SIN_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = SIN( X )", /* Syntax */
   "The sine of X, where X is in radians.",  /* Description */
+#endif
   "SIN", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3192,8 +3728,10 @@
 },
 {
   F_SIND_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = SIND( X )", /* Syntax */
   "The sine of X, where X is in degrees.",  /* Description */
+#endif
   "SIND", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3203,8 +3741,10 @@
 },
 {
   F_SING_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = SING( X )", /* Syntax */
   "The sine of X, where X is in gradians.",  /* Description */
+#endif
   "SING", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3214,8 +3754,10 @@
 },
 {
   F_SINH_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = SINH( X )", /* Syntax */
   "The hyperbolic sine of X.",  /* Description */
+#endif
   "SINH", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3225,8 +3767,10 @@
 },
 {
   F_SIZE_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = SIZE( A$ )", /* Syntax */
   "The total number of 1KB blockes required to contain the file.",  /* Description */
+#endif
   "SIZE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3236,8 +3780,10 @@
 },
 {
   F_SIZE_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = SIZE( ... )", /* Syntax */
   "SIZE( arrayname ).  The total number of items in the array.",  /* Description */
+#endif
   "SIZE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   255, /* ParameterCount */
@@ -3247,10 +3793,12 @@
 },
 {
   F_SLEEP_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = SLEEP( X )", /* Syntax */
   "The program pauses for X times the value of OPTION SLEEP seconds. "
   " If the result is zero, negative, or more than INT_MAX then SLEEP "
   "does nothing.  The resolution is implementation defined.",  /* Description */
+#endif
   "SLEEP", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3260,8 +3808,10 @@
 },
 {
   F_SNH_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = SNH( X )", /* Syntax */
   "The hyperbolic sine of X.",  /* Description */
+#endif
   "SNH", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3271,8 +3821,10 @@
 },
 {
   F_SPA_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = SPA( X )", /* Syntax */
   "The string of X blank spaces.",  /* Description */
+#endif
   "SPA", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3282,8 +3834,10 @@
 },
 {
   F_SPACE_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = SPACE( X )", /* Syntax */
   "The string of X blank spaces.",  /* Description */
+#endif
   "SPACE", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3293,8 +3847,10 @@
 },
 {
   F_SPACE4_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = SPACE$( X )", /* Syntax */
   "The string of X blank spaces.",  /* Description */
+#endif
   "SPACE$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3304,8 +3860,10 @@
 },
 {
   F_SPC_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = SPC( X )", /* Syntax */
   "The string of X spaces.  Only for use within the PRINT command.",  /* Description */
+#endif
   "SPC", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3315,8 +3873,10 @@
 },
 {
   F_SQR_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = SQR( X )", /* Syntax */
   "The non-negative square root of X;  X shall be non-negative.",  /* Description */
+#endif
   "SQR", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3326,8 +3886,10 @@
 },
 {
   F_SQRT_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = SQRT( X )", /* Syntax */
   "The non-negative square root of X;  X shall be non-negative.",  /* Description */
+#endif
   "SQRT", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3337,8 +3899,10 @@
 },
 {
   F_STR_X_Y_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = STR( X, Y )", /* Syntax */
   "The string X bytes long consisting of CHR$(Y).",  /* Description */
+#endif
   "STR", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -3348,9 +3912,11 @@
 },
 {
   F_STR4_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = STR$( X )", /* Syntax */
   "The string generated by the print-statement as the numeric-representation "
   "of the value associated with X.",  /* Description */
+#endif
   "STR$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3360,8 +3926,10 @@
 },
 {
   F_STRING_X_Y_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = STRING( X, Y )", /* Syntax */
   "The string X bytes long consisting of CHR$(Y).",  /* Description */
+#endif
   "STRING", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -3371,9 +3939,11 @@
 },
 {
   F_STRING4_X_A_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = STRING$( X, A$ )", /* Syntax */
   "The string X bytes long consisting of the first character of "
   "A$.",  /* Description */
+#endif
   "STRING$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -3383,8 +3953,10 @@
 },
 {
   F_STRING4_X_Y_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = STRING$( X, Y )", /* Syntax */
   "The string X bytes long consisting of CHR$(Y).",  /* Description */
+#endif
   "STRING$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -3394,8 +3966,10 @@
 },
 {
   F_STRIP4_A_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = STRIP$( A$ )", /* Syntax */
   "Return the string with the eighth bit of each character cleared.",  /* Description */
+#endif
   "STRIP$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3405,8 +3979,10 @@
 },
 {
   F_STUFF_X_Y_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = STUFF( X, Y )", /* Syntax */
   "Sends Y to hardware address X.  Causes ERROR 73.",  /* Description */
+#endif
   "STUFF", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -3416,9 +3992,11 @@
 },
 {
   F_TAB_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = TAB( X )", /* Syntax */
   "The string required to advance to column X.  Only for use within "
   "the PRINT command.",  /* Description */
+#endif
   "TAB", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3428,8 +4006,10 @@
 },
 {
   F_TAN_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = TAN( X )", /* Syntax */
   "The tangent of X, where X is in radians.",  /* Description */
+#endif
   "TAN", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3439,8 +4019,10 @@
 },
 {
   F_TAND_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = TAND( X )", /* Syntax */
   "The tangent of X, where X is in degrees.",  /* Description */
+#endif
   "TAND", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3450,8 +4032,10 @@
 },
 {
   F_TANG_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = TANG( X )", /* Syntax */
   "The tangent of X, where X is in gradians.",  /* Description */
+#endif
   "TANG", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3461,8 +4045,10 @@
 },
 {
   F_TANH_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = TANH( X )", /* Syntax */
   "The hyperbolic tangent of X.",  /* Description */
+#endif
   "TANH", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3472,11 +4058,13 @@
 },
 {
   F_TI_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = TI", /* Syntax */
   "The time elapsed since the previous midnight, expressed in seconds; "
   "e.g., the value of TIME at 11:15 AM is 40500.  If there is no "
   "clock available, then the value of TIME shall be -1.  The value "
   "of TIME at midnight shall be zero (not 86400).",  /* Description */
+#endif
   "TI", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -3486,11 +4074,13 @@
 },
 {
   F_TI4_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = TI$", /* Syntax */
   "The time of day in 24-hour notation according to ISO 3307.  For "
   "example, the value of TIME$ at 11:15 AM is \"11:15:00\".  If there "
   "is no clock available, then the value of TIME$ shall be \"99:99:99\". "
   " The value of TIME$ at midnight is \"00:00:00\".",  /* Description */
+#endif
   "TI$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -3500,11 +4090,13 @@
 },
 {
   F_TIM_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = TIM", /* Syntax */
   "The time elapsed since the previous midnight, expressed in seconds; "
   "e.g., the value of TIME at 11:15 AM is 40500.  If there is no "
   "clock available, then the value of TIME shall be -1.  The value "
   "of TIME at midnight shall be zero (not 86400).",  /* Description */
+#endif
   "TIM", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -3514,11 +4106,13 @@
 },
 {
   F_TIM_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = TIM( X )", /* Syntax */
   "If X is 0, returns minutes in current hour.  If X is 1, returns "
   "hours in current day.  If X is 2, returns days in current year. "
   " If X is 3, returns years since 1900.  Any other value for X "
   "is an ERROR.",  /* Description */
+#endif
   "TIM", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3528,11 +4122,13 @@
 },
 {
   F_TIME_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = TIME", /* Syntax */
   "The time elapsed since the previous midnight, expressed in seconds; "
   "e.g., the value of TIME at 11:15 AM is 40500.  If there is no "
   "clock available, then the value of TIME shall be -1.  The value "
   "of TIME at midnight shall be zero (not 86400).",  /* Description */
+#endif
   "TIME", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -3542,12 +4138,14 @@
 },
 {
   F_TIME_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = TIME( X )", /* Syntax */
   "The time elapsed since the previous midnight, expressed in seconds; "
   "e.g., the value of TIME at 11:15 AM is 40500.  If there is no "
   "clock available, then the value of TIME shall be -1.  The value "
   "of TIME at midnight shall be zero (not 86400).  The value of "
   "the parameter X is ignored.",  /* Description */
+#endif
   "TIME", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3557,11 +4155,13 @@
 },
 {
   F_TIME4_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = TIME$", /* Syntax */
   "The time of day in 24-hour notation according to ISO 3307.  For "
   "example, the value of TIME$ at 11:15 AM is \"11:15:00\".  If there "
   "is no clock available, then the value of TIME$ shall be \"99:99:99\". "
   " The value of TIME$ at midnight is \"00:00:00\".",  /* Description */
+#endif
   "TIME$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -3571,12 +4171,14 @@
 },
 {
   F_TIME4_X_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = TIME$( X )", /* Syntax */
   "The time of day in 24-hour notation according to ISO 3307.  For "
   "example, the value of TIME$ at 11:15 AM is \"11:15:00\".  If there "
   "is no clock available, then the value of TIME$ shall be \"99:99:99\". "
   " The value of TIME$ at midnight is \"00:00:00\".  The value of "
   "X is ignored.",  /* Description */
+#endif
   "TIME$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3586,8 +4188,10 @@
 },
 {
   F_TIMER_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = TIMER", /* Syntax */
   "The time in the system clock in seconds elapsed since midnight.",  /* Description */
+#endif
   "TIMER", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -3597,10 +4201,12 @@
 },
 {
   F_TOP_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = TOP", /* Syntax */
   "The address of the top of available memory.  This function is "
   "provided for backward compatibility only and it always returns "
   "a fixed value of 32000.",  /* Description */
+#endif
   "TOP", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -3610,8 +4216,10 @@
 },
 {
   F_TRACE_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = TRACE", /* Syntax */
   "Turn tracing ON",  /* Description */
+#endif
   "TRACE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -3621,9 +4229,11 @@
 },
 {
   F_TRACE_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = TRACE( X )", /* Syntax */
   "When X is zero turn tracing off.  When X is non-zero turn tracing "
   "ON",  /* Description */
+#endif
   "TRACE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3633,9 +4243,11 @@
 },
 {
   F_TRIM4_A_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = TRIM$( A$ )", /* Syntax */
   "The string resulting from removing both leading and trailing "
   "spaces from A$.",  /* Description */
+#endif
   "TRIM$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3645,8 +4257,10 @@
 },
 {
   F_TROFF_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = TROFF", /* Syntax */
   "Turn tracing OFF",  /* Description */
+#endif
   "TROFF", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -3656,8 +4270,10 @@
 },
 {
   F_TRON_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = TRON", /* Syntax */
   "Turn tracing ON",  /* Description */
+#endif
   "TRON", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -3667,8 +4283,10 @@
 },
 {
   F_TRUE_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = TRUE", /* Syntax */
   "The value of TRUE.",  /* Description */
+#endif
   "TRUE", /* Name */
   IntegerTypeCode, /* ReturnTypeCode */
   0, /* ParameterCount */
@@ -3678,10 +4296,12 @@
 },
 {
   F_TRUNCATE_X_Y_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = TRUNCATE( X, Y )", /* Syntax */
   "The value of X truncated to Y decimal digits to the right of "
   "the decimal point (or -Y digits to the left if Y < 0); i.e., "
   "IP(X*10^Y)/10^Y.  Y in [-32,32].",  /* Description */
+#endif
   "TRUNCATE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -3691,9 +4311,11 @@
 },
 {
   F_UBOUND_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = UBOUND( ... )", /* Syntax */
   "UBOUND( arrayname [, dimension] ).  The upper bound of the array. "
   " The dimension defaults to 1.  dimension in [1,DIM(arrayname)]",  /* Description */
+#endif
   "UBOUND", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   255, /* ParameterCount */
@@ -3703,10 +4325,12 @@
 },
 {
   F_UCASE4_A_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = UCASE$( A$ )", /* Syntax */
   "The string of characters resulting from the value associated "
   "with A$ by replacing each lower-case-letter in the string by "
   "its upper-case version.",  /* Description */
+#endif
   "UCASE$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3716,8 +4340,10 @@
 },
 {
   F_UNLOCK_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = UNLOCK( X )", /* Syntax */
   "Unlock file number X.  Causes ERROR 73.",  /* Description */
+#endif
   "UNLOCK", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3727,8 +4353,10 @@
 },
 {
   F_UNSAVE_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = UNSAVE( A$ )", /* Syntax */
   "Removes the file named in A$.",  /* Description */
+#endif
   "UNSAVE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3738,10 +4366,12 @@
 },
 {
   F_UPPER4_A_S, /* UniqueID */
+#ifndef NO_HELP
   "S$ = UPPER$( A$ )", /* Syntax */
   "The string of characters resulting from the value associated "
   "with A$ by replacing each lower-case-letter in the string by "
   "its upper-case version.",  /* Description */
+#endif
   "UPPER$", /* Name */
   StringTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3751,8 +4381,10 @@
 },
 {
   F_USR_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = USR( ... )", /* Syntax */
   "Execute hardware program.  Causes ERROR 73.",  /* Description */
+#endif
   "USR", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   255, /* ParameterCount */
@@ -3762,8 +4394,10 @@
 },
 {
   F_USR0_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = USR0( ... )", /* Syntax */
   "Execute hardware program.  Causes ERROR 73.",  /* Description */
+#endif
   "USR0", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   255, /* ParameterCount */
@@ -3773,8 +4407,10 @@
 },
 {
   F_USR1_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = USR1( ... )", /* Syntax */
   "Execute hardware program.  Causes ERROR 73.",  /* Description */
+#endif
   "USR1", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   255, /* ParameterCount */
@@ -3784,8 +4420,10 @@
 },
 {
   F_USR2_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = USR2( ... )", /* Syntax */
   "Execute hardware program.  Causes ERROR 73.",  /* Description */
+#endif
   "USR2", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   255, /* ParameterCount */
@@ -3795,8 +4433,10 @@
 },
 {
   F_USR3_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = USR3( ... )", /* Syntax */
   "Execute hardware program.  Causes ERROR 73.",  /* Description */
+#endif
   "USR3", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   255, /* ParameterCount */
@@ -3806,8 +4446,10 @@
 },
 {
   F_USR4_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = USR4( ... )", /* Syntax */
   "Execute hardware program.  Causes ERROR 73.",  /* Description */
+#endif
   "USR4", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   255, /* ParameterCount */
@@ -3817,8 +4459,10 @@
 },
 {
   F_USR5_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = USR5( ... )", /* Syntax */
   "Execute hardware program.  Causes ERROR 73.",  /* Description */
+#endif
   "USR5", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   255, /* ParameterCount */
@@ -3828,8 +4472,10 @@
 },
 {
   F_USR6_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = USR6( ... )", /* Syntax */
   "Execute hardware program.  Causes ERROR 73.",  /* Description */
+#endif
   "USR6", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   255, /* ParameterCount */
@@ -3839,8 +4485,10 @@
 },
 {
   F_USR7_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = USR7( ... )", /* Syntax */
   "Execute hardware program.  Causes ERROR 73.",  /* Description */
+#endif
   "USR7", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   255, /* ParameterCount */
@@ -3850,8 +4498,10 @@
 },
 {
   F_USR8_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = USR8( ... )", /* Syntax */
   "Execute hardware program.  Causes ERROR 73.",  /* Description */
+#endif
   "USR8", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   255, /* ParameterCount */
@@ -3861,8 +4511,10 @@
 },
 {
   F_USR9_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = USR9( ... )", /* Syntax */
   "Execute hardware program.  Causes ERROR 73.",  /* Description */
+#endif
   "USR9", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   255, /* ParameterCount */
@@ -3872,8 +4524,10 @@
 },
 {
   F_UUF_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = UUF( ... )", /* Syntax */
   "Execute hardware program.  Causes ERROR 73.",  /* Description */
+#endif
   "UUF", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   255, /* ParameterCount */
@@ -3883,6 +4537,7 @@
 },
 {
   F_VAL_A_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = VAL( A$ )", /* Syntax */
   "The value of the numeric-constant associated with A$, if the "
   "string associated with A$ is a numeric-constant.  Leading and "
@@ -3891,6 +4546,7 @@
   "an underflow, then the value returned shall be zero.  For example, "
   "VAL( \" 123.5 \" ) = 123.5, VAL( \"2.E-99\" ) could be zero, and "
   "VAL( \"MCMXVII\" ) causes an exception.",  /* Description */
+#endif
   "VAL", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3900,8 +4556,10 @@
 },
 {
   F_VARPTR_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = VARPTR( ... )", /* Syntax */
   "Returns hardware address of variable.  Causes ERROR 73.",  /* Description */
+#endif
   "VARPTR", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   255, /* ParameterCount */
@@ -3911,8 +4569,10 @@
 },
 {
   F_VTAB_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = VTAB( X )", /* Syntax */
   "Savme as LOCATE X, 1.",  /* Description */
+#endif
   "VTAB", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3922,10 +4582,12 @@
 },
 {
   F_WAIT_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = WAIT( X )", /* Syntax */
   "The program pauses for X times the value of OPTION SLEEP seconds. "
   " If the result is zero, negative, or more than INT_MAX then WAIT "
   "does nothing.  The resolution is implementation defined.",  /* Description */
+#endif
   "WAIT", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3935,9 +4597,11 @@
 },
 {
   F_WAIT_X_Y_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = WAIT( X, Y )", /* Syntax */
   "Waits for the value of (INP(X) AND Y) to become nonzero.  Causes "
   "ERROR 73.",  /* Description */
+#endif
   "WAIT", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -3947,9 +4611,11 @@
 },
 {
   F_WAIT_X_Y_Z_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = WAIT( X, Y, Z )", /* Syntax */
   "Waits for the value of ((INP(X) XOR Z) AND Y) to become nonzero. "
   " Causes ERROR 73.",  /* Description */
+#endif
   "WAIT", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   3, /* ParameterCount */
@@ -3959,9 +4625,11 @@
 },
 {
   F_WIDTH_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = WIDTH( X )", /* Syntax */
   "For console, sets the line width to X. Zero means no wrapping "
   "will occur.",  /* Description */
+#endif
   "WIDTH", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3971,11 +4639,13 @@
 },
 {
   F_WIDTH_X_Y_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = WIDTH( X, Y )", /* Syntax */
   "If X = 0, sets the console width to Y.\nIf X < 0, sets the printer "
   "width to Y.\nIf X is an open file number, sets the file line width "
   "to Y.\nOtherwise sets the console rows to X and the line width "
   "to Y.\nA value of zero for Y means no wrapping will occur.",  /* Description */
+#endif
   "WIDTH", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
@@ -3985,8 +4655,10 @@
 },
 {
   F_ZONE_X_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ZONE( X )", /* Syntax */
   "Sets the width of the print zones.",  /* Description */
+#endif
   "ZONE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   1, /* ParameterCount */
@@ -3996,8 +4668,10 @@
 },
 {
   F_ZONE_X_Y_N, /* UniqueID */
+#ifndef NO_HELP
   "N  = ZONE( X, Y )", /* Syntax */
   "X is ignored.  Y sets the width of the print zones.",  /* Description */
+#endif
   "ZONE", /* Name */
   DoubleTypeCode, /* ReturnTypeCode */
   2, /* ParameterCount */
