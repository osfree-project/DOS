--- orig/debug.asm	2023-01-08 21:56:03.585624042 +0300
+++ contrib/debug.asm	2023-01-08 21:56:03.581623959 +0300
@@ -60,27 +60,27 @@
 TOUPPER_W equ 0dfdfh
 MNEMONOFS equ 28	;offset in output line where mnemonics start (disassember)
 
-%if PM
-%define VDD        1	;try to load DEBXXVDD.DLL
-%define NOEXTENDER 1	;don't assume DPMI host includes a DOS extender
-%define WIN9XSUPP  1	;avoid to hook DPMI entry when running in Win9x
-%define DOSEMU     1	;avoid to hook DPMI entry when running in DosEmu
-%define EXCCSIP    1	;display CS:IP where exception occured
-%define DISPHOOK   1	;display "DPMI entry hooked..."
-%define DBGNAME "DEBUGX"
-%define DBGNAME2 "DebugX"
-%else
-%define VDD 0
-%define NOEXTENDER 0
-%define DBGNAME "DEBUG"
-%define DBGNAME2 "Debug"
-%endif
+if PM eq 1
+VDD         equ   1	;try to load DEBXXVDD.DLL
+NOEXTENDER  equ   1	;don't assume DPMI host includes a DOS extender
+WIN9XSUPP   equ   1	;avoid to hook DPMI entry when running in Win9x
+DOSEMU      equ   1	;avoid to hook DPMI entry when running in DosEmu
+EXCCSIP     equ   1	;display CS:IP where exception occured
+DISPHOOK    equ   1	;display "DPMI entry hooked..."
+DBGNAME     equ   "DEBUGX"
+DBGNAME2    equ   "DebugX"
+else
+VDD         equ   0
+NOEXTENDER  equ   0
+DBGNAME     equ   "DEBUG"
+DBGNAME2    equ   "Debug"
+endif
 
 ;%define DOSNAME "FreeDOS"
-%define DOSNAME	"DOS"
-%define MCB 1			;support DM command
-%define USESDA 1		;use SDA to get/set PSP in real-mode
-%define MMXSUPP	0		;support MMX specific commands
+DOSNAME     equ	  "DOS"
+MCB         equ   1			;support DM command
+USESDA      equ   1		;use SDA to get/set PSP in real-mode
+MMXSUPP     equ   0		;support MMX specific commands
 
 LINE_IN_LEN equ	257		;length of line_in (including header stuff)
 
@@ -94,45 +94,39 @@
 SPSAV	equ	2eh	;Save the stack pointer here
 DTA		equ	80h	;Program arguments; also used to store file name (N cmd)
 
-%if 0
-	[segment _TEXT]
-%else    
+_TEXT   segment dword public 'CODE'  use16
+
 	org	100h
-%endif    
 
-%if NASM
-%macro cpufpu 1
-	cpu %1
-%endmacro    
-%else
-%macro cpufpu 1
-	cpu %1 fpu
-%endmacro    
-%endif
-
-%macro mne 3
-	dw %1
-    db %2, %3
-%endmacro
+cpufpu macro x
+        .x
+endm    
+mne macro a,b,c
+    dw &a
+    db <&b>
+    db <&c>+80h
+endm
 
-%if VDD
-%macro RegisterModule 0
+if VDD
+RegisterModule macro
 	db 0C4h, 0C4h, 58h, 0
-%endmacro
-%macro UnRegisterModule 0
+endm
+UnRegisterModule macro
 	db 0C4h, 0C4h, 58h, 1
-%endmacro
-%macro DispatchCall 0
+endm
+DispatchCall macro
 	db 0C4h, 0C4h, 58h, 2
-%endmacro
-%endif
-
-	cpu 8086
+endm
+endif
 
+;	cpu 8086
+.8086
+__start:
 	jmp	initcode
 
-cmdlist	dw aa,error,cc,ddd,ee,ff,gg,hh,ii,error,error,ll,mm,nn,oo
-		dw pp,qq,rr,sss,tt,uu,error,ww,xx
+cmdlist	dw offset aa,offset error,offset cc,offset ddd,offset ee,offset ff
+        dw offset gg,offset hh,offset ii,offset error,offset error,offset ll,offset mm,offset nn,offset oo
+	dw offset pp,offset qq,offset rr,offset sss,offset tt,offset uu,offset error,offset ww,offset xx
 
 savesp	dw 0		;save stack pointer
 errret	dw 0		;return here if error
@@ -141,30 +135,30 @@
 pspdbe  dw 0		;debuggee's program segment prefix
 pspdbg  dw 0		;debugger's program segment prefix (always a segment)
 run2324	dw 0,0,0,0	;debuggee's interrupt vectors 23 and 24 (both modes)
-%if PM
+if PM eq 1
 		dw 0,0
-dbg2324 dw myi23, myi24
-%if VDD
+dbg2324 dw offset myi23, offset myi24
+if VDD
 hVdd	dw -1
-%endif
-%endif
+endif
+endif
 sav2324	dw 0,0,0,0	;debugger's interrupt vectors 23 and 24 (real-mode only)
 hakstat	db 0		;whether we have hacked the vectors or not
 psp22	dw 0,0		;original terminate address in the PSP
 parent	dw 0		;original PSP of process parent (must be next)
-%if MCB
+if MCB
 wMCB	dw 0		;start of MCB chain
-%endif
+endif
 pInDOS	dd 0		;far16 address of InDOS flag
-%if PM
+if PM eq 1
 InDosSegm dw 0		;saved segment value of pInDOS
-%endif
-%if USESDA
+endif
+if USESDA
 pSDA	dd 0		;far16 address of DOS swappable data area
-%if PM
+if PM eq 1
 SDASegm	dw 0		;saved segment value of pSDA
-%endif
-%endif
+endif
+endif
 machine	db 0		;type of this processor
 regsdmp db 0		;bit 0: 1=386 register display
 tmode	db 0		;bit 0: 1=ms-dos compatible trace mode
@@ -175,20 +169,20 @@
 switchar db	0		;switch character
 swch1	db ' '		;switch character if it's a slash
 promptlen dw 0		;length of prompt
-bufnext	dw line_in+2	;address of next available character
-bufend	dw line_in+2	;address + 1 of last valid character
+bufnext	dw offset line_in+2	;address of next available character
+bufend	dw offset line_in+2	;address + 1 of last valid character
 
 a_addr	dw 0,0,0	;address for next A command
 d_addr	dw 0,0,0	;address of last D command; must follow a_addr
 u_addr	dw 0,0,0	;address of last U command; must follow d_addr
-%if PM
+if PM eq 1
 x_addr	dd 0		;address of last DX command
-%endif
+endif
 eqflag	db 0		;flag indicating presence of `=' operand
 eqladdr	dw 0,0,0	;address of `=' operand in G, P and T command
 run_cs	dw 0		;save original CS when running in G
 run_int	dw 0		;interrupt type that stopped the running
-lastcmd dw dmycmd
+lastcmd dw offset dmycmd
 bInit	db 0		;0=ensure a valid opcode is at debuggee's CS:IP
 fileext	db 0		;file extension (0 if no file name)
 
@@ -197,26 +191,25 @@
 EXT_EXE		equ	4
 EXT_HEX		equ	8
 
-inttab
-	db 0
-	dw intr0		;table of interrupt initialization stuff
+inttab	db 0
+	dw offset intr0		;table of interrupt initialization stuff
 	db 1
-	dw intr1
+	dw offset intr1
 	db 3
-	dw intr3
+	dw offset intr3
 	db 22h
-	dw debug22
-%if PM
+	dw offset debug22
+if PM eq 1
 	db 2Fh
-%endif
+endif
 
 intsave	dd 0		;save area for interrupt vectors 0, 1, 3, 22h, 2Fh
 	dd 0
 	dd 0
 	dd 0
-%if PM    
+if PM eq 1
 oldi2f	dd 0
-%endif
+endif
 
 ;	Parameter block for exec call.
 
@@ -264,8 +257,8 @@
 regh_eip dw 0		;+60
 regh_efl dw 0		;+62
 
-regnames dw	'AX','BX','CX','DX','SP','BP','SI','DI','DS','ES'
-	dw	'SS','CS','FS','GS','IP','FL'
+regnames dw	'XA','XB','XC','XD','PS','PB','IS','ID','SD','SD'
+	dw	'SS','SC','SF','SG','PI','LF'
 
 ;	Instruction set information needed for the 'p' command.
 
@@ -302,24 +295,24 @@
 
 prompt1	db	'-'		;main prompt
 prompt2	db	':'		;prompt for register value
-%if PM
+if PM eq 1
 prompt3	db	'#'		;protected-mode prompt
-%endif
+endif
 
 helpmsg	db	DOSNAME, ' ', DBGNAME2, ' v1.13 help screen',CR,LF
 	db	'assemble',9,	'A [address]',CR,LF
 	db	'compare',9,9,	'C range address',CR,LF
 	db	'dump',9,9,		'D [range]',CR,LF
-%if PM    
+if PM eq 1
 	db	'dump interrupt',9,'DI interrupt [count]',CR,LF
 	db	'dump LDT',9,	'DL selector [count]',CR,LF
-%endif    
-%if MCB
+endif    
+if MCB
 	db	'dump MCB chain',9,'DM',CR,LF
-%endif
-%if PM    
+endif
+if PM eq 1
 	db	'dump ext memory',9,'DX physical_address',CR,LF
-%endif
+endif
 	db	'enter',9,9,	'E address [list]',CR,LF
 	db	'fill',9,9,		'F range list',CR,LF
 	db	'go',9,9,		'G [=address] [breakpts]',CR,LF
@@ -335,27 +328,28 @@
 	db	'proceed',9,9,	'P [=address] [count]',CR,LF
 	db	'quit',9,9,		'Q',CR,LF
 	db	'register',9,	'R [register [value]]',CR,LF
-%if PM
+if PM eq 1
     db  '$'
 helpmsg2:    
-%endif
+endif
     db  'FPU register',9,'RN',CR,LF
     db  'toggle 386 regs',9,'RX',CR,LF
 	db	'search',9,9,	'S range list',CR,LF
-%if PM==0
+;if PM==0
+if PM eq 0
     db  '$'
 helpmsg2:    
-%endif
+endif
 	db	'trace',9,9,	'T [=address] [count]',CR,LF
 	db	'trace mode',9,	'TM [0|1]',CR,LF
 	db	'unassemble',9,	'U [range]',CR,LF
 	db	'write program',9,'W [address]',CR,LF
 	db	'write sectors',9,'W address drive sector count',CR,LF
 	db	'expanded mem',9,'XA/XD/XM/XR/XS,X? for help'
-%if PM    
+if PM eq 1
     db   CR,LF,CR,LF
 	db  "prompts: '-' = real/v86-mode; '#' = protected-mode"
-%endif    
+endif    
 crlf	db	CR,LF,'$'
 
 presskey db '[more]$'
@@ -409,33 +403,33 @@
 int1msg	db	'Unexpected single-step interrupt',CR,LF,'$'
 int3msg	db	'Unexpected breakpoint interrupt',CR,LF,'$'
 
-%if PM
-%if 0
+if PM eq 1
+if 0
 exc6msg	db	'Invalid opcode fault',CR,LF,'$'
-%endif
-%if 1
+endif
+if 1
 excCmsg	db	'Stack fault',CR,LF,'$'
-%endif
+endif
 excDmsg	db	'General protection fault',CR,LF,'$'
-%if EXCCSIP
+if EXCCSIP
 excloc	db	'CS:IP='
 exccsip db '    :    '
 		db  CR,LF,'$'
-%endif        
+endif        
 excEmsg	db	'Page fault.',CR,LF,'$'
 nodosext db 'Command not supported in protected-mode without a DOS-Extender',CR,LF,'$'
 nopmsupp db 'Command not supported in protected-mode',CR,LF,'$'
-%if DISPHOOK
+if DISPHOOK
 dpmihook db 'DPMI entry hooked, new entry='
 dpmihookcsip db '    :    ',CR,LF,'$'
-%endif
-%if DOSEMU
+endif
+if DOSEMU
 dDosEmuDate db "02/25/93"
-%endif
+endif
 nodesc	db 'resource not accessible in real-mode',CR,LF,'$'
 ;descwrong db 'descriptor not accessible',CR,LF,'$'
 gatewrong db 'gate not accessible',CR,LF,'$'
-%endif
+endif
 cantwritebp db "Can't write breakpoint",CR,LF,'$'
 
 progtrm	db	CR,LF,'Program terminated normally ('
@@ -461,8 +455,9 @@
 emserr9	db	'Parameter error',CR,LF,'$'
 emserra	db	'Logical page out of range',CR,LF,'$'
 emserrb	db	'Physical page out of range',CR,LF,'$'
-emserrs	dw	emserr1,emserr1,0,emserr3,0,emserr5,0,emserr7,emserr8,emserr9
-	dw	emserra,emserrb
+emserrs	dw	offset emserr1,offset emserr1,0,offset emserr3,0,offset emserr5,0
+        dw      offset emserr7,offset emserr8,offset emserr9
+	dw	offset emserra,offset emserrb
 emserrx	db	'EMS error '
 emserrxa db	'__',CR,LF,'$'
 xaans	db	'Handle created = '
@@ -553,11 +548,11 @@
 replist	db	06ch,06eh,0a4h,0aah,0ach	;REP
 		db	0a6h,0aeh					;REPE/REPNE
 
-	%include "debugtbl.inc"
+	include debugtbl.inc
 
-%if PM
+if PM eq 1
 
-	%include "fptostr.inc"
+	include fptostr.inc
 
 dpmientry dd 0	;dpmi entry point returned by dpmi host
 dpmiwatch dd 0	;
@@ -571,23 +566,23 @@
 
 exctab:
 	db 0
-    dw exc00, exc0032
+    dw offset exc00, offset exc0032
 	db 1
-    dw exc01, exc0132
+    dw offset exc01, offset exc0132
 	db 3
-    dw exc03, exc0332
-%if 0
+    dw offset exc03, offset exc0332
+if 0
 	db 06h
-    dw exc06, exc0632
-%endif
-%if 1
+    dw offset exc06, offset exc0632
+endif
+if 1
 	db 0Ch
-    dw exc0c, exc0c32
-%endif
+    dw offset exc0c, offset exc0c32
+endif
 	db 0Dh
-    dw exc0d, exc0d32
+    dw offset exc0d, offset exc0d32
 	db 0Eh
-    dw exc0e, exc0e32
+    dw offset exc0e, offset exc0e32
     db -1
 
 ;--- int 2F handler
@@ -598,31 +593,30 @@
 dpmidisable:		;set [IP+1]=0 if hook 2F is to be disabled    
     jz dpmiquery
     popf
-    jmp far [cs:oldi2f]
+    ;jmp far [cs:oldi2f]
+    jmp dword ptr [cs:oldi2f]
 dpmiquery:
-	call far [cs:oldi2f]
+	;call far [cs:oldi2f]
+	call dword ptr [cs:oldi2f]
     and ax,ax
     jnz nodpmi
-	mov [cs:dpmientry+0],di
-	mov [cs:dpmientry+2],es
-    mov di,mydpmientry
+	mov word ptr[cs:dpmientry+0],di
+	mov word ptr [cs:dpmientry+2],es
+    mov di, offset mydpmientry
     push cs
     pop es
 nodpmi:    
 	iret
 mydpmientry:
 	mov [cs:dpmi32],al
-	call far [cs:dpmientry]
+	;call far [cs:dpmientry]
+	call dword ptr [cs:dpmientry]
     jc dpmifailed
     call installdpmi
 dpmifailed:
     retf
 
-%if NASM
-	cpu 286
-%else    
-	cpu 286 protected
-%endif
+.286p
 
 ;--- inp: [sp+4] = client real-mode CS
     
@@ -648,13 +642,13 @@
     mov [scratchsel],ax	;the first is used as scratch descriptor
     mov bx,ax
     xor cx,cx
-%if 1
-	cmp byte [machine],3	;is at least a 80386?
+if 1
+	cmp byte ptr [machine],3	;is at least a 80386?
     jb instdpmi_1
-%else
-    cmp byte [dpmi32],0		;is a 16-bit client?
+else
+    cmp byte ptr [dpmi32],0		;is a 16-bit client?
     jz instdpmi_1
-%endif    
+endif    
     dec cx			;set a limit of FFFFFFFFh
 instdpmi_1:
     or dx,-1
@@ -672,7 +666,7 @@
     mov ax,0009h
     int 31h
     mov [bp+20],bx
-%if 1
+if 1
     mov bx,[run_cs]	;convert saved (by G) CS segment
     and bx,bx
     jz norun_cssegm
@@ -681,20 +675,20 @@
     jc  fataldpmierr
     mov [run_cs],ax
 norun_cssegm:
-%endif
-    mov bx,word [pInDOS+2]
+endif
+    mov bx,word ptr [pInDOS+2]
     mov ax,0002h	;convert the INDOS segment 
     int 31h
     jc  fataldpmierr
-    mov word [pInDOS+2],ax
-%if USESDA
-    mov bx,word [pSDA+2]
+    mov word ptr [pInDOS+2],ax
+if USESDA
+    mov bx,word ptr [pSDA+2]
     mov ax,0002h	;convert the SDA segment
     int 31h
     jc  fataldpmierr
-    mov word [pSDA+2],ax
-%endif
-%if 0    
+    mov word ptr [pSDA+2],ax
+endif
+if 0    
     mov bx,[d_addr+4]	;convert the disassemblers's current address
     and bx,bx
     jz  nodsegm
@@ -703,8 +697,8 @@
     jc  fataldpmierr
     mov [d_addr+4],ax
 nodsegm:    
-%endif
-%if 1
+endif
+if 1
     mov bx,[a_addr+4]	;convert the assembler's current address
     and bx,bx
     jz  noasegm
@@ -713,8 +707,8 @@
     jc  fataldpmierr
     mov [a_addr+4],ax
 noasegm:
-%endif
-	mov si,exctab		;hook several exceptions
+endif
+	mov si, offset exctab		;hook several exceptions
     cld
 next_exc:    
     lodsb
@@ -725,15 +719,19 @@
     mov dx,ax
     lodsw
     mov cx,cs
-    cmp byte [dpmi32],0
+    cmp byte ptr [dpmi32],0
     jz is16
-    cpu 386
+    ;cpu 386
+;.386
+.386;
     push edx
     movzx edx,ax
     mov ax,0203h
     int 31h
     pop edx
-    cpu 286
+    ;cpu 286
+;.286
+.286p
     jmp next_exc
 is16:
     mov ax,0203h
@@ -745,9 +743,9 @@
     int 31h
     cmp cx,[pspdbg]		;did we hook it and are the last in chain?
     jnz int2fnotours
-    mov dx,[oldi2f+0]
+    mov dx,word ptr [oldi2f+0]
     xor cx,cx
-    xchg cx,[oldi2f+2]	;then unhook
+    xchg cx,word ptr [oldi2f+2]	;then unhook
     mov ax,201h
     int 31h
 int2fnotours:    
@@ -778,29 +776,29 @@
 fr16_ss equ 32
 
 exc00:
-	push int0msg
+	push offset int0msg
     jmp exc_xx
 exc01:
-	push int1msg
+	push offset int1msg
     jmp exc_xx
 exc03:
-	push int3msg
+	push offset int3msg
     jmp exc_xx
-%if 0
+if 0
 exc06:
-	push exc6msg
+	push offset exc6msg
     jmp exc_xx
-%endif    
-%if 1    
+endif    
+if 1    
 exc0c:
-	push excCmsg
+	push offset excCmsg
     jmp exc_xx
-%endif    
+endif    
 exc0d:
-	push excDmsg
+	push offset excDmsg
     jmp exc_xx
 exc0e:
-	push excEmsg
+	push offset excEmsg
 exc_xx:    
     pusha
     mov bp,sp
@@ -814,30 +812,32 @@
     mov [bp + fr16_cs], cs
     mov [bp + fr16_ss], ds
     mov di,[bp+fr16_exc]
-	mov	word [run_int],di
-    cmp [bInDbg],byte 0	;did the exception occur inside DEBUG?
+    mov	word ptr [run_int],di
+    cmp [bInDbg], byte ptr 0	;did the exception occur inside DEBUG?
     jz isdebuggee16
     push ds
     pop es
-%if EXCCSIP
-    mov di,exccsip		;render CS:IP if internal GPF
+if EXCCSIP
+    mov di,offset exccsip		;render CS:IP if internal GPF
     mov ax,bx
     call hexword
     inc di
     mov ax,[bp + fr16_ip]
     call hexword
 
-%endif    
-    mov word [bp + fr16_ip],tt2x
+endif    
+    mov word ptr [bp + fr16_ip], offset tt2x
     mov ax,[savesp]
     mov [bp + fr16_sp], ax
-    and byte [bp + fr16_fl+1], ~1	;reset TF
+    ;and byte ptr [bp + fr16_fl+1], ~1	;reset TF
+    and byte ptr [bp + fr16_fl+1], not 1 ;reset TF
     pop ax
     jmp isdebugger16
 isdebuggee16:
-    mov word [bp + fr16_ip], intrtn2
-    and byte [bp + fr16_fl+1], ~3	;reset IF + TF
-    mov word [bp + fr16_sp], reg_ss
+    mov word ptr [bp + fr16_ip], offset intrtn2
+    ;and byte ptr [bp + fr16_fl+1], ~3	;reset IF + TF
+    and byte ptr [bp + fr16_fl+1], not 3 ;reset IF + TF
+    mov word ptr [bp + fr16_sp], offset reg_ss
     mov [reg_ip],ax
     mov [reg_cs],bx
     mov [reg_fl],cx
@@ -851,7 +851,9 @@
     add sp,2
     retf
 
-	cpu 386
+	;cpu 386
+;.386
+.386p
 
 fr32_exc equ 16*2
 fr32_eip equ 24*2
@@ -861,29 +863,29 @@
 fr32_ss  equ 32*2
     
 exc0032:
-	push dword int0msg
+	push dword ptr offset int0msg
     jmp exc32_xx
 exc0132:
-	push dword int1msg
+	push dword ptr offset int1msg
     jmp exc32_xx
 exc0332:
-	push dword int3msg
+	push dword ptr offset int3msg
     jmp exc32_xx
-%if 0
+if 0
 exc0632:
-	push dword exc6msg
+	push dword ptr offset exc6msg
     jmp exc32_xx
-%endif    
-%if 1    
+endif    
+if 1    
 exc0c32:
-	push dword excCmsg
+	push dword ptr offset excCmsg
     jmp exc32_xx
-%endif    
+endif    
 exc0d32:
-	push dword excDmsg
+	push dword ptr offset excDmsg
     jmp exc32_xx
 exc0e32:
-	push dword excEmsg
+	push dword ptr offset excEmsg
 exc32_xx:
     pushad
     mov ebp,esp
@@ -897,29 +899,31 @@
     mov [ebp + fr32_cs], cs
     mov [ebp + fr32_ss], ds
     mov di,[ebp + fr32_exc]
-	mov	word [run_int],di
-    cmp [bInDbg],byte 0	;did the exception occur inside DEBUG?
+    mov	word ptr [run_int],di
+    cmp [bInDbg], byte ptr 0	;did the exception occur inside DEBUG?
     jz isdebuggee32
     push ds
     pop es
-%if EXCCSIP
-    mov di,exccsip
+if EXCCSIP
+    mov di,offset exccsip
     mov ax,bx
     call hexword
     inc di
     mov ax,[ebp + fr32_eip]
     call hexword
-%endif    
-    mov dword [ebp + fr32_eip],tt2x
-    movzx eax,word [savesp]
+endif    
+    mov dword ptr [ebp + fr32_eip], offset tt2x
+    movzx eax, word ptr [savesp]
     mov [ebp + fr32_esp], eax
-    and byte [ebp+fr32_efl+1], ~1	;reset TF
+    ;and byte ptr [ebp+fr32_efl+1], ~1	;reset TF
+    and byte ptr [ebp+fr32_efl+1], not 1	;reset TF
     pop ax
     jmp isdebugger32
 isdebuggee32:
-    mov dword [ebp + fr32_eip], intrtn2
-    and byte  [ebp + fr32_efl+1], ~3;reset IF + TF
-    mov dword [ebp + fr32_esp], reg_ss
+    mov dword ptr [ebp + fr32_eip], offset intrtn2
+    ;and byte  ptr [ebp + fr32_efl+1], ~3;reset IF + TF
+    and byte  ptr [ebp + fr32_efl+1], not 3;reset IF + TF
+    mov dword ptr [ebp + fr32_esp], offset reg_ss
     mov [reg_ip],ax
     mov [reg_cs],bx
     mov [reg_fl],cx
@@ -949,23 +953,24 @@
     ret
 
 myi23:
-	cmp [cs:dpmi32],byte 0
+	cmp [cs:dpmi32],byte ptr 0
     jz doretf2
     db 66h
     retf 4
 doretf2:
 	retf 2
 myi24:
-	cmp [cs:dpmi32],byte 0
+	cmp [cs:dpmi32],byte ptr 0
     jz doiret16
 	db 66h
 doiret16:
 	iret
     
 
-	cpu 8086
+	;cpu 8086
+.8086    
     
-%endif	;PM
+endif	;PM
 
 ;	debug22 - INT 22 (Program terminate) interrupt handler.
 ;	This is for DEBUG itself:  it's a catch-all for the various INT 23
@@ -986,20 +991,22 @@
 
 cmd3:
 	mov	sp,[savesp]	;restore stack (this must be first)
-	mov	word [errret],cmd3
+	mov	word ptr [errret],offset cmd3
     push ds
     pop es
     call isdebuggeeloaded
     jnz taskok
     call createdummytask	;if no task is active, create a dummy one
 taskok:
-	mov	dx,prompt1
-%if PM    
+	;mov	dx,prompt1
+	mov	dx, offset prompt1
+if PM eq 1
     call ispm
     jnz cmd3_1
-    mov dx,prompt3
+    ;mov dx,prompt3
+    mov dx, offset prompt3
 cmd3_1:
-%endif
+endif
 	mov	cx,1
 	call getline	;prompted input
 	cmp	al,CR
@@ -1021,7 +1028,8 @@
 	call skipcomma
 	shl	bx,1
     mov dx,[cmdlist+bx]
-    mov word [lastcmd],dmycmd
+    ;mov word ptr [lastcmd],dmycmd
+    mov word ptr [lastcmd], offset dmycmd
 cmd4:    
 	mov	di,line_out
 	call dx
@@ -1031,7 +1039,7 @@
 	ret
 
 waitkey:
-	cmp byte [notatty],0
+	cmp byte ptr [notatty],0
     jnz nowait
 	mov bx,1
     mov ax,4400h	;is stdout a device?
@@ -1041,10 +1049,11 @@
 	push es
     mov ax,40h		;0040h is a bimodal segment/selector
     mov es,ax
-    cmp byte [es:84h],30
+    cmp byte ptr [es:84h],30
 	pop es
     jnc nowait
-    mov dx,presskey
+    ;mov dx,presskey
+    mov dx, offset presskey
 	call int21ah9	;print string
     mov ah,8
     int 21h
@@ -1055,10 +1064,12 @@
     ret
 
 help:
-	mov	dx,helpmsg
+	;mov	dx,helpmsg
+	mov	dx, offset helpmsg
 	call int21ah9	;print string
     call waitkey
-	mov	dx,helpmsg2
+	;mov	dx,helpmsg2
+	mov	dx,offset helpmsg2
 prnquit:
 	call int21ah9	;print string
 	jmp	cmd3		;done
@@ -1120,7 +1131,7 @@
 obsmach		db	1,1,2,4,4	;max permissible machine for the above
 
 aadbsiz		db	0,4,2,1		;table for max size of db operand
-aadbsto		dw	0,aa28,aa29,aa30;table for routine to store a number
+aadbsto		dw	0,offset aa28,offset aa29,offset aa30;table for routine to store a number
 
 modrmtab	db	11,0,13,0,15,0,14,0	;[bx], [bp], [di], [si]
 		db	15,13,14,13,15,11,14,11	;[bp+di],[bp+si],[bx+di],[bx+si]
@@ -1182,19 +1193,19 @@
 ;	Jump table for operand types.
 
 asm_jmp1:	
-		dw	ao04,ao01,ao01,ao01	;OP_IMM, OP_RM, OP_M, OP_R_MOD
-		dw	ao05,ao02,ao03,ao06	;OP_MOFFS, OP_R, OP_R_ADD, OP_AX
+		dw	offset ao04,offset ao01,offset ao01,offset ao01	;OP_IMM, OP_RM, OP_M, OP_R_MOD
+		dw	offset ao05,offset ao02,offset ao03,offset ao06	;OP_MOFFS, OP_R, OP_R_ADD, OP_AX
 
-		dw	ao17,ao17,ao17		;OP_M64, OP_MFLOAT, OP_MDOUBLE
-		dw	ao17,ao17,ao17		;OP_M80, OP_MXX, OP_FARMEM
-		dw	ao21,ao23,ao25		;OP_FARP, OP_REL8, OP_REL1632
-		dw	ao29,ao30,ao31		;OP_1CHK, OP_STI, OP_CR
-		dw	ao34,ao35,ao39		;OP_DR, OP_TR, OP_SEGREG
-		dw	ao41,ao42,ao43m		;OP_IMMS8, OP_IMM8, OP_ECX
-		dw	ao44,ao46,ao47		;OP_SHOSIZ, OP_1, OP_3
-		dw	ao48,ao48,ao48		;OP_DX, OP_CL, OP_ST
-		dw	ao48,ao48,ao48		;OP_CS, OP_DS, OP_ES
-		dw	ao48,ao48,ao48		;OP_FS, OP_GS, OP_SS
+		dw	offset ao17,offset ao17,offset ao17		;OP_M64, OP_MFLOAT, OP_MDOUBLE
+		dw	offset ao17,offset ao17,offset ao17		;OP_M80, OP_MXX, OP_FARMEM
+		dw	offset ao21,offset ao23,offset ao25		;OP_FARP, OP_REL8, OP_REL1632
+		dw	offset ao29,offset ao30,offset ao31		;OP_1CHK, OP_STI, OP_CR
+		dw	offset ao34,offset ao35,offset ao39		;OP_DR, OP_TR, OP_SEGREG
+		dw	offset ao41,offset ao42,offset ao43m		;OP_IMMS8, OP_IMM8, OP_ECX
+		dw	offset ao44,offset ao46,offset ao47		;OP_SHOSIZ, OP_1, OP_3
+		dw	offset ao48,offset ao48,offset ao48		;OP_DX, OP_CL, OP_ST
+		dw	offset ao48,offset ao48,offset ao48		;OP_CS, OP_DS, OP_ES
+		dw	offset ao48,offset ao48,offset ao48		;OP_FS, OP_GS, OP_SS
 
 ;--- special ops DX, CL, ST, CS, DS, ES, FS, GS, SS, MMX
 ;--- entry required if ao48 is set above
@@ -1208,7 +1219,8 @@
 aa00:
 	jmp	cmd3		;done with this command
 
-aa:	mov	word [errret],aa01
+;aa:	mov	word ptr [errret],aa01
+aa:	mov	word ptr [errret], offset aa01
 	cmp	al,CR
 	je	aa01		;if end of line
 	mov	bx,[reg_cs]	;default segment to use
@@ -1216,14 +1228,16 @@
 	call getaddr	;get address into bx:(e)dx
 	call chkeol		;expect end of line here
 	mov	[a_addr],dx	;save the address
-%if PM    
-    cmp byte [machine],3
+if PM eq 1
+    cmp byte ptr [machine],3
     jb aa00_1
-    cpu 386
-    mov [a_addr],edx
-    cpu 8086
+    ;cpu 386
+.386p
+    mov dword ptr [a_addr],edx
+    ;cpu 8086
+.8086
 aa00_1:
-%endif
+endif
 	mov	[a_addr+4],bx
 
 ;	Begin loop over input lines.
@@ -1235,11 +1249,11 @@
 	call hexword
 	mov	al,':'
 	stosb
-	mov	byte [asm_mn_flags],0
-%if PM    
+	mov	byte ptr [asm_mn_flags],0
+if PM eq 1    
 	call ispm
     jnz aa01_1
-    cmp byte [machine],3
+    cmp byte ptr [machine],3
     jb aa01_1
     mov bx,[a_addr+4]
     call getattrhigh	;set Z flag
@@ -1249,7 +1263,7 @@
 	call hexword
 ;	mov	byte [asm_mn_flags],AMF_D32
 aa01_1:   
-%endif
+endif
 	mov	ax,[a_addr+0]
 	call hexword
 	mov	al,' '
@@ -1259,7 +1273,7 @@
 	je	aa00		;if done
 	cmp	al,';'
 	je	aa01		;if comment
-	mov	word [aa_saved_prefix],0 ;clear aa_saved_prefix and aa_seg_pre
+	mov	word ptr [aa_saved_prefix],0 ;clear aa_saved_prefix and aa_seg_pre
 
 ;	Get mnemonic and look it up.
 
@@ -1282,15 +1296,15 @@
 	cmp	al,TAB
 	jne	aa03
 aa05:
-	or byte [di-1],80h	;set highest bit of last char of mnemonic
+	or byte ptr [di-1],80h	;set highest bit of last char of mnemonic
 	call skipwh0	;skip to next field
 	dec	si
 	push si			;save position in input line
 	mov	al,0
 	stosb
-	mov	si,mnlist
+	mov	si, offset mnlist
 aa06:               ;<--- next mnemonic
-	cmp si,end_mnlist
+	cmp si, offset end_mnlist
     jnc aa13		;if end of table reached
     mov bx,si
 	add si,2
@@ -1318,7 +1332,7 @@
 
 aa14:
 	mov si,[bx]		;get the offset into asmtab
-	add	si,asmtab
+	add si, offset asmtab
 
 ;	Now si points to the spot in asmtab corresponding to this mnemonic.
 ;	The format of the assembler table is as follows.
@@ -1384,7 +1398,7 @@
 ASM_MACH6		equ	0f3h
 ASM_MACH0		equ	0edh
 
-	cmp	byte [si],ASM_LOCKREP	;check for mnemonic flag byte
+	cmp	byte ptr [si],ASM_LOCKREP	;check for mnemonic flag byte
 	jb	aa15					;if none
 	lodsb						;get the prefix
 	sub	al,ASM_LOCKREP			;convert to 0-9
@@ -1402,7 +1416,7 @@
 aa15:
 	jmp	ab01			  		;now process the arguments
 aa15_1:
-	or	byte [asm_mn_flags],AMF_D16
+	or	byte ptr [asm_mn_flags],AMF_D16
     inc si						;skip the ASM_D32 byte
 	jmp	ab01			  		;now process the arguments
 
@@ -1414,7 +1428,7 @@
 aa17:
 	lodsb			;get prefix value
 	mov	[aa_seg_pre],al
-	or	byte [asm_mn_flags],AMF_MSEG
+	or	byte ptr [asm_mn_flags],AMF_MSEG
 	pop	si
 	pop	ax
 	lodsb
@@ -1449,7 +1463,7 @@
 ;	Pseudo ops (org or db/dw/dd).
 
 aa20:
-	cmp	word [aa_saved_prefix],0
+	cmp	word ptr [aa_saved_prefix],0
 	jnz	aa13a		;if there was a prefix or a segment
 	pop	si			;get position in input line
 	sub	al,3		;AX=0 if org, 1 if dd, 2 if dw, 3 if db.
@@ -1558,7 +1572,8 @@
 	cmp	al,';'
 	jne	ab01b		;if not end of line
 ab00a:
-	mov	si,aam_args	;fake a 0ah argument
+	;mov	si,aam_args	;fake a 0ah argument
+	mov	si,offset aam_args	;fake a 0ah argument
 	jmp	ab01a
 
 ;	Process normal instructions.
@@ -1614,10 +1629,10 @@
 	dec	si
 	mov	ax,[si]
 	and	ax,TOUPPER_W
-	cmp	byte [di+2],0
+	cmp	byte ptr [di+2],0
 	jne	ab07		;if already have a size qualifier ("BYTE PTR",...)
 	push di
-	mov	di,sizetcnam
+	mov	di,offset sizetcnam
 	mov	cx,12
 	repne scasw
 	pop	di
@@ -1636,32 +1651,32 @@
 ;	call skipwh0
 	mov	ah,[si]
 	and	ax,TOUPPER_W
-%if 0
-	cmp	ax,'FA'
+if 0
+	cmp	ax,'AF'
 	jne	ab06a		;if not 'FA'
 	mov	al,[si+1]
 	and	al,TOUPPER
 	cmp	al,'R'
 	jne	ab05		;if not 'FAR'
-	mov	byte [di+2],12	;set 'FAR'
-	or	byte [asm_mn_flags],AMF_D32
+	mov	byte ptr [di+2],12	;set 'FAR'
+	or	byte ptr [asm_mn_flags],AMF_D32
 	call skipalpha
 ;	call skipwh0
 	mov	ah,[si]
 	and	ax,TOUPPER_W
-%endif    
+endif    
 ab06a:
-	cmp	ax,'PT'
+	cmp	ax,'TP'
 	jne	ab05		;if not 'PTR'
 	call skipalpha
 ;	call skipwh0
 	jmp	ab05
 
 ab07:
-	cmp	byte [aa_seg_pre],0
+	cmp	byte ptr [aa_seg_pre],0
 	jne	ab09		;if we already have a segment prefix
 	push di
-	mov	di,segrgnam
+	mov	di, offset segrgnam
 	mov	cx,6
 	repne scasw
 	pop	di
@@ -1673,7 +1688,8 @@
 	jne	ab08		;if not followed by ':'
 	pop	ax			;discard saved si
 	call skipwhite	;skip it
-	mov	bx,prefixlist + 5
+	;mov	bx,prefixlist + 5
+	mov	bx,offset prefixlist + 5
 	sub	bx,cx
 	mov	al,[bx]		;look up the prefix byte
 	mov	[aa_seg_pre],al	;save it away
@@ -1686,12 +1702,12 @@
 
 ab09:
 	push di			;check for solo registers
-	mov	di,rgnam816
+	mov	di,offset rgnam816
 	mov	cx,27
 	call aagetreg
 	pop	di
 	jc	ab14		;if not a register
-	or	byte [di],ARG_JUSTREG
+	or	byte ptr [di],ARG_JUSTREG
 	mov	[di+4],bl	;save register number
 	cmp	bl,24
 	jae	ab09a		;if it's not a normal register
@@ -1703,18 +1719,18 @@
 	jmp	ab13
 
 ab09a:
-	xor	byte [di],ARG_JUSTREG + ARG_WEIRDREG
+	xor	byte ptr [di],ARG_JUSTREG + ARG_WEIRDREG
 	mov	al,2		;register size
 	cmp	bl,30
 	ja	ab11		;if it's CR, DR, TR, or MM
 	je	ab09b		;if it's ST
 	cmp	bl,28
 	jb	ab13		;if it's a normal segment register
-	or	byte [asm_mn_flags],AMF_FSGS	;flag it
+	or	byte ptr [asm_mn_flags],AMF_FSGS	;flag it
 	jmp	ab13
 
 ab09b:
-	cmp	byte [si],'('
+	cmp	byte ptr [si],'('
 	jne	ab12		;if just plain ST
 	lodsb
 	lodsb
@@ -1770,7 +1786,7 @@
 	mov	[di+5],cx
 	mov	[di+8],bx
 	mov	[di+10],dx
-	or	byte [di],ARG_FARADDR
+	or	byte ptr [di],ARG_FARADDR
 	jmp	ab43		;done with this operand
 
 ;	Check for [...].
@@ -1783,7 +1799,7 @@
 ab17:
 	cmp	al,'['		;begin loop over sets of []
 	jne	ab15		;if not [
-	or	byte [di],ARG_DEREF ;set the flag
+	or	byte ptr [di],ARG_DEREF ;set the flag
 ab18:
 	call skipwhite
 ab19:
@@ -1794,7 +1810,7 @@
 
 	dec	si
 	push di
-	mov	di,rgnam16
+	mov	di,offset rgnam16
 	mov	cx,8
 	call aagetreg
 	pop	di
@@ -1804,7 +1820,7 @@
 	add	bl,8		;adjust 0..7 to 8..15
 	jmp	ab21
 ab20:
-	cmp	byte [di+5],0
+	cmp	byte ptr [di+5],0
 	jnz	ab21		;if we already have an index
 	call skipwhite
 	dec	si
@@ -1818,14 +1834,14 @@
 	jmp	ab28		;ready for next part
 
 ab21:
-	cmp	byte [di+4],0
+	cmp	byte ptr [di+4],0
 	jne	ab22		;if there's already a register
-	mov	byte [di+4],bl
+	mov	byte ptr [di+4],bl
 	jmp	ab23
 ab22:
-	cmp	byte [di+5],0
+	cmp	byte ptr [di+5],0
 	jne	ab24		;if too many registers
-	mov	byte [di+5],bl
+	mov	byte ptr [di+5],bl
 ab23:
 	call skipwhite
 	jmp	ab28		;ready for next part
@@ -1851,12 +1867,12 @@
 	call skipwhite
 	dec	si
 	push di
-	mov	di,rgnam16
+	mov	di,offset rgnam16
 	xor	cx,cx
 	call aagetreg
 	pop	di
 	jc	ab24		;if error
-	cmp	byte [di+5],0
+	cmp	byte ptr [di+5],0
 	jne	ab24		;if there is already a register
 	mov	[di+5],bl
 	call skipwhite
@@ -1875,25 +1891,25 @@
 ;	Post-processing for complicated arguments.
 
 ab30:
-	cmp	word [di+4],0
+	cmp	word ptr [di+4],0
 	jnz	ab32		;if registers were given ( ==> create MOD R/M)
-	cmp	byte [di+7],0
+	cmp	byte ptr [di+7],0
 	jz	ab31		;if nothing was given ( ==> error)
-	cmp	byte [di],0
+	cmp	byte ptr [di],0
 	jnz	ab30b		;if it was not immediate
-	or	byte [di],ARG_IMMED
+	or	byte ptr [di],ARG_IMMED
 ab30a:
 	jmp	ab43		;done with this argument
 ab30b:
-	or	byte [asm_mn_flags],AMF_ADDR
+	or	byte ptr [asm_mn_flags],AMF_ADDR
 	mov	al,2		;size of the displacement
-	test byte [di+7],4
+	test byte ptr [di+7],4
 	jz	ab30c		;if not 32-bit displacement
 	inc	ax
 	inc	ax
-	or	byte [asm_mn_flags],AMF_A32	;32-bit addressing
+	or	byte ptr [asm_mn_flags],AMF_A32	;32-bit addressing
 ab30c:	
-	mov	byte [di+3],al	;save displacement size
+	mov	byte ptr [di+3],al	;save displacement size
 	jmp	ab30a		;done with this argument
 ab31:	
 	jmp	aa13b		;flag an error
@@ -1902,22 +1918,23 @@
 ;	(For disp-only or register, this will be done later as needed.)
 
 ab32:
-	or	byte [di],ARG_MODRM
+	or	byte ptr [di],ARG_MODRM
 	mov	al,[di+4]
 	or	al,[di+5]
 	test al,16
 	jnz	ab34		;if 32-bit addressing
-	test byte [di+7],4
+	test byte ptr [di+7],4
 	jnz	ab34		;if 32-bit addressing
-;	or byte [asm_mn_flags], AMF_ADDR | AMF_A32
-	or byte [asm_mn_flags], AMF_ADDR
+;	or byte ptr [asm_mn_flags], AMF_ADDR | AMF_A32
+	or byte ptr [asm_mn_flags], AMF_ADDR
 	mov	ax,[di+4]
 	cmp	al,ah
 	ja	ab33		;make sure al >= ah
 	xchg al,ah
 ab33:
 	push di
-	mov	di,modrmtab
+	;mov	di,modrmtab
+	mov	di,offset modrmtab
 	mov	cx,8
 	repne scasw
 	pop	di
@@ -1926,7 +1943,7 @@
 	jmp	ab39		;done (just about)
 
 ab34:	
-	or	byte [asm_mn_flags],AMF_A32	+ AMF_ADDR;32-bit addressing
+	or	byte ptr [asm_mn_flags],AMF_A32	+ AMF_ADDR;32-bit addressing
 	mov	al,[di+4]
 	or	al,[di+6]
 	jnz	ab35		;if we can't optimize [EXX*1] to [EXX]
@@ -1935,7 +1952,7 @@
 	mov	[di+4],ax
 ab35:
 	mov	bx,405h		;max disp = 4 bytes; 5 ==> (non-existent) [bp]
-	cmp	byte [di+5],0
+	cmp	byte ptr [di+5],0
 	jne	ab36		;if there's a SIB
 	mov	cl,[di+4]
 	cmp	cl,16
@@ -1945,7 +1962,7 @@
 	jne	ab39		;if not, then we're done (otherwise do SIB)
 
 ab36:
-	or	byte [asm_mn_flags],AMF_SIB	;form SIB
+	or	byte ptr [asm_mn_flags],AMF_SIB	;form SIB
 	mov	ch,[di+6]	;get SS bits
 	mov	cl,3
 	shl	ch,cl		;shift them halfway into place
@@ -2031,7 +2048,7 @@
 	jmp	aa13b		;error jump
 
 ab99:
-	mov	byte [di],-1;end of parsing phase
+	mov	byte ptr [di],-1;end of parsing phase
 	push si			;save the location of the end of the string
 
 ;	For the next phase, we match the parsed arguments with the set of
@@ -2054,7 +2071,7 @@
 
 ac01:
 	xor	ax,ax		;zero out rmaddr through varflags or a_opcode
-	mov	di,rmaddr
+	mov	di,offset rmaddr
 	mov	cx,7
 	rep	stosw
 	mov	si,[mneminfo]	;address of the next argument variant
@@ -2070,10 +2087,10 @@
 	cmp	al,ASM_LOCKABLE-ASM_MACH0
 	je	ac03		;if ASM_LOCKABLE
 	ja	ac04		;if ASM_END ( ==> error)
-	mov	byte [dismach],al	;save machine type
+	mov	byte ptr [dismach],al	;save machine type
 	jmp	ac02		;back for next byte
 ac03:
-	or	byte [varflags],VAR_LOCKABLE
+	or	byte ptr [varflags],VAR_LOCKABLE
 	jmp	ac02		;back for next byte
 
 ac04:
@@ -2094,12 +2111,12 @@
 	ja	ac05a			;if not coprocessor instruction
 	cmp	al,0d8h
 	jb	ac05a			;ditto
-	or	byte [dmflags],DM_COPR	;flag it as an x87 instruction
+	or	byte ptr [dmflags],DM_COPR	;flag it as an x87 instruction
 	mov	ah,al			;ah = low order byte of opcode
 	lodsb				;get extra byte
 	mov	[regmem],al		;save it in regmem
 	mov	[a_opcode2],ax	;save this for obsolete-instruction detection
-	or	byte [varflags],VAR_MODRM	;flag its presence
+	or	byte ptr [varflags],VAR_MODRM	;flag its presence
 ac05a:
 	mov	[mneminfo],si	;save si back again
 	mov	si,dx
@@ -2113,7 +2130,7 @@
 	lodsb			;get next operand byte
 	cmp	al,0
 	je	ac10		;if end of list
-	cmp	byte [di],-1
+	cmp	byte ptr [di],-1
 	je	ac01		;if too few operands were given
 	cmp	al,OP_SIZE
 	jb	ac07		;if no size needed
@@ -2136,7 +2153,7 @@
 	test al,[di]
 	jz	ac09		;if no required bits are present
 	call cx			;call its specific routine
-	cmp	word [si-1],(OP_1632+OP_R)*256+(OP_1632+OP_R_MOD)
+	cmp	word ptr [si-1],(OP_1632+OP_R)*256+(OP_1632+OP_R_MOD)
 	je	ac06		;(hack) for IMUL instruction
 	add	di,12		;next operand
 	jmp	ac06		;back for more
@@ -2147,7 +2164,7 @@
 ;	End of operand list.
 
 ac10:
-	cmp	byte [di],-1
+	cmp	byte ptr [di],-1
 	jne	ac09		;if too many operands were given
 
 ;	Final check on sizes
@@ -2160,7 +2177,7 @@
 	test al,VAR_SIZ_FORCD
 	jz	ac09		;if the size was not forced ( ==> reject)
 	mov	si,[mneminfo]
-	cmp	byte [si],ASM_END
+	cmp	byte ptr [si],ASM_END
 	je	ac12		;if this is the last one
 ac11:
 	jmp	aa13a		;it was not ==> error (not a retry)
@@ -2173,27 +2190,30 @@
 	jz	ac14		;if no saved prefixes to check
 	cmp	al,0f0h
 	jne	ac13		;if it's a rep prefix
-	test byte [varflags],VAR_LOCKABLE
+	test byte ptr [varflags],VAR_LOCKABLE
 	jz	ac11		;if this variant is not lockable ( ==> error)
 	jmp	ac14		;done
 
 ac13:
 	mov	ax,[a_opcode]	;check if opcode is OK for rep{,z,nz}
-	and	al,~1		;clear low order bit
+	;and	al,~1		;clear low order bit
+	and	ax, not 1	;clear low order bit
 	cmp	ax,0ffh
 	ja	ac11		;if it's not a 1 byte instruction
-	mov	di,replist	;list of instructions that go with rep
+	;mov	di,replist	;list of instructions that go with rep
+	mov	di, offset replist	;list of instructions that go with rep
 	mov	cx,7
 	repne	scasb
 	jnz	ac11		;if it's not among them
 
 ac14:
-	test byte [asm_mn_flags],AMF_MSEG
+	test byte ptr [asm_mn_flags],AMF_MSEG
 	jz	ac15		;if no segment prefix before mnemonic
 	mov	ax,[a_opcode]	;check if opcode allows this
 	cmp	ax,0ffh
 	ja	ac11		;if it's not a 1 byte instruction
-	mov	di,prfxtab
+	;mov	di,prfxtab
+	mov	di, offset prfxtab
 	mov	cx,P_LEN
 	repne	scasb
 	jnz	ac11		;if it's not in the list
@@ -2216,7 +2236,7 @@
 ac16:
 	mov	di,[a_addr]
 	mov	es,[a_addr+4]
-	test byte [asm_mn_flags],AMF_WAIT
+	test byte ptr [asm_mn_flags],AMF_WAIT
 	jz	ac17		;if no wait instruction beforehand
 	mov	al,9bh
 	stosb
@@ -2237,11 +2257,11 @@
     test al,AMF_ADDR
     jz ac19
 	and al,AMF_A32
-%if PM
+if PM eq 1
 	mov ah,[bCSAttr]
     and ah,40h
     or al,ah
-%endif
+endif
     and al,AMF_A32 + 40h
     jz ac19
     cmp al,AMF_A32 + 40h
@@ -2256,8 +2276,9 @@
 
 	mov ah,[asm_mn_flags]
 	mov al,[varflags]
-%if PM    
-    test byte [bCSAttr],40h
+if PM eq 1    
+    ;test byte [bCSAttr],40h
+    test byte ptr [bCSAttr],40h
     jz ac20
     test al, VAR_D16
     jnz ac20_1
@@ -2265,7 +2286,7 @@
     jnz ac20_1
     jmp ac21
 ac20:
-%endif
+endif
     test al,VAR_D32
     jnz ac20_1
     test ah,AMF_D32
@@ -2280,7 +2301,7 @@
 	stosb
 	cmp	al,64h
 	jb	ac22		;if not 64 or 65 (FS or GS)
-	or	byte [asm_mn_flags],AMF_FSGS	;flag it
+	or	byte ptr [asm_mn_flags],AMF_FSGS	;flag it
 
 ;	Now emit the instruction itself.
 
@@ -2291,7 +2312,7 @@
 	jae	ac23		;if 576-...
 	cmp	ax,512
 	jb	ac24		;if regular instruction
-	or	byte [dmflags],DM_COPR	;flag it as an x87 instruction
+	or	byte ptr [dmflags],DM_COPR	;flag it as an x87 instruction
 	and	al,038h		;get register part
 	or	[regmem],al
 	xchg	ax,bx		;mov ax,bx (the low bits of bx are good)
@@ -2322,11 +2343,11 @@
 
 ;	Now store the extra stuff that comes with the instruction.
 
-	mov	ax,word [regmem]
-	test byte [varflags],VAR_MODRM
+	mov	ax,word ptr [regmem]
+	test byte ptr [varflags],VAR_MODRM
 	jz	ac26		;if no mod reg/mem
 	stosb
-	test byte [asm_mn_flags],AMF_SIB
+	test byte ptr [asm_mn_flags],AMF_SIB
 	jz	ac26		;if no SIB
 	dec	di
 	stosw			;store the MOD R/M and SIB, too
@@ -2373,16 +2394,17 @@
 
 ;	Compute machine type.
 
-	cmp	byte [dismach],3
+	cmp	byte ptr [dismach],3
 	jae	ac31		;if we already know a 386 is needed
-	test byte [asm_mn_flags],AMF_D32 | AMF_A32 | AMF_FSGS
+	;test byte ptr [asm_mn_flags], AMF_D32 | AMF_A32 | AMF_FSGS
+	test byte ptr [asm_mn_flags], AMF_D32 or AMF_A32 or AMF_FSGS
 	jnz	ac30		;if 386
-	test byte [varflags],VAR_D32
+	test byte ptr [varflags],VAR_D32
 	jz	ac31		;if not 386
 ac30:
-	mov	byte [dismach],3
+	mov	byte ptr [dismach],3
 ac31:
-	mov	di,a_opcode2+2	;info on this instruction
+	mov	di, offset a_opcode2+2	;info on this instruction
 	call showmach		;get machine message into si, length into cx
 	jcxz ac33			;if no message
 
@@ -2416,7 +2438,7 @@
 ;	push	cs
 ;	pop	ds
 ;	call putsline
-;	mov	byte disflags,0
+;	mov	byte ptr offset disflags,0
 ;	call disasm		;disassemble the new instruction
 ;	jmp	aa01		;back to next input line
 
@@ -2458,7 +2480,7 @@
 ;	OP_MOFFS:  just the memory offset
 
 ao05:
-	test byte [di],ARG_MODRM
+	test byte ptr [di],ARG_MODRM
 	jnz	ao11		;if MOD R/M byte ( ==> reject)
 	mov	[rmaddr],di	;save the pointer
 	jmp	ao07		;go to the size check
@@ -2466,14 +2488,14 @@
 ;	OP_AX:  check for AL/AX/EAX
 
 ao06:
-	test byte [di+4],7
+	test byte ptr [di+4],7
 	jnz	ao11		;if wrong register
 	;jmp ao07		;go to the size check
 
 ;	Size check
 
 ao07:
-	or	byte [varflags],VAR_SIZ_NEED
+	or	byte ptr [varflags],VAR_SIZ_NEED
 	mov	al,[a_reqsize]
 	sub	al,5		;OP_1632 >> 4
 	jl	ao12		;if OP_ALL
@@ -2481,11 +2503,11 @@
 	add	al,-3
 	adc	al,3		;convert 3 --> 4
 ao08:
-	or	byte [varflags],VAR_SIZ_FORCD + VAR_SIZ_NEED
+	or	byte ptr [varflags],VAR_SIZ_FORCD + VAR_SIZ_NEED
 	mov	bl,[di+2]
 	or	bl,bl
 	jz	ao09		;if no size given
-	or	byte [varflags],VAR_SIZ_GIVN
+	or	byte ptr [varflags],VAR_SIZ_GIVN
 	cmp	al,bl
 	jne	ao11		;if sizes conflict
 ao09:
@@ -2507,7 +2529,7 @@
 	cmp	al,1
 	je	ao15		;if byte
 	jb	ao14		;if unknown
-	or	byte [opcode_or],1	;set bit in instruction
+	or	byte ptr [opcode_or],1	;set bit in instruction
 	jmp	ao14		;if size is 16 or 32
 
 ;	OP_1632 - word or dword.
@@ -2519,15 +2541,15 @@
 	je	ao16		;if still unknown
 	cmp	al,2
 	jne	ao15_1		;if word
-	or	byte [varflags],VAR_D16
+	or	byte ptr [varflags],VAR_D16
     jmp ao15
 ao15_1:    
 	cmp	al,4
 	jne	ao11		;if not dword
-	or	byte [varflags],VAR_D32	;set flag
+	or	byte ptr [varflags],VAR_D32	;set flag
 ao15:
 	mov	[opsize],al
-	or	byte [varflags],VAR_SIZ_GIVN
+	or	byte ptr [varflags],VAR_SIZ_GIVN
 ao16:
 	ret
 
@@ -2547,17 +2569,17 @@
 
 ao21:
 	mov	al,2
-%if PM    
-    test byte [bCSAttr],40h
+if PM eq 1    
+    test byte ptr [bCSAttr],40h
     jnz ao21_1
-%endif    
-	cmp	word [di+10],0
+endif    
+	cmp	word ptr [di+10],0
 	jz	ao22		;if 16 bit address
 ao21_1:
-	or	byte [varflags],VAR_D32
+	or	byte ptr [varflags],VAR_D32
 	mov	al,4
 ao22:
-	mov	byte [di+4],2
+	mov	byte ptr [di+4],2
 	mov	[immaddr],di
 	mov	[opsize],al
 ao22a:
@@ -2576,21 +2598,23 @@
 
 ; JxCXZ, LOOPx, LOOPZx and LOOPNZx need a 67h, not a 66h prefix
 
-	test cl,AMF_D32 | AMF_D16
+	;test cl,AMF_D32 | AMF_D16
+	test cl,AMF_D32 or AMF_D16
 	jz	ao23b		;if not JxCXZ, LOOPx
     test cl,AMF_D32
     jz ao23a
     or cl,AMF_A32
 ao23a:
-	and cl,~(AMF_D32 | AMF_D16)
+	;and cl,~(AMF_D32 | AMF_D16)
+	and cl,not (AMF_D32 or AMF_D16)
 	or  cl, AMF_ADDR
     mov [asm_mn_flags],cl
-%if PM
+if PM eq 1
     mov ch,[bCSAttr]
     and ch,40h
-%else
+else
 	mov ch,0
-%endif
+endif
 	and cl,AMF_A32
 	or cl,ch
     jz ao23b
@@ -2611,7 +2635,8 @@
 	jne	ao24		;if too big
 	cmp	ax,dx
 	jne	ao24		;if too big
-	mov	byte [di+4],1	;save the length
+	;mov	byte [di+4],1	;save the length
+	mov	byte ptr [di+4],1	;save the length
 	jmp	ao22a		;save it away
 
 
@@ -2621,7 +2646,7 @@
 	mov	bx,[a_addr+0]
     mov cx,[a_addr+2]
     mov ax,3
-	cmp	word [a_opcode],100h	;???
+	cmp	word ptr [a_opcode],100h	;???
 	jb	ao26
 	inc	ax
 ao26:
@@ -2639,26 +2664,26 @@
 	jmp	ao50		;reject
 
 ao27:
-%if PM
-	test byte [bCSAttr],40h
+if PM eq 1
+	test byte ptr [bCSAttr],40h
     jnz ao27_1
-%endif
+endif
 	or	dx,dx
 	jnz	ao24		;if operand is too big
 	mov	al,2
     jmp ao28
 ao27_1:
 	mov al,4
-	or	byte [varflags],VAR_D32
+	or	byte ptr [varflags],VAR_D32
     mov ah,0
     push ax
     dec ax
-%if PM
-	test byte [bCSAttr],40h
+if PM eq 1
+	test byte ptr [bCSAttr],40h
     jz ao27_2
     dec ax			;no prefix needed
 ao27_2:
-%endif
+endif
     add bx,ax
     adc cx,0
     pop ax
@@ -2693,11 +2718,11 @@
 	cmp	al,4
 	ja	ao24		;if too big
 	jne	ao32		;if not CR4
-	mov	byte [dismach],5	;CR4 is new to the 586
+	mov	byte ptr [dismach],5	;CR4 is new to the 586
 ao32:
 	cmp	al,1
 	jne	ao33
-	cmp	byte [di+12],-1
+	cmp	byte ptr [di+12],-1
 	jne	ao24		;if another arg (can't mov CR1,xx)
 ao33:
 	mov	al,32		;code for CR
@@ -2717,7 +2742,7 @@
 	jb	ao24		;if too small
 	cmp	al,6
 	jae	ao36
-	mov	byte [dismach],4	;TR3-5 are new to the 486
+	mov	byte ptr [dismach],4	;TR3-5 are new to the 486
 ao36:
 	mov	al,34		;code for TR
 
@@ -2729,7 +2754,7 @@
 	shl	bl,cl
 ao38:
 	or	[regmem],bl
-	or	byte [varflags],VAR_MODRM
+	or	byte ptr [varflags],VAR_MODRM
 	cmp	al,[di+4]	;check for the right numbered register
 	je	ao40		;if yes, then return
 ao38a:
@@ -2751,7 +2776,8 @@
 ;	OP_IMMS8 - Sign-extended immediate byte (PUSH xx)
 
 ao41:
-    and byte [varflags],~VAR_SIZ_NEED	;added for v1.09. Ok?
+    ;and byte ptr [varflags],~VAR_SIZ_NEED	;added for v1.09. Ok?
+    and byte ptr [varflags],not VAR_SIZ_NEED	;added for v1.09. Ok?
 	mov	ax,[di+8]
 	mov	cl,7
 	sar	al,cl
@@ -2779,42 +2805,43 @@
 ;   used for LOOPx
 
 ao43m:
-%if 0
-	cmp	byte [di+4],9	;CX
+if 0
+	cmp	byte ptr [di+4],9	;CX
 	je	ao43r			;if CX (do nothing)
-	or	byte [varflags],VAR_D32
+	or	byte ptr [varflags],VAR_D32
 	mov	al,17
 	jmp	ao48a			;require ECX
-%endif    
+endif    
     ret
 
 ;	OP_SHOSIZ - force the user to declare the size of the next operand
 
 ao44:
-	test	byte [varflags],VAR_SIZ_NEED
+	test	byte ptr [varflags],VAR_SIZ_NEED
 	jz	ao45		;if no testing needs to be done
-	test	byte [varflags],VAR_SIZ_GIVN
+	test	byte ptr [varflags],VAR_SIZ_GIVN
 	jz	ao50		;if size was given ( ==> reject)
 ao45:
-	and	byte [varflags],~VAR_SIZ_GIVN	;clear the flag
-	cmp	byte [si],OP_IMM8
+	;and	byte ptr [varflags],~VAR_SIZ_GIVN	;clear the flag
+	and	byte ptr [varflags],not VAR_SIZ_GIVN	;clear the flag
+	cmp	byte ptr [si],OP_IMM8
 	je	ao45a		;if OP_IMM8 is next, then don't set VAR_SIZ_NEED
-	or	byte [varflags],VAR_SIZ_NEED
+	or	byte ptr [varflags],VAR_SIZ_NEED
 ao45a:
-	mov	byte [opsize],0
+	mov	byte ptr [opsize],0
 	pop	ax		;discard return address
 	jmp	ac06		;next operand
 
 ;	OP_1
 
 ao46:
-	cmp	word [di+7],101h
+	cmp	word ptr [di+7],101h
 	jmp	ao49		;test it later
 
 ;	OP_3
 
 ao47:
-	cmp	word [di+7],301h
+	cmp	word ptr [di+7],301h
 	jmp	ao49		;test it later
 
 ;	OP_DX, OP_CL, OP_ST, OP_ES, ..., OP_GS
@@ -2840,9 +2867,9 @@
 ;	AASIZCHK - Check that the size given is 0 or AL.
 
 ao60:
-	cmp	byte [di+2],0
+	cmp	byte ptr [di+2],0
 	je	ao51
-	cmp	byte [di+2],al
+	cmp	byte ptr [di+2],al
 	je	ao51
 	pop	ax		;discard return address
 	jmp	ao50
@@ -2851,16 +2878,16 @@
 ;	Uses	AX
 
 ao90:
-	test byte [di],ARG_JUSTREG
+	test byte ptr [di],ARG_JUSTREG
 	jnz	ao92		;if just register
-	test byte [di],ARG_MODRM
+	test byte ptr [di],ARG_MODRM
 	jz	ao91		;if no precomputed MOD R/M byte
-	mov	ax,word [di+4]	;get the precomputed bytes
+	mov	ax,word ptr [di+4]	;get the precomputed bytes
 	jmp	ao93		;done
 
 ao91:
 	mov	al,6		;convert plain displacement to MOD R/M
-	test byte [asm_mn_flags],AMF_A32
+	test byte ptr [asm_mn_flags],AMF_A32
 	jz	ao93		;if 16 bit addressing
 	dec	ax
 	jmp	ao93		;done
@@ -2871,8 +2898,8 @@
 	or	al,0c0h
 
 ao93:
-	or	word [regmem],ax	;store the MOD R/M and SIB
-	or	byte [varflags],VAR_MODRM	;flag its presence
+	or	word ptr [regmem],ax	;store the MOD R/M and SIB
+	or	byte ptr [varflags],VAR_MODRM	;flag its presence
 	mov	[rmaddr],di	;save a pointer
 	ret			;done
 
@@ -3025,7 +3052,7 @@
 	mov	ah,[si+2]
 	and	ah,TOUPPER
 	push di
-	mov	di,rgnam16
+	mov	di,offset rgnam16
 	push cx
 	mov	cx,8
 	repne scasw
@@ -3061,15 +3088,17 @@
 
 cc:	
 	call parsecm		;parse arguments
-%if PM    
-    cmp byte [cs:bAddr32],0
+if PM eq 1    
+    cmp byte ptr [cs:bAddr32],0
 	jz cc0_1
-    cpu 386
+    ;cpu 386
+.386p
     inc ecx
     jmp cc1
-    cpu 8086
+    ;cpu 8086
+.8086
 cc0_1:
-%endif
+endif
 	inc	cx
 cc1:
 	push ds
@@ -3079,16 +3108,18 @@
 	call dohack	;do the interrupt pointer hack
 	pop	es
 	pop	ds
-%if PM    
-    cmp byte [cs:bAddr32],0
+if PM eq 1    
+    cmp byte ptr [cs:bAddr32],0
     jz cc1_1
     repe cmpsb
     lahf
+.386p
     mov dl,[esi-1]
     mov dh,[es:edi-1]
+.8086
     jmp cc1_2
 cc1_1:    
-%endif    
+endif    
 	repe	cmpsb		;start comparing
 	lahf
 	mov	dl,[si-1]	;save the possibly errant characters
@@ -3110,32 +3141,36 @@
 	push ss
 	pop	es
 	mov	bx,di
-%if PM
-    cmp byte [cs:bAddr32],0
+if PM eq 1
+    cmp byte ptr [cs:bAddr32],0
     jz cc1_3
-    cpu 386
+    ;cpu 386
+.386p
     mov ebx,edi
-    cpu 8086
+    ;cpu 8086
+.8086
 cc1_3:
-%endif
+endif
 	mov	di,line_out
 	mov	ax,ds
 	call hexword
 	mov	al,':'
 	stosb
 	lea	ax,[si-1]
-%if PM
-    cmp byte [cs:bAddr32],0
+if PM eq 1
+    cmp byte ptr [cs:bAddr32],0
     jz cc1_4
-    cpu 386
+    ;cpu 386
+.386p
     lea eax,[esi-1]
     push ax
     shr eax,16
     call hexword
     pop ax
-    cpu 8086
+    ;cpu 8086
+.8086
 cc1_4:    
-%endif
+endif
 	call hexword
 	mov	ax,'  '
 	stosw
@@ -3153,18 +3188,21 @@
 	mov	al,':'
 	stosb
 	lea	ax,[bx-1]
-%if PM
-    cmp byte [cs:bAddr32],0
+if PM eq 1
+    cmp byte ptr [cs:bAddr32],0
     jz cc1_5
-    cpu 386
+    ;cpu 386
+;.386
+.386p
     lea eax,[ebx-1]
     push ax
     shr eax,16
     call hexword
     pop ax
-    cpu 8086
+    ;cpu 8086
+.8086
 cc1_5:    
-%endif
+endif
 	call hexword
 	push ds
 	push ss
@@ -3175,15 +3213,18 @@
 	pop	ds
 	pop	es
 	pop	cx
-%if PM    
-    cmp byte [cs:bAddr32],0
+if PM eq 1    
+    cmp byte ptr [cs:bAddr32],0
     jz cc1_6
-    cpu 386
+    ;cpu 386
+;.386
+.386p
     jecxz cc2
-	cpu 8086    
+    ;cpu 8086
+.8086    
     jmp cc1
 cc1_6:
-%endif
+endif
 	jcxz cc2
 	jmp cc1		;if not done yet
 cc2:
@@ -3193,7 +3234,7 @@
 	pop	es
 	ret
 
-%if PM
+if PM eq 1
 
 descr    db '     base='
 descbase db '         limit='
@@ -3223,11 +3264,7 @@
     ret
 
 descout:    
-%if NASM
-    cpu 286
-%else
-    cpu 286 protected
-%endif    
+.286p
     call skipwhite
     call getword	;get word into DX
 	mov bx,dx
@@ -3244,17 +3281,20 @@
 	mov si,dx		;save count
     call ispm
     jz nextdesc
-	mov dx,nodesc
+	;mov dx,nodesc
+	mov dx,offset nodesc
     jmp int21ah9
 desc_done:
 	ret
 nextdesc:
 	dec si
     js desc_done
-    mov di,descr
+    ;mov di,descr
+    mov di,offset descr
     mov ax,bx
     call hexword
-    mov di,descbase
+    ;mov di,descbase
+    mov di,offset descbase
     call cleardesc
 ;    lar ax,bx
 ;    jnz skipdesc	;tell that this descriptor is invalid
@@ -3266,10 +3306,14 @@
     mov ax,dx
     call hexword
 desc_o1:    
-    mov di, desclim
-    cmp byte [machine],3
+    ;mov di, desclim
+    mov di, offset desclim
+    ;cmp byte [machine],3
+    cmp byte ptr [machine],3
     jb use16desc
-    cpu 386
+    ;cpu 386
+;.386
+.386p
     lsl eax,ebx
     jnz desc_out
     push ax
@@ -3280,18 +3324,16 @@
     lar eax,ebx
     shr eax,8
 desc_o2:    
-    mov di,descattr
+    ;mov di,descattr
+    mov di,offset descattr
     call hexword
 desc_out:    
-    mov dx,descr
+    ;mov dx,descr
+    mov dx,offset descr
     call int21ah9
     add bx,8
     jmp nextdesc
-%if NASM
-    cpu 286
-%else
-    cpu 286 protected
-%endif    
+.286p
 use16desc:
 	lsl ax,bx
     jnz desc_out
@@ -3320,17 +3362,14 @@
     mov si,dx		;save count
 gateout_00:    		;<--- next int/exc
     call dohack
-    mov di,gateno
+    ;mov di,gateno
+    mov di,offset gateno
     mov al,bl
     call hexbyte
     inc di
     call ispm
     jnz gaterm
-%if NASM
-    cpu 286
-%else
-    cpu 286 protected
-%endif
+.286p
     mov ax,204h
     cmp bl,20h
     adc bh,1
@@ -3341,12 +3380,14 @@
     call hexword
     mov al,':'
     stosb
-    cmp byte [dpmi32],0
+    cmp byte ptr [dpmi32],0
     jz gate16
-    cpu 386
+    ;cpu 386
+.386p
     shld eax,edx,16
     call hexword
-    cpu 8086
+    ;cpu 8086
+.8086
 gate16:    
     mov ax,dx
     call hexword
@@ -3359,7 +3400,8 @@
     stosw
 	mov al,'$'
     stosb
-    mov dx,gater
+    ;mov dx,gater
+    mov dx,offset gater
 gate_exit:    
     call unhack
     call int21ah9
@@ -3384,19 +3426,21 @@
     mov bh,1
     jmp gate16
 gatefailed:
-	mov dx,gatewrong
+	;mov dx,gatewrong
+	mov dx,offset gatewrong
     mov si,1
     jmp gate_exit
-%endif
+endif
 
-    cpu 8086
+    ;cpu 8086
+.8086
 
-%if MCB
+if MCB
 mcbout:
     mov di,line_out
-    mov ax,"PS"
+    mov ax,"SP"
     stosw
-    mov ax,"P:"
+    mov ax,":P"
     stosw
     mov ax,[pspdbe]
     call hexword
@@ -3463,31 +3507,34 @@
 setds2si:
 	mov bx,si
 setds2bx:
-%if PM    
+if PM eq 1    
 	call ispm
     jnz sd2s_ex
     mov dx,bx
     call setrmsegm
 sd2s_ex:
-%endif
+endif
     mov ds,bx
 	ret
-%endif
+endif
 
 ;--- DX command. Display extended memory
 
-%if PM
-    cpu 386
+if PM eq 1
+    ;cpu 386
+.386p
 extmem:
-	mov dx,[x_addr+0]
-	mov bx,[x_addr+2]
+	;mov dx,[x_addr+0]
+	mov dx,word ptr [x_addr+0]
+	;mov bx,[x_addr+2]
+	mov bx,word ptr [x_addr+2]
     call skipwhite
     cmp al,CR
     jz extmem_1
 	call getdword	;get linear address into bx:dx
 	call chkeol		;expect end of line here
 extmem_1:
-	mov word [lastcmd],extmem
+	mov word ptr [lastcmd], offset extmem
 	push bx
     push dx
     pop ebp
@@ -3507,7 +3554,7 @@
     stosb
     mov ax,007Fh
     stosw
-    mov ax,line_in+128
+    mov ax,offset line_in+128
     mov bx,[pspdbg]
     movzx ebx,bx
     shl ebx,4
@@ -3529,7 +3576,7 @@
     mov cx,0040h
     mov ah,87h
     jnz extmem_rm
-    push word [cs:pspdbg]
+    push word ptr [cs:pspdbg]
     push 15h
     call intcall
     jmp i15ok
@@ -3537,7 +3584,7 @@
     int 15h
 i15ok:
     jc extmem_exit
-    mov si,line_in+128
+    mov si,offset line_in+128
     mov ch,8h
 nexti15l:    
 	mov di,line_out
@@ -3566,7 +3613,7 @@
     stosb
 	dec cl
     jnz nexti15b
-    mov byte [di-(8*3+1)],'-'	;display a '-' after 8 bytes
+    mov byte ptr [di-(8*3+1)],'-'	;display a '-' after 8 bytes
     add di,16
     push cx
     call putsline
@@ -3577,8 +3624,9 @@
     mov [x_addr],ebp
 extmem_exit:
     ret
-	cpu 8086
-%endif
+	;cpu 8086
+.8086
+endif
 
 ;	D command - hex/ascii dump.
 
@@ -3589,22 +3637,25 @@
 	mov	dx,[d_addr]	;compute range of 80h or until end of segment
 	mov	si,dx
     mov bx,[d_addr+4]
-%if PM    
-    cmp byte [machine],3
+if PM eq 1    
+    cmp byte ptr [machine],3
     jb dd0_1
-    cpu 386
-    mov edx,[d_addr]
+    ;cpu 386
+.386p
+    ;mov edx,[d_addr]
+    mov edx,dword ptr [d_addr]
     mov esi,edx
-    cpu 8086
+    ;cpu 8086
+.8086
 dd0_1:
-%endif
+endif
 	add	dx,7fh
 	jnc	dd2		;if no overflow
 	mov	dx,0ffffh
 	jmp	dd2
 
 dd1:
-%if PM
+if PM eq 1
 	or  al,TOLOWER
     cmp al,'l'
     jnz dd1_0
@@ -3616,17 +3667,17 @@
 dd1_01:   
 	cmp al,'x'
     jnz dd1_02
-    cmp byte [machine],3
+    cmp byte ptr [machine],3
     jb dd1_02
     jmp extmem
 dd1_02:    
-%endif
-%if MCB
+endif
+if MCB
     cmp al,'m'
     jnz dd1_03
     jmp mcbout
 dd1_03:
-%endif
+endif
 	mov	cx,80h		;default length
 	mov	bx,[reg_ds]
 	call getrangeX	;get address range into bx:(e)dx
@@ -3634,14 +3685,16 @@
 
 	mov	[d_addr+4],bx	;save segment (offset is saved later)
 	mov	si,dx
-%if PM    
-    cmp byte [machine],3
+if PM eq 1    
+    cmp byte ptr [machine],3
     jb dd1_1
-    cpu 386
+    ;cpu 386
+.386p
     mov esi,edx
-    cpu 8086
+    ;cpu 8086
+.8086
 dd1_1:
-%endif
+endif
 	mov	dx,cx		;dx = end address
     
     jmp dd2_1
@@ -3649,42 +3702,46 @@
 ;	Parsing is done.  Print first line.
 
 dd2:	
-%if PM
+if PM eq 1
 	call ispm
     jnz dd2_1
-	cpu 286 protected
+	;cpu 286 protected
+.286p
     verr bx
     jz dd2_1
     mov bx,[reg_ds]
     mov [d_addr+4],bx
-	cpu 8086
-%endif
+	;cpu 8086
+.8086
+endif
 dd2_1:	
-	mov word [lastcmd],lastddd
+	mov word ptr [lastcmd],offset lastddd
 	mov	ax,[d_addr+4]
 	call hexword
 	mov	al,':'
 	stosb
 	mov	ax,si
-%if PM    
+if PM eq 1    
 	xor bp,bp
 	call ispm
     jnz dd2_2
 
-    cmp byte [machine],3
+    cmp byte ptr [machine],3
     jb dd2_2
     push ax
     call getattrhigh	;sets Z flag
     pop ax
     jz dd2_2
     inc bp
-    cpu 386
+    ;cpu 386
+.386p
     shld eax,esi,16		;AX=HiWord(esi)
-    cpu 8086
+    ;cpu 8086
+.8086
 	call hexword
     mov ax,si
 dd2_2:    
-%endif
+endif
 
 	and	al,0f0h
 	push ax
@@ -3693,7 +3750,7 @@
 	stosw
 	pop	ax
 	lea	bx,[di+3*16]
-;	mov	byte [bx-1],' '
+;	mov	byte ptr [bx-1],' '
 	call prephack		;set up for faking int vectors 23 and 24
 
 ;--- blank the start of the line if offset isn't para aligned
@@ -3725,12 +3782,12 @@
 	call dohack		;substitute interrupt vectors
 	mov	ds,[d_addr+4]
 dd6:    
-%if PM
+if PM eq 1
 	and bp,bp
     jz dd6_1
     db 67h			;do a lods [esi] 
 dd6_1:
-%endif
+endif
 	lodsb
 dd6_2:    
 	push ax
@@ -3764,15 +3821,18 @@
 	push ss		;restore ds
 	pop	ds
 	mov	[d_addr],si
-%if PM
-    cmp byte [machine],3
+if PM eq 1
+    cmp byte ptr [machine],3
     jb dd10_1
-    cpu 386
-    mov [d_addr],esi
-    cpu 8086
+    ;cpu 386
+.386p
+    ;mov [d_addr],esi
+    mov dword ptr [d_addr],esi
+    ;cpu 8086
+.8086
 dd10_1:    
-%endif    
-	mov	byte [di-25],'-'
+endif    
+	mov	byte ptr [di-25],'-'
 	call unhack
 	mov	di,bx
 	push dx
@@ -3782,7 +3842,7 @@
 	cmp	si,dx
 	jae	dd11		;if we're done
 	inc	si
-%if 0    
+if 0    
 	mov	di,line_out+5	;set up for next time
 	mov	ax,si
 	call hexword
@@ -3790,11 +3850,11 @@
 	inc	di
 	lea	bx,[di+50]
 	jmp	dd4
-%else
+else
 	mov di,line_out
     mov bx,[d_addr+4]
 	jmp dd2
-%endif
+endif
 dd11:	inc	dx		;set up the address for the next 'D' command.
 	mov	[d_addr],dx
 	ret
@@ -3823,18 +3883,21 @@
 	call dohack
 	mov	si,dx
 	mov	es,bx
-%if PM
-	cmp [bAddr32],byte 0
+if PM eq 1
+	;cmp [bAddr32],byte ptr 0
+	cmp byte ptr [bAddr32], byte ptr 0
     jz ee_2
-    cpu 386
+    ;cpu 386
+.386p
     mov dx,di		;dx was destroyed
     mov edi,edx
     movzx esi,si
     movzx ecx,cx
     db 67h
-    cpu 8086
+    ;cpu 8086
+.8086
 ee_2:    
-%endif
+endif
 	rep	movsb
 
 ;	Restore ds + es and undo the interrupt vector hack.
@@ -3845,7 +3908,7 @@
 	pop	ds
 	push ss			;restore es
 	pop	es
-	mov	di,run2324	;debuggee's int 23/24 values
+	mov	di,offset run2324	;debuggee's int 23/24 values
 	call prehak1	;copy things back
 	call unhack
 	ret
@@ -3861,15 +3924,19 @@
 	call hexword
 	mov	al,':'
 	stosb
-%if PM    
-	cmp [bAddr32],byte 0
+if PM eq 1    
+	;cmp [bAddr32],byte ptr 0
+	cmp byte ptr [bAddr32], byte ptr 0
     jz ee_21
-    cpu 386
+    ;cpu 386
+;.386
+.386p
     shld eax,edx,16
-    cpu 8086
+    ;cpu 8086
+.8086
     call hexword
 ee_21:    
-%endif
+endif
 	mov	ax,dx
 	call hexword
 
@@ -3895,10 +3962,11 @@
 	xor	cx,cx		;number of characters so far
 
 ee4:
-	cmp	byte [notatty],0
+	cmp	byte ptr [notatty],0
 	jz	ee9			;if it's a tty
 	push si
-	mov	di,line_in+2
+	;mov	di,line_in+2
+	mov	di,offset line_in+2
 	mov	si,[bufnext]
 ee5:
 	cmp	si,[bufend]
@@ -3907,12 +3975,12 @@
 	mov	al,CR
 	jc	ee8			;if eof
 ee6:
-	cmp	byte [notatty],CR
+	cmp	byte ptr [notatty],CR
 	jne	ee7			;if no need to compress CR/LF
-	cmp	byte [si],LF
+	cmp	byte ptr [si],LF
 	jne	ee7			;if not a line feed
 	inc	si			;skip it
-	inc	byte [notatty]	;avoid repeating this
+	inc	byte ptr [notatty]	;avoid repeating this
 	jmp	ee5			;next character
 
 ee7:
@@ -3974,7 +4042,7 @@
 	pop	cx
 	call dohack		;do the INT pointer hack
 	call writemem	;write AL at BX:(E)DX
-	mov	di,run2324	;debuggee's int 23/24
+	mov	di, offset run2324	;debuggee's int 23/24
 	call prehak1	;copy things back
 	call unhack		;undo the INT pointer hack
 
@@ -4006,18 +4074,20 @@
 ff:	xor	cx,cx		;get address range (no default length)
 	mov	bx,[reg_ds]
 	call getrange	;get address range into bx:(e)dx
-%if PM
-	cmp byte [bAddr32],0
+if PM eq 1
+	cmp byte ptr [bAddr32],0
     jz  ff_0
-    cpu 386
+    ;cpu 386
+.386p
     sub ecx,edx
     inc ecx
     push ecx
     push edx
-    cpu 8086
+    ;cpu 8086
+.8086
     jmp ff_01
 ff_0:    
-%endif
+endif
 	sub	cx,dx
 	inc	cx		;cx = number of bytes
 	push cx		;save it
@@ -4027,10 +4097,12 @@
 	call getstr		;get string of bytes
 	mov	cx,di
 	sub	cx,line_out
-%if PM
-	cmp byte [bAddr32],0
+if PM eq 1
+	cmp byte ptr [bAddr32],0
     jz	ff_1
-    cpu 386
+    ;cpu 386
+;.386
+.386p
     pop edi
     mov es,bx
     cmp ecx,1
@@ -4043,7 +4115,8 @@
 ff1_32:
 	mov	esi,line_out
 	push ecx
-	a32 rep	movsb
+	;a32 rep	movsb
+	rep	movsb
 	pop	ecx
 	dec	eax
 	jnz	ff1_32
@@ -4051,16 +4124,19 @@
 	mov	ecx,edx
 	jecxz ff4		;if no partial copies
 	mov	si,line_out
-	a32 rep	movsb
+	;a32 rep	movsb
+	rep	movsb
 	jmp	ff4		;done (almost)
 ff3_32:
 	pop ecx
     mov al,[line_out]
-    a32 rep stosb
+    ;a32 rep stosb
+    rep stosb
     jmp ff4
-    cpu 8086
+    ;cpu 8086
+.8086
 ff_1:    
-%endif
+endif
 	pop	di
 	mov	es,bx
 	cmp	cx,1
@@ -4087,7 +4163,8 @@
 	jmp	ff4		;done (almost)
 ff3:
 	pop	cx
-	mov	al,[line_out]
+	;mov	al,[line_out]
+	mov	al,byte ptr [line_out]
     stosb		;cx=0 -> 64 kB
     dec cx
     rep stosb
@@ -4160,9 +4237,10 @@
 ;	Finish up.  Check if it was one of _our_ breakpoints.
 
 gg6:
-	cmp	word [run_int],int3msg
+	;cmp	word ptr [run_int],int3msg
+	cmp	word ptr [run_int], offset int3msg
 	jne	gg9			;if not CC interrupt
-	dec	word [reg_ip]
+	dec	word ptr [reg_ip]
 	mov	si,[line_out]	;loop over the set breakpoints
 gg7:
 	dec	si
@@ -4183,7 +4261,7 @@
 ;	It's not.
 
 gg8:	
-	inc	word [reg_ip]
+	inc	word ptr [reg_ip]
 gg9:
 	jmp	tt2		;print messages and quit.
 
@@ -4249,16 +4327,16 @@
     call skipwhite
     jmp ii_2
 ii_1:
-    cmp [machine],byte 3
+    cmp [machine], byte ptr 3
     jb  ii_2
 	cmp ah,'D'
     jne ii_2
-%if 1    
+if 1    
     mov ah,[si-2]		;distiguish 'id' and 'i d'
     and ah,TOUPPER
     cmp ah,'I'
     jnz ii_2
-%endif    
+endif    
     inc bx
     inc bx
     call skipwhite
@@ -4277,21 +4355,23 @@
 	call hexword
     jmp ii_5
 ii_4:
-	cpu 386
+	;cpu 386
+.386p
 	in eax,dx
     push ax
     shr eax,16
 	call hexword
     pop ax
 	call hexword
-    cpu 8086
+    ;cpu 8086
+.8086
 ii_5:    
 	call putsline
 iiret:	ret
 
 errorj5:jmp	error
 
-%if PM
+if PM eq 1
 ispm:
 	push ax
 	mov ax,1686h
@@ -4299,15 +4379,16 @@
     and ax,ax
     pop ax
     ret
-%endif
+endif
 
 setpsp:
 	mov ah,50h
-%if PM
+if PM eq 1
 	call ispm
     jnz setpsp_rm
-%if NOEXTENDER
-    cpu 286
+if NOEXTENDER
+    ;cpu 286
+.286p
 	push cx
     push dx
     push bx
@@ -4324,15 +4405,16 @@
     pop dx
     pop cx
     ret
-    cpu 8086
-%else    
+    ;cpu 8086
+.8086
+else    
 	jmp doscall_rm
-%endif
+endif
 setpsp_rm:
-%endif
+endif
 
-%if USESDA
-	cmp word [pSDA+2],0
+if USESDA
+	cmp word ptr [pSDA+2],0
     jz doscall_rm
     push ds
     push si
@@ -4341,62 +4423,67 @@
     pop si
     pop ds
     ret
-%else
+else
 	jmp doscall_rm
-%endif
+endif
     
 getpsp:
 	mov ah,51h
-%if PM    
+if PM eq 1    
 	call ispm
     jnz getpsp_rm
-%if NOEXTENDER
+if NOEXTENDER
     call doscallx
     mov ax,2
     int 31h
     mov bx,ax
     ret
-%else    
+else    
     jmp doscall_rm
-%endif
+endif
 getpsp_rm:    
-%endif
+endif
 
-%if USESDA
-	cmp word [pSDA+2],0
+if USESDA
+	cmp word ptr [pSDA+2],0
     jz doscall_rm
     push ds
     lds bx,[pSDA]
     mov bx,[bx+10h]
     pop ds
     ret
-%else
+else
 	jmp doscall_rm
-%endif
+endif
 
 doscall:    
-%if NOEXTENDER
+if NOEXTENDER
 	call ispm
     jnz doscall_rm
-    cpu 286
+    ;cpu 286
+;.286p
+.286
 doscallx:
-    push word [cs:pspdbg]
+    push word ptr [cs:pspdbg]
 	push 21h
     call intcall
     ret
-    cpu 8086
-%endif
+    ;cpu 8086
+.8086
+endif
 doscall_rm:    
 	int	21h
     ret
 
-%if PM
+if PM eq 1
 intcall:    
-    cmp byte [cs:dpmi32],0
+    cmp byte ptr [cs:dpmi32],0
     jz intcall_pm16
-    cpu 386
+    ;cpu 386
+.386p
     movzx edi,di
-    cpu 8086
+    ;cpu 8086
+.8086
 intcall_pm16:    
     push bp
     sub sp,32h
@@ -4437,26 +4524,29 @@
     mov sp,bp
     pop bp
     ret 4
-%endif    
+endif    
 
-%if PM
+if PM eq 1
 
 ;--- this proc is called in pmode only
 ;--- DS is unknown!
 
 isextenderavailable:
-	cpu 286
+	;cpu 286
+.286p
     push ds
     push es
     pusha
 	push ss
     pop ds
-	mov si,szMSDOS
-    cmp byte [machine],3
+	mov si,offset szMSDOS
+    cmp byte ptr [machine],3
     jb iea_1
-    cpu 386
+    ;cpu 386
+.386p
     movzx esi,si
-    cpu 286
+    ;cpu 286
+.286p
 iea_1:
     mov ax,168ah
     int 2Fh
@@ -4466,15 +4556,17 @@
     pop es
     pop ds
     ret
-    cpu 8086
+    ;cpu 8086
+.8086
 szMSDOS:
 	db "MS-DOS",0
 nodosextinst:
 	push ss
     pop ds
-	mov dx,nodosext
+	;mov dx,nodosext
+	mov dx, offset nodosext
     jmp int21ah9
-%endif
+endif
 
 isdebuggeeloaded:    
 	mov		ax,[pspdbe]
@@ -4491,8 +4583,10 @@
     push bx
     push dx
     call createdummytask
-    mov si,[reg_cs]
-    mov di,[reg_ip]
+    ;mov si,[reg_cs]
+    mov si,word ptr [reg_cs]
+    ;mov di,[reg_ip]
+    mov di,word ptr [reg_ip]
 	pop dx
     pop bx
 ll5_2:
@@ -4504,44 +4598,46 @@
 ll:	
 	call parselw	;parse it
 	jz	ll1			;if request to read program
-%if NOEXTENDER
+if NOEXTENDER
 	call ispm
     jnz ll0_rm
     call isextenderavailable
     jc nodosextinst
 ll0_rm:    
-%endif
-	cmp [cs:usepacket],byte 2
+endif
+	;cmp [cs:usepacket],byte ptr 2
+	cmp byte ptr [cs:usepacket], byte ptr 2
     jb  ll0_1
     mov dl,al		;A=0,B=1,C=2,...
     xor si,si		;read drive
-%if VDD
+if VDD
 	mov ax,[hVdd]
 	cmp ax,-1
 	jnz callvddread
-%endif
+endif
     inc dl			;A=1,B=2,C=3,...
     mov ax,7305h	;DS:(E)BX -> packet
     stc
     int 21h			;use int 21h here, not doscall!
     jmp ll0_2
-%if VDD
+if VDD
 callvddread:
 	mov cx,5
     add cl,[dpmi32]
 	DispatchCall
     jmp ll0_2
-%endif
+endif
 ll0_1:
 	int	25h
 ll0_2:
-	mov	dx,reading
+	;mov	dx,reading
+	mov	dx,offset reading
 	jmp	ww1
 
 ;	For .com or .exe files, we can only load at cs:100.  Check that first.
 
 ll1:
-	test byte [fileext],EXT_COM+EXT_EXE
+	test byte ptr [fileext],EXT_COM+EXT_EXE
 	jz	ll4		;if not .com or .exe file
 	cmp	bx,[reg_cs]
 	jne	ll2		;if segment is wrong
@@ -4553,7 +4649,7 @@
 ;	load (any) file (if not .EXE or .COM, load at BX:DX)
 
 ll3:
-	cmp	byte [fileext],0
+	cmp	byte ptr [fileext],0
     jnz ll4
 	jmp	iiret
 
@@ -4580,19 +4676,21 @@
 ;		dx:ax	file length
 ;		si:di	load address (CS:100h for .EXE or .COM)
 
-	test	byte [fileext],EXT_COM | EXT_EXE
+	;test	byte [fileext],EXT_COM | EXT_EXE
+	test	byte ptr [fileext],EXT_COM or EXT_EXE
 	jnz	ll13		;if .com or .exe file
 
-%if PM
+if PM eq 1
 ;--- dont load a file in protected mode, 
 ;--- the read loop makes some segment register arithmetic
 	call ispm
     jnz ll5_1
-    mov dx,nopmsupp
+    ;mov dx,nopmsupp
+    mov dx,offset nopmsupp
     call int21ah9
     jmp ll12
 ll5_1:
-%endif
+endif
 
 ;	Load it ourselves.
 ;	For non-.com/.exe files, we just do a read, and set BX:CX to the
@@ -4630,7 +4728,8 @@
 ll9:
 	pop	bx			;out of space
 	pop	si
-	mov	dx,doserr8	;not enough memory
+	;mov	dx,doserr8	;not enough memory
+	mov	dx,offset doserr8	;not enough memory
 	call int21ah9	;print string
 	jmp	ll12
 
@@ -4643,13 +4742,13 @@
 ; seems a bit unwise to modify registers if a debuggee is running 
 ; but MS DEBUG does it as well
 
-%if 0
+if 0
 	mov cx,[reg_cs]
     cmp cx,[pspdbe]
     jnz noregmodify
     cmp word [reg_ip],100h
     jnz noregmodify
-%endif    
+endif    
 	mov	[reg_bx],dx
 	mov	[reg_cx],ax
 noregmodify:    
@@ -4698,15 +4797,15 @@
 	int	21h
 	pop	bx		;dx:bx is the file length
 
-%if 1
+if 1
 
 ;	adjust .exe size by 200h (who knows why)
 
-	test	byte [fileext],EXT_EXE
+	test	byte ptr [fileext],EXT_EXE
 	jz	ll14		;if not .exe
 	sub	bx,200h
 	sbb	dx,0
-%endif
+endif
 
 ;	Clear registers
 
@@ -4724,18 +4823,18 @@
 	call freemem	
 notask:
 
-	mov di, regs
+	mov di, offset regs
     mov cx, 16*2	;(8 std, 6 seg, ip, fl) * 2
     xor ax, ax
     rep stosw
     
-	pop word [reg_bx]
-    pop word [reg_cx]
+	pop word ptr [reg_bx]
+    pop word ptr [reg_cx]
 
 ;	Fix up interrupt vectors in PSP
 
 	mov	si,CCIV		;address of original INT 23 and 24 (in PSP)
-	mov	di,run2324
+	mov	di,offset run2324
 	movsw
 	movsw
 	movsw
@@ -4745,7 +4844,7 @@
 
 	mov	ax,4b01h	;load program
 	mov	dx,DTA		;offset of file to load
-	mov	bx,execblk	;parameter block
+	mov	bx,offset execblk	;parameter block
 	int	21h		;load it
 	jnc ll14_1
 	jmp ll16		;if error
@@ -4765,16 +4864,16 @@
 	les	si,[execblk+18]
 	mov	[reg_ip],si
 	mov	[reg_cs],es
-    mov byte [bInit],0
+    mov byte ptr [bInit],0
 	push cs
 	pop	es
     clc
     pushf
-    pop word [reg_fl]
+    pop word ptr [reg_fl]
     call getpsp
 	xchg	ax,bx		;mov ax,bx
 	mov	[pspdbe],ax
-	mov	di,reg_ds
+	mov	di,offset reg_ds
 	stosw
 	stosw			;reg_es
 	mov	bx,cs
@@ -4783,11 +4882,13 @@
 ;	Finish up.  Set termination address.
 
 	mov	ax,2522h	;set interrupt vector 22
-	mov	dx,int22
+	mov	dx,offset int22
 	int	21h
 	mov	ds,[pspdbe]
-	mov	word [TPIVOFS],int22
-	mov	[TPIVSEG],cs
+	;mov	word ptr [TPIVOFS],int22
+	mov	word ptr ds:[TPIVOFS], offset int22
+	;mov	[TPIVSEG],cs
+	mov	word ptr ds:[TPIVSEG],cs
 	push cs
 	pop	ds
 
@@ -4797,7 +4898,7 @@
 	mov	ax,[reg_ip]
     mov cx,[regh_eip]
 	mov	bx,[reg_cs]
-	mov	di,a_addr
+	mov	di,offset a_addr
 	stosw				;IP
     mov [di],cx
     add di,2
@@ -4843,14 +4944,14 @@
 	lodsb
 	call parsecm		;parse arguments (DS:(E)SI, ES:(E)DI, ECX)
 	push cx
-%if PM    
+if PM eq 1    
     call ispm
     jnz m2_1
 ;--- TODO: do this check in protected-mode    
 	clc
     jmp m3
 m2_1:    
-%endif    
+endif    
 	mov	cl,4
 	shr	dx,cl
 	add	dx,bx		;upper 16 bits of destination
@@ -4874,23 +4975,27 @@
 	call dohack	;do the interrupt pointer hack
 	pop	es
 	pop	ds
-%if PM
-	cmp byte [cs:bAddr32],0
+if PM eq 1
+	cmp byte ptr [cs:bAddr32],0
     jz m3_1
-    cpu 386
+    ;cpu 386
+.386p
     sahf
     jae m4_32
     add esi,ecx
     add edi,ecx
     std
 m4_32:
-	a32 rep movsb
-    a32 movsb
+	;a32 rep movsb
+	rep movsb
+    ;a32 movsb
+    movsb
     cld
     jmp ee0a
-    cpu 8086
+    ;cpu 8086
+.8086
 m3_1:    
-%endif
+endif
 	sahf
 	jae	m4		;if forward copy is OK
 	add	si,cx
@@ -4919,7 +5024,8 @@
 	mov	[mach_87],al	;coprocessor type, too
     cmp al,3
     jnc m5_1
-	and [regsdmp],byte ~1	;reset 386 register display
+	;and [regsdmp],byte ptr ~1	;reset 386 register display
+	and [regsdmp], byte ptr not 1	;reset 386 register display
 m5_1:    
 	ret
 
@@ -4934,7 +5040,7 @@
 	jne	errorj3		;if not 'c' after that
 	lodsb
 	call chkeol
-	mov	byte [has_87],0	;clear coprocessor flag
+	mov	byte ptr [has_87],0	;clear coprocessor flag
 	ret			;done
 
 m7:	
@@ -4952,30 +5058,35 @@
 m9:	
 	cmp	al,CR
 	jne	errorj3		;if not end of line
-	mov	byte [has_87],1	;set coprocessor flag
+	mov	byte ptr [has_87],1	;set coprocessor flag
 	mov	[mach_87],ah	;set copr. type
 	ret
 
 ;	Display machine type.
 
 m10:
-	mov	si,msg8088
+	;mov	si,msg8088
+	mov	si,offset msg8088
 	mov	al,[machine]
 	cmp	al,0
 	je	m11		;if 8088
-	mov	si,msgx86
+	;mov	si,msgx86
+	mov	si,offset msgx86
 	add	al,'0'
 	mov	[si],al
 m11:
 	call showstring
-	mov	si,no_copr
-	cmp	byte [has_87],0
+	;mov	si,no_copr
+	mov	si,offset no_copr
+	cmp	byte ptr [has_87],0
 	je	m12		;if no coprocessor
-	mov	si,has_copr
+	;mov	si,has_copr
+	mov	si,offset has_copr
 	mov	al,[mach_87]
 	cmp	al,[machine]
 	je	m12		;if has coprocessor same as processor
-	mov	si,has_287
+	;mov	si,has_287
+	mov	si,offset has_287
 m12:
 	call showstring	;show string
 	jmp	putsline	;call puts and quit
@@ -5017,21 +5128,21 @@
 	cmp	di,85h
 	jb	nn3c		;if no extension (name too short)
 	mov	al,EXT_HEX
-	cmp	word [di-5],'.H'
+	cmp	word ptr [di-5],'H.'
 	jne	nn3a		;if not .HEX
-	cmp	word [di-3],'EX'
+	cmp	word ptr [di-3],'XE'
 	je	nn3d		;if .HEX
 nn3a:
 	mov	al,EXT_EXE
-	cmp	word [di-5],'.E'
+	cmp	word ptr [di-5],'E.'
 	jne	nn3b		;if not .EXE
-	cmp	word [di-3],'XE'
+	cmp	word ptr [di-3],'EX'
 	je	nn3d		;if .EXE
 nn3b:
 	mov	al,EXT_COM
-	cmp	word [di-5],'.C'
+	cmp	word ptr [di-5],'C.'
 	jne	nn3c		;if not .COM
-	cmp	word [di-3],'OM'
+	cmp	word ptr [di-3],'MO'
 	je	nn3d		;if .COM
 nn3c:
 	mov	al,EXT_OTHER
@@ -5054,10 +5165,10 @@
 	mov	si,line_out
 	mov	di,5ch
 	call nn6		;do first FCB
-	mov	byte [reg_ax],al
+	mov	byte ptr [reg_ax],al
 	mov	di,6ch
 	call nn6		;second FCB
-	mov	byte [reg_ax+1],al
+	mov	byte ptr [reg_ax+1],al
 
 ;	Copy command tail.
 
@@ -5152,16 +5263,16 @@
     call skipwhite
     jmp oo_2
 oo_1:
-    cmp [machine],byte 3
+    cmp [machine],byte ptr 3
     jb  oo_2
 	cmp ah,'D'
     jne oo_2
-%if 1    
+if 1    
     mov ah,[si-2]		;distiguish 'od' and 'o d'
     and ah,TOUPPER
     cmp ah,'O'
     jnz oo_2
-%endif    
+endif    
     inc bx
     inc bx
     call skipwhite
@@ -5187,7 +5298,8 @@
 	out	dx,ax
 	ret
 oo_5:    
-	cpu	386
+	;cpu	386
+.386p
 	call getdword
 	call chkeol		;expect end of line here
     push bx
@@ -5196,14 +5308,15 @@
 	pop	dx
 	out	dx,eax
 	ret
-    cpu 8086
+    ;cpu 8086
+.8086
 
 ;--- ensure segment in BX is writeable
 ;--- out: Carry=1 if segment not writeable
 ;--- might clear HiWord(EDI)
 
 verifysegm:
-%if PM
+if PM eq 1
 	call ispm
     jnz is_rm
     push ax
@@ -5212,19 +5325,22 @@
     mov bp,sp
     sub sp,8
     mov di,sp
-    cmp [machine],byte 3
+    ;cmp [machine],byte 3
+    cmp [machine],byte ptr 3
     jb vs_1
-    cpu 386
+    ;cpu 386
+.386p
     movzx edi,di
-    cpu 8086
+    ;cpu 8086
+.8086
 vs_1:    
     mov ax,000Bh		;get descriptor
     int 31h
     jc vs_2
-	test byte [di+5],8	;code segment
+	test byte ptr [di+5],8	;code segment
     jz vs_2
-    and byte [di+5],0F3h;reset CODE+conforming attr
-    or byte [di+5],2	;set writable
+    and byte ptr [di+5],0F3h	;reset CODE+conforming attr
+    or byte ptr [di+5],2	;set writable
     mov bx,[scratchsel]
     mov ax,000Ch
     int 31h
@@ -5235,13 +5351,14 @@
     pop ax
     ret
 is_rm:
-%else
+else
 	clc
-%endif
+endif
     ret
 
-%if PM
-	cpu 286
+if PM eq 1
+	;cpu 286
+.286p
 setrmsegm:
     mov bx,[cs:scratchsel]
 setrmaddr:		;<--- set selector in BX to segment address in DX
@@ -5251,10 +5368,11 @@
     mov ax,7
     int 31h
     ret
-    cpu 8086
-%endif
+    ;cpu 8086
+.8086
+endif
 
-%if PM
+if PM eq 1
 
 ; get attribute of current CS
 ; save it in bCSAttr
@@ -5263,7 +5381,8 @@
 
 getcsattr:
 	mov ah,00
-    cmp byte [machine],3
+    ;cmp byte [machine],3
+    cmp byte ptr [machine],3
     jb getcsattr_1
     call ispm
     jnz getcsattr_1
@@ -5273,7 +5392,7 @@
     mov [bCSAttr],ah
     test ah,40h
     ret
-%endif
+endif
 
 ;--- read [EIP+x] value 
 ;--- CX=x, CS=[reg_cs], EIP=[regh_eip] & [reg_ip]
@@ -5283,10 +5402,11 @@
 getcseipbyte:
     push es
     mov es,[reg_cs]
-%if PM
-	test byte [bCSAttr],40h 
+if PM eq 1
+	test byte ptr [bCSAttr],40h 
     jz isrmipx
-    cpu 386
+    ;cpu 386
+.386p
     mov bx,[regh_eip]
     shl ebx,16
     mov bx,[reg_ip]
@@ -5297,9 +5417,10 @@
     pop edx
     pop es
     ret
-    cpu 8086
+    ;cpu 8086
+.8086
 isrmipx:    
-%endif
+endif
 	mov bx,[reg_ip]
     add bx,cx
 	mov	al,[es:bx]
@@ -5314,12 +5435,13 @@
     call verifysegm
     jc scib_1
     mov es,bx
-%if PM
-	test byte [bCSAttr],40h 
+if PM eq 1
+	test byte ptr [bCSAttr],40h 
     jz isrmipxx
-    cpu 386
-    push word [regh_eip]
-    push word [reg_ip]
+    ;cpu 386
+.386p
+    push word ptr [regh_eip]
+    push word ptr [reg_ip]
     pop ebx
     push edx
     movzx edx,cx
@@ -5327,9 +5449,10 @@
     pop edx
     pop es
     ret
-    cpu 8086
+    ;cpu 8086
+.8086
 isrmipxx:   
-%endif
+endif
 	mov bx,[reg_ip]
     add bx,cx
 	mov	[es:bx],al
@@ -5341,27 +5464,29 @@
 ;--- OUT: AL=old value at that location
 
 writemem:
-%if PM
+if PM eq 1
     call ispm
     jnz weip16
     call verifysegm	;make bx a writeable segment
     jc weip_1
-    cmp byte [machine],3
+    cmp byte ptr [machine],3
     jb  weip16
     push ax
     call getattrhigh
     pop ax
     jz weip16
-    cpu 386
+    ;cpu 386
+.386p
     push ds
     mov ds,bx
     xchg al,[edx]
     pop ds
-    cpu 8086
+    ;cpu 8086
+.8086
 weip_1:    
     ret
 weip16:
-%endif
+endif
 	push ds
 	mov	ds,bx
     push bx
@@ -5374,20 +5499,23 @@
 ;--- read byte at BX:EDX into AL
 
 readmem:    
-%if PM    
+if PM eq 1    
     call ispm
     jnz reip16
-    cmp [machine],byte 3
+    cmp [machine],byte ptr 3
     jb reip16
     call getattrhigh
     jz reip16
     push ds
     mov ds,bx
+    ;mov al,[edx]
+.386
     mov al,[edx]
+.8086
     pop ds
     ret
 reip16:    
-%endif    
+endif    
     push ds
     mov ds,bx
     mov bx,dx
@@ -5395,7 +5523,7 @@
     pop ds
     ret
 
-%if PM
+if PM eq 1
 
 ;--- DS:SI -> protected-mode "flag" (WORD)
 ;--- returns AX<>0000 if real-mode
@@ -5414,14 +5542,16 @@
 	int 31h			;then transform saved CS to a selector
     mov bx,ax
     pop ax 
-    cmp [machine],byte 3
+    cmp [machine],byte ptr 3
     jb nomodechange
-    cpu 386
+    ;cpu 386
+.386p
     movzx edx,dx	;ensure hiword edx is cleared
-    cpu 8086
+    ;cpu 8086
+.8086
 nomodechange:
 	ret
-%endif
+endif
 
 ;--- check if an unexpected int 3 has occured
 ;--- CS:(E)IP in reg_cs:regh_eip & reg_ip
@@ -5429,23 +5559,26 @@
 ;--- called by P, T
 
 IsUnexpInt3:    
-%if PM
+if PM eq 1
 	call getcsattr
-%endif    
+endif    
     mov  cx,-1
     call getcseipbyte
     cmp al,0CCh
     jz isunexp_exit
-	mov	dx,int3msg
+	;mov	dx,int3msg
+	mov	dx,offset int3msg
 	mov	[reg_ip],bx
-%if PM    
+if PM eq 1    
     test ah,40h
     jz isunexp_exit
-    cpu 386
+    ;cpu 386
+.386p
     shr ebx,16
     mov [regh_eip],bx
-    cpu 8086
-%endif    
+    ;cpu 8086
+.8086
+endif    
 isunexp_exit:
 	ret
 
@@ -5459,20 +5592,23 @@
 pp1:
 	push cx			;save cx
 	mov	dx,15		;DL = number of bytes to go; DH = prefix flags.
-%if PM
+if PM eq 1
 	call getcsattr
     jz iseip16
-    cpu 386
+    ;cpu 386
+.386p
     mov si,[regh_eip]
     shl esi,16
     mov dh,1+2
-    cpu 8086
+    ;cpu 8086
+.8086
 iseip16:    
-%endif    
+endif    
 	mov	si,[reg_ip]
 pp2:
 	call pp16		;get next instruction byte into AL
-	mov	di,ppbytes
+	;mov	di,ppbytes
+	mov	di,offset ppbytes
 	mov	cx,PPLEN
 	repne scasb
 	jne	pp5		;if not one of these
@@ -5500,9 +5636,10 @@
 	cmp	al,0ffh
     jz pp5_0
 	jmp	pp12	;just an ordinary instruction
-pp5_0    
+pp5_0:
 	call pp16	;get MOD REG R/M byte
-	and	al,~8	;clear lowest bit of REG field (/3 --> /2)
+	;and	al,~8	;clear lowest bit of REG field (/3 --> /2)
+	and	al,not 8	;clear lowest bit of REG field (/3 --> /2)
 	xor	al,10h	;/2 --> /0
 	test al,38h
     jz pp5_1
@@ -5553,38 +5690,43 @@
 	push cx
 pp11x_1:		;BX=CS
 	mov dx,si
-    cmp [machine],byte 3
+    cmp [machine],byte ptr 3
     jb pp11x_2
-    cpu 386
+    ;cpu 386
+.386p
     mov edx,esi
-    cpu 8086
+    ;cpu 8086
+.8086
 pp11x_2:
 	mov	al,0cch
     call writemem
     jnc pp11x_3
-    mov dx,cantwritebp
+    ;mov dx,cantwritebp
+    mov dx,offset cantwritebp
     jmp prnquit
 pp11x_3:    
 	mov	di,line_out	;save old byte here
 	stosb
 	xchg ax,si
 	stosw
-%if PM
-	cmp byte [machine],3
+if PM eq 1
+	cmp byte ptr [machine],3
     jb noeipsave
-    cpu 386
+    ;cpu 386
+.386p
     shld eax,esi,16		;save hiword ESI if machine is a 80386+
 	stosw
-    cpu 8086
+    ;cpu 8086
+.8086
 noeipsave:    
-%endif
+endif
 	mov	ax,bx
 	stosw
-%if PM    
+if PM eq 1    
     mov ax,1686h
     int 2Fh
     stosw
-%endif    
+endif    
 	call run
     
 	mov	si,line_out
@@ -5592,26 +5734,29 @@
 	xchg ax,cx		;into CL
 	lodsw			;old IP
 	xchg ax,dx
-%if PM
-	cmp byte [machine],3
+if PM eq 1
+	cmp byte ptr [machine],3
     jb noeipsave_2
-    cpu 386
+    ;cpu 386
+.386p
     lodsw
     push ax
     push dx
     pop edx
-    cpu 8086
+    ;cpu 8086
+.8086
 noeipsave_2:    
-%endif
+endif
 	lodsw			;old CS
 	xchg ax,bx		;CS -> BX
-%if PM
+if PM eq 1
 	call IsSegm2Sel	;change BX to selector if switch to pmode
-%endif
+endif
 	mov al,cl
     call writemem	;write byte AL at BX:E/DX
 	xor	dx,dx		;set flag
-	cmp	word [run_int],int3msg
+	;cmp	word ptr [run_int],int3msg
+	cmp	word ptr [run_int],offset int3msg
 	jne	pp13		;if not CC interrupt
     call IsUnexpInt3;test byte at reg_cs:reg_eip-1 if CCh	
     jmp pp13
@@ -5619,9 +5764,10 @@
 ;	Ordinary instruction.  Just do a trace.
 
 pp12:	
-	or byte [reg_fl+1],1	;set single-step mode
+	or byte ptr [reg_fl+1],1	;set single-step mode
 	call run
-	mov	dx,int1msg
+	;mov	dx,int1msg
+	mov	dx,offset int1msg
 
 ;	Common part to finish up.
 
@@ -5649,46 +5795,50 @@
     jmp pp11x
 
 inceip:    
-%if PM
-	test byte [bCSAttr],40h
+if PM eq 1
+	test byte ptr [bCSAttr],40h
     jnz inceip_1
-%endif    
+endif    
 	inc	si
     ret
-%if PM
-	cpu 386
+if PM eq 1
+	;cpu 386
+.386p
 inceip_1:
 	inc esi
     ret
-    cpu 8086
-%endif
+    ;cpu 8086
+.8086
+endif
 addeip:
-%if PM
-	test byte [bCSAttr],40h
+if PM eq 1
+	test byte ptr [bCSAttr],40h
     jnz addeip_1
-%endif    
+endif    
 	add	si,ax
     ret
-%if PM    
-	cpu 386
+if PM eq 1    
+	;cpu 386
+.386p
 addeip_1:
 	movzx eax,ax
 	add	esi,eax
     ret
-    cpu 8086
-%endif
+    ;cpu 8086
+.8086
+endif
 
 ;	PPX - Get next byte in instruction stream.
 
 pp16:
 	push ds
 	mov	ds,[reg_cs]
-%if PM
-	test byte [cs:bCSAttr],40h
+if PM eq 1
+	test byte ptr [cs:bCSAttr],40h
     jz pp16_2
     db 67h	;is a a32
 pp16_2:
-%endif
+endif
 	lodsb
 	pop	ds
 	ret
@@ -5698,33 +5848,35 @@
 ;	Q command - quit.
 
 qq:	
-%if PM
-	mov byte [dpmidisable+1],0	;disble DPMI hook
-	inc byte [bNoHook2F]		;avoid a new hook while terminating
-%endif
+if PM eq 1
+	mov byte ptr [dpmidisable+1],0	;disble DPMI hook
+	inc byte ptr [bNoHook2F]		;avoid a new hook while terminating
+endif
 
 ; cancel child's process if any
 ; this will drop to real-mode if debuggee is in pmode
 
 	call freemem
 
-%if VDD
+if VDD
 	mov ax,[hVdd]
     cmp ax,-1
     jz novddrelease
     UnRegisterModule
 novddrelease:
-%endif
+endif
 
 ;	Restore interrupt vectors.
 
-	mov	di,intsave
-	mov	si,inttab
-%if PM
+	;mov	di,intsave
+	mov	di,offset intsave
+	;mov	si,inttab
+	mov	si,offset inttab
+if PM eq 1
     mov cx,5
-%else
+else
     mov cx,4
-%endif    
+endif    
 nextint:
 	lodsb
     mov bl,al
@@ -5749,7 +5901,7 @@
 
 ;	Restore termination address.
 
-	mov	si,psp22	;restore termination address
+	mov	si,offset psp22	;restore termination address
 	mov	di,TPIVOFS
 	movsw
 	movsw
@@ -5776,16 +5928,17 @@
     je rr1_0
     jmp no386_5    
 rr1_0:    
-    cmp [machine],byte 3
+    cmp [machine],byte ptr 3
     jb  rr1_w
-    xor [regsdmp],byte 1
+    xor [regsdmp],byte ptr 1
     mov ax,"n "
     jnz rr1_x1
     mov ax,"ff"
-rr1_x1    
-	mov word [regs386s],ax
+rr1_x1:
+	mov word ptr [regs386s],ax
 	mov	di,line_out
-    mov si,regs386
+    ;mov si,regs386
+    mov si,offset regs386
     call showstring
     call putsline
 rr1_w:    
@@ -5798,7 +5951,7 @@
     je rr1x_0
     jmp no386_5    
 rr1x_0:    
-    cmp [has_87],byte 0
+    cmp [has_87],byte ptr 0
     jz  rr1x_1
     call dumpregsF
 rr1x_1:    
@@ -5807,18 +5960,19 @@
 	dec	si
 	lodsw
 	and	ax,TOUPPER_W
-	mov	di,regnames
+	mov	di, offset regnames
 	mov	cx,16
 	repne scasw
 	mov	bx,di
 	mov	di,line_out
 	jne	rr2			;if not found
-    cmp [si],byte 20h	;avoid "ES" to be found for "ESI" or "ESP"
+    ;cmp [si],byte ptr 20h	;avoid "ES" to be found for "ESI" or "ESP"
+    cmp byte ptr [si],byte ptr 20h	;avoid "ES" to be found for "ESI" or "ESP"
     ja rr2
 	stosw			;print register name
 	mov	al,' '
 	stosb
-	sub	bx,regnames+2
+	sub	bx,offset regnames+2
 	call skipcomma	;skip white spaces
 	cmp	al,CR
 	jne	rr1a		;if not end of line
@@ -5833,7 +5987,7 @@
 	call getword
 	call chkeol		;expect end of line here
 	mov	[bx+regs],dx;save new value
-	cmp	bx,reg_ip - regs
+	cmp	bx, offset reg_ip - offset regs
 	jne	rr1b		;if not changing IP
 rr1b:	ret
 
@@ -5866,11 +6020,11 @@
 	dec	si
 	lodsw
 	and	ax,TOUPPER_W	;here's the mnemonic
-	mov	di,flgnams
+	mov	di, offset flgnams
 	mov	cx,16
 	repne scasw
 	jne	rr6		;if no match
-	cmp	di,flgnons
+	cmp	di, offset flgnons
 	ja	rr4		;if we're clearing
 	mov	ax,[di-16-2]
 	not	ax
@@ -5886,7 +6040,7 @@
 	jmp	rr3		;if done
 
 rr6:
-	cmp [machine],byte 3
+	cmp [machine],byte ptr 3
     jb  no386_5
     cmp al,'E'
     jnz no386_5
@@ -5894,17 +6048,18 @@
     and al,TOUPPER
     xchg al,ah
     mov cx,16
-	mov	di,regnames
+	mov	di, offset regnames
 	repne	scasw
 	jne	no386_5
 	mov	bx,di
 	mov	di,line_out
-    mov [di],byte 'E'
+    ;mov [di],byte ptr 'E'
+    mov byte ptr [di],byte ptr 'E'
     inc di
     stosw
 	mov	al,' '
 	stosb
-	sub	bx,regnames+2
+	sub	bx, offset regnames+2
 	call skipcomma	;skip white spaces
 	cmp	al,CR
 	jne	rr1aX   	;if not end of line
@@ -5927,12 +6082,12 @@
 	call chkeol		;expect end of line here
 	mov	[bx+regs],dx	;save new value
 	mov	[bx+regshi],cx	;save new value
-	cmp	bx,reg_ip - regs
+	cmp	bx, offset reg_ip - offset regs
 	jne	rr1bX		;if not changing IP
 rr1bX:
 	ret
     
-no386_5    
+no386_5:
 	dec	si		;back up one before flagging an error
 errorj9:
 	jmp	error
@@ -6022,27 +6177,30 @@
 	add	al,'0'
     mov	[tmodev],al
 	mov	di,line_out
-    mov si,tmodes
+    ;mov si,tmodes
+    mov si,offset tmodes
     call showstring
-    mov si,tmode0
-    test byte [tmode],1
+    ;mov si,tmode0
+    mov si,offset tmode0
+    test byte ptr [tmode],1
     jz ismg_1
-    mov si,tmode1
+    ;mov si,tmode1
+    mov si,offset tmode1
 ismg_1:
     call showstring
     call putsline
 	ret
 isnotmodeset:
-	mov	word [lastcmd], isnotmodeset
+	mov	word ptr [lastcmd], offset isnotmodeset
 	call parse_pt	;process arguments
     
 ;	Do it <CX=count> times.
 
 tt1:	
 	push cx
-%if PM
+if PM eq 1
 	call getcsattr
-%endif
+endif
 	xor cx,cx
 	call getcseipbyte
     cmp al,0CDh
@@ -6051,7 +6209,7 @@
     call getcseipbyte
     cmp al,3
     jz  isstdtrace
-    test byte [tmode], 1	;TM=1?
+    test byte ptr [tmode], 1	;TM=1?
     jnz tt1_0
     jmp  isstdtraceX
 tt1_0:    
@@ -6059,16 +6217,16 @@
     jz isstdtrace
     jmp emuint
 isstdtrace:
-%if PM    
+if PM eq 1    
 	mov bx,[reg_ip]
-    cmp bx,[dpmiwatch+0]	;catch the initial switch to protected mode
+    cmp bx,word ptr [dpmiwatch+0]	;catch the initial switch to protected mode
     jnz isnotdbgcode
     mov ax,[reg_cs]
-    cmp ax,[dpmiwatch+2]
+    cmp ax,word ptr [dpmiwatch+2]
     jz isdpmientry
 isnotdbgcode:    
-%endif
-	or byte [reg_fl+1],1h	;set single-step mode
+endif
+	or byte ptr [reg_fl+1],1h	;set single-step mode
     xor cx,cx
     call getcseipbyte
     cmp al,9Ch				;opcode "PUSHF"?
@@ -6079,7 +6237,8 @@
 isnotpushf:    
 	call	run
 tt1_2:    
-	cmp	word [run_int],int1msg
+	;cmp	word ptr [run_int],int1msg
+	cmp	word ptr [run_int],offset int1msg
 	je	tt1_1
 	jmp	tt2		;if some other interrupt
 tt1_1:    
@@ -6092,41 +6251,46 @@
 cleartfonstack:
 	push es
     mov es,[reg_ss]
-%if PM
+if PM eq 1
     call ispm
     jnz ctos_0
-	cmp byte [machine],3
+	cmp byte ptr [machine],3
     jb ctos_0
-    cpu 386
+    ;cpu 386
+.386p
 	mov bx,es
     call getattrhigh
     jz ctos_0
     mov bx,[regh_esp]
     shl ebx,16
     mov bx,[reg_sp]
-    and byte [es:ebx+1],~1
+    ;and byte ptr [es:ebx+1],~1
+    and byte ptr [es:ebx+1],not 1
     jmp ctos_1
-    cpu 8086
+    ;cpu 8086
+.8086
 ctos_0:    
-%endif
+endif
     mov bx,[reg_sp]
-    and byte [es:bx+1],~1
+    ;and byte ptr [es:bx+1],~1
+    and byte ptr [es:bx+1],not 1
 ctos_1:
     pop es
     ret
 
-%if PM
+if PM eq 1
 isdpmientry:    
-    cmp byte [bNoHook2F],0
+    cmp byte ptr [bNoHook2F],0
     jz isstdhook
-    mov word [reg_ip],mydpmientry	;if int 2fh is *not* hooked
+    ;mov word ptr [reg_ip],mydpmientry	;if int 2fh is *not* hooked
+    mov word ptr [reg_ip],offset mydpmientry	;if int 2fh is *not* hooked
     mov [reg_cs],cs
 isstdhook:    
     push ss
     pop es
     call ppout	;run code until RETF
     jmp tt1_3
-%endif
+endif
 
 ;--- test if memory at CS:E/IP can be written to
 ;--- return C if not
@@ -6164,20 +6328,22 @@
     
 ;--- now get (E)SI=(E)IP+2 
     
-%if PM    
-    cmp byte [machine],3
+if PM eq 1    
+    cmp byte ptr [machine],3
     jb isstdtrace_2
-    test byte [bCSAttr],40h
+    test byte ptr [bCSAttr],40h
     jz isstdtrace_2
-    cpu 386
-    push word [regh_eip]
+    ;cpu 386
+.386p
+    push word ptr [regh_eip]
     push si
     pop esi
     add esi,2
     jmp isstdtrace_3
-    cpu 8086
+    ;cpu 8086
+.8086
 isstdtrace_2:
-%endif
+endif
 	add si,2
 isstdtrace_3:
 	call pp11x				;set BP at BX:(E)SI and run debuggee
@@ -6187,10 +6353,10 @@
 
 emuint:
     mov bl,al
-%if PM
+if PM eq 1
 	call ispm
     jz   emuint_pm
-%endif
+endif
     mov bh,0
     push ds
     xor ax,ax
@@ -6210,10 +6376,10 @@
     call pp11x
     jmp tt1_3
 isrom:
-%if 0
+if 0
 	pop ds
     jmp isstdtrace
-%else    
+else    
 	mov  ax,ds
     pop  ds
 	xchg si,[reg_ip]
@@ -6230,10 +6396,10 @@
 	mov  [bx+4],cx
     pop  ds
     mov  [reg_sp],bx
-    and  byte [reg_fl],0FCh
+    and  byte ptr [reg_fl],0FCh
     jmp  tt1_1
-%endif    
-%if PM
+endif    
+if PM eq 1
 emuint_pm:
     mov  ax,204h
     int  31h
@@ -6243,16 +6409,18 @@
     jmp  isstdtrace
 emuint_1:    
 	mov  si,dx
-    cmp  byte [dpmi32],0
+    cmp  byte ptr [dpmi32],0
     jz   emuint_pm16
-    cpu 386
+    ;cpu 386
+.386p
     mov  esi,edx
-    cpu 8086
+    ;cpu 8086
+.8086
 emuint_pm16:
 	call pp11x
     jmp  tt1_3
     
-%endif
+endif
 
 ;	Print message about unexpected interrupt, dump registers, and end
 ;	command.  This code is also used by the G and P commands.
@@ -6260,36 +6428,41 @@
 tt2:	
 	mov	dx,[run_int]
 	call int21ah9	;print string
-	cmp	dx,progtrm
+	;cmp	dx,progtrm
+	cmp	dx,offset progtrm
 	je	tt3			;if it terminated, skip the registers
 	call dumpregs
 tt3:	
 	jmp	cmd3		;back to the start
 
-%if PM
+if PM eq 1
 tt2x:				;<--- entry if exception occured inside debugger
 	call unhack
 	mov	dx,[run_int]
 	call int21ah9	;print string
-%if EXCCSIP    
-	mov	dx,excloc
+if EXCCSIP    
+	;mov	dx,excloc
+	mov	dx,offset excloc
     call int21ah9
-%endif    
+endif    
     jmp cmd3
-%endif    
+endif    
 
 ;	U command - disassemble.
 
 uu:
-	mov word [lastcmd],lastuu	
+	;mov word [lastcmd],lastuu	
+	mov word ptr [lastcmd],offset lastuu
 	cmp	al,CR
 	jne	uu1		;if an address was given
 lastuu:    
-%if PM    
+if PM eq 1    
     call getcsattr
     jz   uu_0
-    cpu 386
-    mov  ecx,[u_addr]
+    ;cpu 386
+.386p
+    ;mov  ecx,[u_addr]
+    mov  ecx,dword ptr [u_addr]
     add  ecx,1Fh
     jnc  uu0x
     mov  ecx,-1
@@ -6298,20 +6471,22 @@
 uu3_32:    
 	push ecx
 	push edx
-	mov	byte [disflags],0
+	mov	byte ptr [disflags],0
 	call disasm
 	pop	ebx
 	pop	ecx
-	mov	eax,[u_addr]
+	;mov	eax,[u_addr]
+	mov	eax,dword ptr [u_addr]
 	mov	edx,eax
 	sub	eax,ecx		;current position - end
 	sub	ebx,ecx		;previous position - end
 	cmp	eax,ebx
 	jnb	uu3_32		;if we haven't reached the goal
     ret
-    cpu 8086
+    ;cpu 8086
+.8086
 uu_0:
-%endif    
+endif    
 	mov	cx,[u_addr]
 	add	cx,1fh
 	jnc	uu2		;if no overflow
@@ -6325,14 +6500,17 @@
 	call chkeol		;expect end of line here
 	mov	[u_addr+4],bx
 	mov	[u_addr],dx
-%if PM
-	cmp [machine],byte 3
+if PM eq 1
+	cmp [machine],byte ptr 3
     jb uu1_1
-    cpu 386
-    mov dword [u_addr],edx
-    cpu 8086
+    ;cpu 386
+.386p
+    ;mov dword [u_addr],edx
+    mov dword ptr [u_addr],edx
+    ;cpu 8086
+.8086
 uu1_1:    
-%endif
+endif
 
 ;	At this point, cx holds the last address, and dx the address.
 
@@ -6341,7 +6519,7 @@
 uu3:
 	push cx
 	push dx
-	mov	byte [disflags],0
+	mov	byte ptr [disflags],0
 	call disasm		;do it
 	pop	bx
 	pop	cx
@@ -6396,24 +6574,26 @@
 ww:	
 	call parselw	;parse L and W argument format
 	jz	ww4			;if request to write program
-%if NOEXTENDER
+if NOEXTENDER
 	call ispm
     jnz ww0_rm
     call isextenderavailable
     jnc ww0_rm
-	mov dx,nodosext
+	;mov dx,nodosext
+	mov dx,offset nodosext
     jmp int21ah9
 ww0_rm:    
-%endif
-	cmp [cs:usepacket],byte 2
+endif
+	;cmp [cs:usepacket],byte ptr 2
+	cmp byte ptr [cs:usepacket],byte ptr 2
     jb  ww0_1
     mov dl,al		;A=0,B=1,C=2,...
     mov si,6001h	;write, assume "file data"
-%if VDD
+if VDD
 	mov ax,[hVdd]
     cmp ax,-1
     jnz callvddwrite
-%endif
+endif
     inc dl			;A=1,B=2,C=3,...
     call lockdrive
     mov ax,7305h	;DS:(E)BX->packet
@@ -6423,17 +6603,18 @@
     call unlockdrive
     popf
     jmp ww0_2
-%if VDD
+if VDD
 callvddwrite:
 	mov cx,5
     add cl,[dpmi32]
     DispatchCall
     jmp ww0_2
-%endif
+endif
 ww0_1:
 	int	26h
 ww0_2:
-	mov	dx,writing
+	;mov	dx,writing
+	mov	dx,offset writing
 ww1:
 	mov	bx,ss		;restore segment registers
 	mov	ds,bx
@@ -6452,7 +6633,8 @@
 	call showstring
 	mov	si,dx
 	call showstring
-	mov	si,drive
+	;mov	si,drive
+	mov	si,offset drive
 	call showstring
 	call putsline
 ww3:
@@ -6466,27 +6648,30 @@
 	mov	al,[fileext]	;get flags of file extension
 	test al,EXT_EXE + EXT_HEX
 	jz	ww5		;if not EXE or HEX
-	mov	dx,nowhexe
+	;mov	dx,nowhexe
+	mov	dx,offset nowhexe
 	jmp	ww6
 
 ww5:
 	cmp	al,0
 	jnz	ww7		;if extension exists
-	mov	dx,nownull
+	;mov	dx,nownull
+	mov	dx,offset nownull
 ww6:
 	jmp	ww16
 
 ;	File extension is OK; write it.  First, create the file.
 
 ww7:
-%if PM
+if PM eq 1
 	call ispm
     jnz ww7_1
-    mov dx,nopmsupp
+    ;mov dx,nopmsupp
+    mov dx,offset nopmsupp
     call int21ah9
     ret
 ww7_1:    
-%endif
+endif
 
 	mov	bp,line_out
 	cmp	dh,0feh
@@ -6505,7 +6690,8 @@
 
 ;	Print message about writing.
 
-	mov	dx,wwmsg1
+	;mov	dx,wwmsg1
+	mov	dx,offset wwmsg1
 	call int21ah9	;print string
 	mov	ax,[reg_bx]
 	cmp	ax,10h
@@ -6525,7 +6711,8 @@
 	mov	[bp+6],ax
 	call hexword
 	call puts		;print size
-	mov	dx,wwmsg2
+	;mov	dx,wwmsg2
+	mov	dx,offset wwmsg2
 	call int21ah9	;print string
 
 ;	Now write the file.  Size remaining is in line_out+6.
@@ -6535,7 +6722,7 @@
 ww11:
 	mov	ax,0fe00h
 	sub	ax,dx
-	cmp	byte [bp+8],0
+	cmp	byte ptr [bp+8],0
 	jnz	ww12		;if more than 0fe00h bytes remaining
 	cmp	ax,[bp+6]
 	jb	ww12		;ditto
@@ -6553,14 +6740,15 @@
 	add	si,0fe0h	;update segment pointer
 	sub	[bp+6],cx
 	lahf
-	sbb	byte [bp+8],0
+	sbb	byte ptr [bp+8],0
 	jnz	ww11		;if more to go
 	sahf
 	jnz	ww11		;ditto
 	jmp	ww14		;done
 
 ww13:
-	mov	dx,diskful
+	;mov	dx,diskful
+	mov	dx,offset diskful
 	call int21ah9	;print string
 	mov	ah,41h		;unlink file
 	mov	dx,DTA
@@ -6577,20 +6765,26 @@
 
 ww15:
 	cmp	ax,2
-	mov	dx,doserr2	;File not found
+	;mov	dx,doserr2	;File not found
+	mov	dx,offset doserr2	;File not found
 	je	ww16
 	cmp	ax,3
-	mov	dx,doserr3	;Path not found
+	;mov	dx,doserr3	;Path not found
+	mov	dx,offset doserr3	;Path not found
 	je	ww16
 	cmp	ax,5
-	mov	dx,doserr5	;Access denied
+	;mov	dx,doserr5	;Access denied
+	mov	dx,offset doserr5	;Access denied
 	je	ww16
 	cmp	ax,8
-	mov	dx,doserr8	;Insufficient memory
+	;mov	dx,doserr8	;Insufficient memory
+	mov	dx,offset doserr8	;Insufficient memory
 	je	ww16
-	mov	di,wwerr1
+	;mov	di,wwerr1
+	mov	di,offset wwerr1
 	call hexword
-	mov	dx,wwerr	;Error ____ opening file
+	;mov	dx,wwerr	;Error ____ opening file
+	mov	dx,offset wwerr	;Error ____ opening file
 ww16:
 int21ah9:
 	mov ah,9
@@ -6620,7 +6814,8 @@
 xx_1:
 	jmp	error
 
-xhelp:	mov	dx,xhelpmsg
+;xhelp:	mov	dx,xhelpmsg
+xhelp:	mov	dx,offset xhelpmsg
 	jmp	int21ah9	;print string and return
 
 ;	XA - Allocate EMS.
@@ -6637,9 +6832,11 @@
 nonullcnt:    
 	call emscall
 	xchg ax,dx			;mov ax,dx
-	mov	di,xaans1
+	;mov	di,xaans1
+	mov	di,offset xaans1
 	call hexword
-	mov	dx,xaans
+	;mov	dx,xaans
+	mov	dx,offset xaans
 	jmp	int21ah9	;print string and return
 
 ;	XD - Deallocate EMS handle.
@@ -6651,9 +6848,11 @@
 	mov	ah,45h		;deallocate handle
 	call emscall
 	xchg ax,dx		;mov ax,dx
-	mov	di,xdans1
+	;mov	di,xdans1
+	mov	di,offset xdans1
 	call hexword
-	mov	dx,xdans
+	;mov	dx,xdans
+	mov	dx,offset xdans
 	jmp	int21ah9	;print string and return
 
 ;	XR - Reallocate EMS handle.
@@ -6668,7 +6867,8 @@
     xchg bx,dx
 	mov	ah,51h			;reallocate handle
 	call	emscall
-	mov	dx,xrans
+	;mov	dx,xrans
+	mov	dx,offset xrans
 	jmp	int21ah9		;print string and return
 
 ;	XM - Map EMS memory to physical page.
@@ -6687,13 +6887,15 @@
 	push ax
 	mov	ah,44h		;function 5 - map memory
 	call emscall
-	mov	di,xmans1
+	;mov	di,xmans1
+	mov	di,offset xmans1
 	xchg ax,bx		;mov al,bl
 	call hexbyte
-	add	di,xmans2-xmans1-2
+	add	di, offset xmans2 - offset xmans1-2
 	pop	ax
 	call hexbyte
-	mov	dx,xmans
+	;mov	dx,xmans
+	mov	dx,offset xmans
 	jmp	int21ah9	;print string and return
 
 ;	XS - Print EMS status.
@@ -6747,7 +6949,8 @@
 	jnz	xs4		;if more to go
 
 xs5:	
-	mov	dx,crlf
+	;mov	dx,crlf
+	mov	dx,offset crlf
 	call int21ah9	;print string
 
 ;	Next print the mappable physical address array.
@@ -6756,28 +6959,34 @@
 	mov	ax,5800h	;function 25 - get mappable phys. address array
 	mov	di,line_out	;address to put array
 	call emscall
-	mov	dx,xsnopgs
+	;mov	dx,xsnopgs
+	mov	dx,offset xsnopgs
     jcxz xs7        ;NO mappable pages!
     
 	mov	si,di
 xs6:
     push cx
 	lodsw
-	mov	di,xsstr2b
+	;mov	di,xsstr2b
+	mov	di,offset xsstr2b
 	call hexword
 	lodsw
-	mov	di,xsstr2a
+	;mov	di,xsstr2a
+	mov	di,offset xsstr2a
 	call hexbyte
-	mov	dx,xsstr2
+	;mov	dx,xsstr2
+	mov	dx,offset xsstr2
 	call int21ah9	;print string
 	pop	cx			;end of loop
     test cl,1
     jz xs_nonl
-	mov	dx,crlf		;blank line
+	;mov	dx,crlf		;blank line
+	mov	dx,offset crlf		;blank line
 	call int21ah9	;print string
 xs_nonl:
 	loop xs6
-	mov	dx,crlf		;blank line
+	;mov	dx,crlf		;blank line
+	mov	dx,offset crlf		;blank line
 xs7:
 	call int21ah9	;print string
 
@@ -6787,30 +6996,34 @@
 	call emscall
 	mov	ax,dx		;total pages available
 	sub	ax,bx		;number of pages allocated
-	mov	bx,xsstrpg
+	;mov	bx,xsstrpg
+	mov	bx,offset xsstrpg
 	call sumshow	;print the line
 	mov	ah,4bh		;function 12 - get handle count
 	call emscall
 	xchg ax,bx		;ax = number of handles allocated
 	mov	dx,0ffh		;total number of handles
-	mov	bx,xsstrhd
+	;mov	bx,xsstrhd
+	mov	bx,offset xsstrhd
 	call sumshow	;print the line
 	ret				;done
 
 ;	Call EMS
 
 emscall:
-%if PM
+if PM eq 1
 	call ispm
     jnz ems_rm
-    cpu 286
-    push word [cs:pspdbg]
+    ;cpu 286
+.286p
+    push word ptr [cs:pspdbg]
     push 67h
     call intcall
     jmp ems_call_done
-    cpu 8086
+    ;cpu 8086
+.8086
 ems_rm:    
-%endif    
+endif    
 	int	67h
 ems_call_done:    
 	cmp	ah,0
@@ -6826,16 +7039,18 @@
 	or	dx,dx
 	jnz	ce3		;if there's a word there
 ce2:
-	mov	di,emserrxa
+	;mov	di,emserrxa
+	mov	di,offset emserrxa
 	call hexbyte
-	mov	dx,emserrx
+	;mov	dx,emserrx
+	mov	dx,offset emserrx
 ce3:	
 	jmp	prnquit		;print string and quit
 
 ;	Check for EMS
 
 emschk:
-%if PM
+if PM eq 1
 	call ispm
     jnz emschk1
     mov bl,67h
@@ -6846,7 +7061,7 @@
     jz echk2
     jmp emschk2
 emschk1:
-%endif
+endif
 	push es
 	mov	ax,3567h	;get interrupt vector 67h
 	int 21h
@@ -6863,7 +7078,8 @@
 echk1:
 	ret
 echk2:
-	mov	dx,emsnot
+	;mov	dx,emsnot
+	mov	dx,offset emsnot
 	jmp	prnquit		;print string and quit
 
 ;	HNDLSHOW - Print XS line giving the handle and pages allocated.
@@ -6876,13 +7092,16 @@
 ;	Uses	ax,cl,di.
 
 hndlshow:
-	mov	di,xsstr1b
+	;mov	di,xsstr1b
+	mov	di,offset xsstr1b
 	call hexword
 	mov	ax,dx
-	mov	di,xsstr1a
+	;mov	di,xsstr1a
+	mov	di,offset xsstr1a
 	call hexword
 	push	dx
-	mov	dx,xsstr1
+	;mov	dx,xsstr1
+	mov	dx,offset xsstr1
 	call	int21ah9	;print string
 	pop	dx
 	ret
@@ -6898,17 +7117,20 @@
 ;	Uses	AX, CX, DX, DI
 
 sumshow:
-	mov	di,xsstr3
+	;mov	di,xsstr3
+	mov	di,offset xsstr3
 	push di
 	call trimhex
 	xchg ax,dx		;mov ax,dx
-	mov	di,xsstr3a
+	;mov	di,xsstr3a
+	mov	di,offset xsstr3a
 	call trimhex
 	pop	dx			;mov dx,xsstr3
 	call int21ah9	;print string
 	mov	dx,bx
 	call int21ah9	;print string
-	mov	dx,xsstr4
+	;mov	dx,xsstr4
+	mov	dx,offset xsstr4
 	jmp	int21ah9	;print string and return
 
 ;	TRIMHEX - Print word without leading zeroes.
@@ -6926,7 +7148,7 @@
 tx1:
 	scasb
 	jne	tx2		;return if not a '0'
-	mov	byte [di-1],' '
+	mov	byte ptr [di-1],' '
 	loop tx1
 tx2:
 	ret
@@ -6935,7 +7157,8 @@
 
 error:
 	mov	cx,si
-	sub	cx,line_in+4
+	;sub	cx,line_in+4
+	sub	cx,offset line_in+4
 	add	cx,[promptlen]
 	cmp	cx,127
 	ja	err2		;if we're really messed up
@@ -6946,7 +7169,8 @@
 	int	21h
 	loop err1
 err2:
-	mov	dx,errcarat
+	;mov	dx,errcarat
+	mov	dx,offset errcarat
 	call int21ah9	;print string
 	jmp	[errret]
 
@@ -6954,12 +7178,12 @@
 
 freemem:
 	mov	[reg_cs],cs
-	mov	word [reg_ip],fmem2
-%if PM    
+	mov	word ptr [reg_ip],offset fmem2
+if PM eq 1    
 	xor ax,ax
     mov [regh_eip],ax
     mov [regh_esp],ax
-%endif    
+endif    
 	mov	[reg_ss],ss
 	push ax
 	mov	[reg_sp],sp	;save sp-2
@@ -6975,10 +7199,10 @@
 ;--- set debuggee's INT 23/24
 
 setint2324:
-%if PM
+if PM eq 1
 	call ispm
     jz	setint2324pm
-%endif    
+endif    
     push es
     push di
     push si
@@ -6986,32 +7210,34 @@
     xor di,di
     mov es,ax
     mov di,23h*4
-    mov si,run2324
+    mov si,offset run2324
     movsw
 	movsw
     movsw
     movsw
 
-%if PM
+if PM eq 1
 	call hook2f
-%endif
+endif
 
     pop si
     pop di
     pop es
     ret
-%if PM    
+if PM eq 1    
 setint2324pm:
 	push si
-	mov si,run2324
+	mov si,offset run2324
     mov bx,0223h
 si2324_0:
 	mov dx,[si+0]
-    cmp [dpmi32],byte 0
+    cmp byte ptr [dpmi32],byte ptr 0
     jz si2324_1
-    cpu 386
+    ;cpu 386
+.386p
     mov edx,[si+0]
-    cpu 8086
+    ;cpu 8086
+.8086
 si2324_1:
 	mov cx,[si+4]
     mov ax,205h
@@ -7022,7 +7248,7 @@
     jnz si2324_0
     pop si
     ret
-%endif
+endif
 
 ;	This is the routine that starts up the running program.
 
@@ -7034,14 +7260,16 @@
     
 	mov	[run_sp],sp	;save stack position
 	sub	sp,[spadjust]
-	mov	[SPSAV],sp
+	;mov	[SPSAV],sp
+	mov	word ptr ds:[SPSAV],sp
 	cli
-    cmp [machine],byte 3
+    cmp [machine],byte ptr 3
     jb  no386
-    cpu 386
+    ;cpu 386
+.386p
     mov fs,[reg_fs]
     mov gs,[reg_gs]
-    mov sp,regshi
+    mov sp, offset regshi
 	pop ebx			;pop hiwords eax+ebx
     shrd eax,ebx,16
 	pop edx			;pop hiwords ecx+edx
@@ -7049,9 +7277,10 @@
     pop ebp			;pop hiwords esp+ebp
 	pop edi			;pop hiwords esi+edi
     shrd esi,edi,16
-    cpu 8086
+    ;cpu 8086
+.8086
 no386:
-	mov	sp,regs
+	mov	sp, offset regs
 	pop	ax
 	pop	bx
 	pop	cx
@@ -7063,51 +7292,54 @@
 	pop	es  	;temporary load DS value into ES (to make sure it is valid)
 	pop	es		;now load the true value for ES
 	pop	ss
-    cmp byte [machine],3
+    cmp byte ptr [machine],3
     jnc doiretd
 	mov	sp,[reg_sp]	;restore program stack
-	mov [bInDbg],byte 0
-	push word [reg_fl]
-	push word [reg_cs]
-	push word [reg_ip]
-    test byte [reg_fl+1],2	;IF set?
+	mov [bInDbg],byte ptr 0
+	push word ptr [reg_fl]
+	push word ptr [reg_cs]
+	push word ptr [reg_ip]
+    test byte ptr [reg_fl+1],2	;IF set?
 	mov ds,[reg_ds]
     jz ifcleared16
     sti				;required for ring3 protected mode if IOPL==0
 ifcleared16:
 	iret			;jump to program
-    cpu 386
+    ;cpu 386
+.386p
 doiretd:    
     mov sp,[regh_esp]
     shl esp,16
 	mov	sp,[reg_sp]	;restore program stack
-	mov [bInDbg],byte 0
-	push word [regh_efl]
-	push word [reg_fl]
+	mov [bInDbg],byte ptr 0
+	push word ptr [regh_efl]
+	push word ptr [reg_fl]
     push 0
-	push word [reg_cs]
-	push word [regh_eip]
-	push word [reg_ip]
-    test byte [reg_fl+1],2	;IF set?
+	push word ptr [reg_cs]
+	push word ptr [regh_eip]
+	push word ptr [reg_ip]
+    test byte ptr [reg_fl+1],2	;IF set?
 	mov ds,[reg_ds]
     jz ifcleared32
     sti				;required for ring3 protected mode if IOPL==0
 ifcleared32:    
 	iretd
-    cpu 8086
+    ;cpu 8086
+.8086
 
 ;	Interrupt 22 (program termination) handler.
 
 int22:
 	cli
-	mov	word [cs:run_int],progtrm	;remember interrupt type
-	mov	word [cs:lastcmd],dmycmd
-%if PM
+	;mov	word ptr [cs:run_int],progtrm	;remember interrupt type
+	mov	word ptr [cs:run_int],offset progtrm	;remember interrupt type
+	mov	word ptr [cs:lastcmd],offset dmycmd
+if PM eq 1
 	mov sp,[cs:InDosSegm]
-    mov word [cs:pInDOS+2],sp
+    mov word ptr [cs:pInDOS+2],sp
 	mov sp,[cs:SDASegm]
-    mov word [cs:pSDA+2],sp
-%endif
+    mov word ptr [cs:pSDA+2],sp
+endif
     mov sp,cs
     mov ss,sp
 	jmp	intrtn1		;jump to register saving routine (sort of)
@@ -7115,19 +7347,22 @@
 ;	Interrupt 0 (divide error) handler.
 
 intr0:	
-	mov	word [cs:run_int],int0msg	;remember interrupt type
+	;mov	word ptr [cs:run_int],int0msg	;remember interrupt type
+	mov	word ptr [cs:run_int],offset int0msg	;remember interrupt type
 	jmp	intrtn		;jump to register saving routine
 
     
 ;	Interrupt 1 (single-step interrupt) handler.
 
-intr1:	mov	word [cs:run_int],int1msg	;remember interrupt type
+;intr1:	mov	word ptr [cs:run_int],int1msg	;remember interrupt type
+intr1:	mov	word ptr [cs:run_int],offset int1msg	;remember interrupt type
 	jmp	intrtn		;jump to register saving routine
     
 ;	Interrupt 3 (breakpoint interrupt) handler.
 
 intr3:
-	mov	word [cs:run_int],int3msg	;remember interrupt type
+	;mov	word ptr [cs:run_int],int3msg	;remember interrupt type
+	mov	word ptr [cs:run_int],offset int3msg	;remember interrupt type
     
 ;	Common interrupt routine.
 
@@ -7135,21 +7370,25 @@
 
 intrtn:
 	cli						;just in case
-	pop	word [cs:reg_ip]	;recover things from stack
-	pop	word [cs:reg_cs]
-	pop	word [cs:reg_fl]
+	pop	word ptr [cs:reg_ip]	;recover things from stack
+	pop	word ptr [cs:reg_cs]
+	pop	word ptr [cs:reg_fl]
 	mov	[cs:reg_ss],ss		;save stack position
 	mov	[cs:reg_sp],sp
-	cmp [cs:machine],byte 3
+	cmp 	[cs:machine],byte ptr 3
     jb nohiesp
-    cpu 386
+    ;cpu 386
+;.386p
+.386
     shr esp,16
     mov [cs:regh_esp],sp
-    cpu 8086
+    ;cpu 8086
+.8086
 nohiesp:    
 	mov	sp,cs				;mov ss,cs
 	mov	ss,sp
-	mov	sp,reg_ss
+	;mov	sp, reg_ss ; ???
+	mov	sp, offset reg_ss
 intrtn2:			;<--- entry protected-mode
 	push es
 	push ds
@@ -7163,20 +7402,22 @@
 	push bx
 	push ax
 
-	cmp [cs:machine],byte 3
+	cmp [cs:machine],byte ptr 3
     jb no386_1
-    cpu 386
-	mov		sp,reg_gs+2
+    ;cpu 386
+;.386p
+.386
+	mov	sp, offset reg_gs+2
     push	gs
     push	fs
 
-	mov		sp,regh_edi+2
+	mov	sp, offset regh_edi+2
 
 ;--- regh_edi+2 is dword aligned, so DWORD pushs are safe here
 
     pushfd
     pop ax		;skip LoWord(EFL)
-    pop word [ss:regh_efl]
+    pop word ptr [ss:regh_efl]
     
     push 0
     pushf
@@ -7198,7 +7439,8 @@
     pop		ax
     shr		eax,16
     push	ax
-    cpu 8086
+    ;cpu 8086
+.8086
 no386_1:
 
 intrtn1:
@@ -7221,15 +7463,18 @@
     pop es
 	mov	bx,cs
     call setpsp				;set PSP of debugger
-	and	word [reg_fl],~100h	;clear single-step interrupt
+	;and	word ptr [reg_fl],~100h	;clear single-step interrupt
+	and	word ptr [reg_fl],not 100h	;clear single-step interrupt
 
     
-	mov [bInDbg],byte 1
-	cmp	word [cs:run_int],progtrm
+	mov [bInDbg],byte ptr 1
+	;cmp	word ptr [cs:run_int],progtrm
+	cmp	word ptr [cs:run_int],offset progtrm
     jnz isnotterm
     mov ah,4Dh
     int 21h
-    mov di,progexit
+    ;mov di,progexit
+    mov di,offset progexit
     call hexword
 isnotterm:
 	ret
@@ -7240,10 +7485,10 @@
 ;--- set debugger's interrupt vectors 23/24
 
 getint2324:
-%if PM
+if PM eq 1
 	call ispm
     jz	getint2324pm
-%endif
+endif
 	push si
     push di
     push es
@@ -7252,7 +7497,7 @@
     pop es
     xor di,di
     mov ds,di
-    mov di,run2324
+    mov di,offset run2324
     mov si,23h*4
     push si
     movsw       ;save interrupt vector 23h
@@ -7274,34 +7519,38 @@
     pop di
     pop si
     ret
-%if PM    
+if PM eq 1    
 getint2324pm:
     push di
-    mov di,run2324
+    mov di,offset run2324
     call getcurrI2324
     pop di
 ;    call setdbgI2324
 ;    ret
 
-	cpu 286    
+	;cpu 286    
+.286p
 setdbgI2324:
 	pusha
-	mov si,dbg2324
+	mov si, offset dbg2324
     mov bx,0223h
 sdbg2324_0:
 	lodsw
 	mov dx,ax
 	mov cx,cs
     mov ax,205h
-    cmp [dpmi32],byte 0
+    ;cmp [dpmi32],byte ptr 0
+    cmp byte ptr [dpmi32],byte ptr 0
     jz sdbg2324_1
-    cpu 386
+    ;cpu 386
+.386p
     push edx
     movzx edx,dx
     int 31h
     pop edx
     jmp sdbg2324_2
-    cpu 286
+    ;cpu 286
+.286p
 sdbg2324_1:
     int 31h
 sdbg2324_2:    
@@ -7310,7 +7559,8 @@
     jnz sdbg2324_0
     popa
     ret
-	cpu 8086
+	;cpu 8086
+.8086
 
 getcurrI2324:
     mov bx,0223h
@@ -7319,11 +7569,14 @@
     int 31h
 	mov	[di+0],dx
 	mov	[di+4],cx
-    cmp [dpmi32],byte 0
+    ;cmp [dpmi32],byte ptr 0
+    cmp byte ptr [dpmi32],byte ptr 0
     jz  gi2324_1
-    cpu 386
+    ;cpu 386
+.386p
     mov [di+0],edx
-    cpu 8086
+    ;cpu 8086
+.8086
 gi2324_1:
     add di,6
     inc bl
@@ -7332,7 +7585,7 @@
 	ret
 
 
-%endif
+endif
 
 ;	The next three subroutines concern the handling of INT 23 and 24.
 ;	These interrupt vectors are saved and restored when running the
@@ -7349,27 +7602,28 @@
 ;	Entry	es = cs
 
 prephack:
-	cmp	byte [hakstat],0
+	cmp	byte ptr [hakstat],0
 	jnz	ph_err		;if hack status error
 	push di
-	mov	di,sav2324	;debugger's Int2324
+	mov	di, offset sav2324	;debugger's Int2324
     call prehak1
     pop di
     ret
 ph_err:
 	push ax
 	push dx
-	mov	dx,ph_msg
+	;mov	dx,ph_msg
+	mov	dx,offset ph_msg
 	call int21ah9	;print string |||
 	pop	dx
 	pop	ax
 	ret
 
 prehak1:
-%if PM
+if PM eq 1
 	call ispm
     jz prehak_pm	;nothing to do
-%endif    
+endif    
     push ds
     push si
 	xor	si,si
@@ -7395,30 +7649,30 @@
 
 dohack:
 	push si
-	mov	byte [hakstat],1
-	mov	si,run2324	;debuggee's interrupt vectors
-%if PM
+	mov	byte ptr [hakstat],1
+	mov	si,offset run2324	;debuggee's interrupt vectors
+if PM eq 1
 	call ispm
     jz dohack_pm
-%endif    
+endif    
 	jmp	hak1
 
-%if PM
+if PM eq 1
 restdbgi2324:
     push ss
     pop es
 	call setdbgI2324	
     ret
-%endif
+endif
 
 unhack:
-	mov	byte [hakstat],0
-%if PM
+	mov	byte ptr [hakstat],0
+if PM eq 1
 	call ispm
     jz restdbgi2324
-%endif
+endif
 	push si
-	mov	si,sav2324	;debugger's interrupt vectors
+	mov	si, offset sav2324	;debugger's interrupt vectors
 hak1:
     push di
 	xor	di,di
@@ -7434,12 +7688,13 @@
     pop es
 hak_ex:
 	ret
-%if PM
+if PM eq 1
 
 ;--- set debuggee's int 23/24 pmode
 
 dohack_pm:
-	cpu 286
+	;cpu 286
+.286p
 	push ss
     pop es
 	pusha
@@ -7448,15 +7703,18 @@
     mov dx,[si+0+0]
     mov cx,[si+0+4]
 	mov ax,205h
-    cmp [dpmi32],byte 0
+    ;cmp [dpmi32],byte ptr 0
+    cmp byte ptr [dpmi32],byte ptr 0
     jz dhpm_1
-    cpu 386
+    ;cpu 386
+.386p
     push edx
     mov edx,[si+0+0]
     int 31h
     pop edx
     jmp dhpm_2
-	cpu 286
+	;cpu 286
+.286p
 dhpm_1:
     int 31h
 dhpm_2:    
@@ -7467,14 +7725,15 @@
     popa
     pop si
     ret
-    cpu 8086
-%endif
+    ;cpu 8086
+.8086
+endif
 
 InDos:    
 	push ds
 	push si
     lds si,[pInDOS]
-    cmp byte [si],0
+    cmp byte ptr [si],0
     pop si
     pop ds
     ret
@@ -7512,7 +7771,7 @@
     call stdout
 	popf
 	jc gl5		;if tty input
-    mov word [lastcmd],dmycmd
+    mov word ptr [lastcmd],offset dmycmd
 
 ;	This part reads the input line from a file (in the case of
 ;	`debug < file').  It is necessary to do this by hand because DOS
@@ -7535,7 +7794,8 @@
 	call fillbuf
 	jnc	gl1		;if we have more characters
 	mov	al,LF
-	cmp	di,line_in+LINE_IN_LEN
+	;cmp	di,line_in+LINE_IN_LEN
+	cmp	di,offset line_in+LINE_IN_LEN
 	jb	gl4
 	dec	si
 	dec	di
@@ -7545,13 +7805,15 @@
 	mov	al,CR
 	stosb
 	mov	cx,di
-	mov	dx,line_in + 2
+	;mov	dx,line_in + 2
+	mov	dx,offset line_in + 2
 	sub	cx,dx
     call stdout	;print out the received line
 	jmp	gl6		;done
 
 gl5:
-	mov	dx,line_in
+	;mov	dx,line_in
+	mov	dx,offset line_in
     call InDos
     jnz rawinput
 	mov	ah,0ah		;buffered keyboard input
@@ -7559,7 +7821,8 @@
 gl6:
 	mov al,10
     call stdoutal
-	mov	si,line_in + 2
+	;mov	si,line_in + 2
+	mov	si,offset line_in + 2
 	call skipwhite
 	ret
 stdoutal:
@@ -7601,7 +7864,7 @@
 	sub di,dx
     mov ax,di
     mov di,dx
-    mov byte [di-1],al
+    mov byte ptr [di-1],al
     dec dx
     dec dx
     pop di
@@ -7627,20 +7890,21 @@
 ;	If the input is from a tty, then bufsetup returns with carry set.
 
 bufsetup:
-	cmp	byte [notatty],0
+	cmp	byte ptr [notatty],0
 	jnz	bs1		;if not a tty
 	stc
 	ret
 
-bs1:	mov	di,line_in+2
+;bs1:	mov	di,line_in+2
+bs1:	mov	di,offset line_in+2
 	mov	si,[bufnext]
 	cmp	si,[bufend]
 	jb	bs2		;if there's a character already
 	call	fillbuf
 	jc	bs4		;if eof
-bs2:	cmp	byte [notatty],CR
+bs2:	cmp	byte ptr [notatty],CR
 	jne	bs3		;if nothing more to do
-	cmp	byte [si],LF
+	cmp	byte ptr [si],LF
 	jne	bs3		;if not a line feed
 	inc	si		;skip it
 bs3:	clc
@@ -7663,7 +7927,8 @@
 	mov	si,di		;we know this already
 	mov	ah,3fh		;read from file
 	xor	bx,bx
-	mov	cx,line_in+LINE_IN_LEN
+	;mov	cx,line_in+LINE_IN_LEN
+	mov	cx,offset line_in+LINE_IN_LEN
 	mov	dx,di
 	sub	cx,dx
 	jz	fb1			;if no more room
@@ -7700,29 +7965,32 @@
 	xor	cx,cx
 	call getrange	;get address range into bx:(e)dx bx:(e)cx
 	push bx			;save segment first address
-%if PM
-	cmp byte [bAddr32],0
+if PM eq 1
+	cmp byte ptr [bAddr32],0
     jz  pc_0
-    cpu 386
+    ;cpu 386
+.386p
     sub ecx,edx
     push edx		;save offset first address
     push ecx
     jmp pc_01
-    cpu 8086
+    ;cpu 8086
+.8086
 pc_0:    
-%endif
+endif
 	sub	cx,dx		;number of bytes minus one
 	push dx
 	push cx
 pc_01:    
 	call skipcomm0
 	mov	bx,[reg_ds]
-%if PM
-	cmp byte [bAddr32],0
+if PM eq 1
+	cmp byte ptr [bAddr32],0
     jz  pc_1
-    cpu 386
+    ;cpu 386
+.386p
 	call getaddr			;get address into bx:(e)dx
-    mov byte [bAddr32],1	;restore bAddr32
+    mov byte ptr [bAddr32],1	;restore bAddr32
     pop ecx
     mov edi,ecx
     add edi,edx
@@ -7733,9 +8001,10 @@
     pop esi
     pop ds
     ret
-    cpu 8086
+    ;cpu 8086
+.8086
 pc_1:    
-%endif
+endif
 	call getaddr	;get destination address into bx:(e)dx
 	pop	cx
 	mov	di,cx
@@ -7781,9 +8050,9 @@
 packet	dw	0,0	;sector number
 	dw	0		;number of sectors to read
 	dw	0,0		;transfer address SSSS:OOOO
-%if PM
+if PM eq 1
 	dw 0		;transfer address might be SSSS:OOOOOOOO!
-%endif
+endif
 usepacket db	0
 
 parselw:
@@ -7821,7 +8090,7 @@
 	inc	dx
 	mov	cx,dx
 	call chkeol		;expect end of line
-	cmp	byte [usepacket],0
+	cmp	byte ptr [usepacket],0
 	jnz	plw3		;if new-style packet called for
 	pop	si			;in case of error
 	pop	dx			;get LoWord starting logical sector number 
@@ -7839,29 +8108,32 @@
 
 plw3:	
 	pop	bx			;discard si
-	mov	bx,packet
-	pop	word [bx+0]	;LoWord sector number
-	pop	word [bx+2]	;HiWord sector number
+	mov	bx, offset packet
+	pop	word ptr [bx+0]	;LoWord sector number
+	pop	word ptr [bx+2]	;HiWord sector number
 	mov	[bx+4],cx	;number of sectors
 	pop	ax			;drive number
-	pop	word [bx+6]	;transfer address ofs
+	pop	word ptr [bx+6]	;transfer address ofs
     pop dx
 	xor	cx,cx
-%if PM
+if PM eq 1
 	call ispm
     jnz plw3_1
-	cmp byte [dpmi32],0
+	cmp byte ptr [dpmi32],0
     jz plw3_1
-    cpu 386
+    ;cpu 386
+.386p
     mov [bx+10],dx	;save segment of transfer buffer
     movzx ebx,bx
     shr edx,16		;get HiWord(offset)
-    cmp [bAddr32],byte 1
+    ;cmp [bAddr32],byte ptr 1
+    cmp byte ptr [bAddr32],byte ptr 1
     jz plw3_1
     xor dx,dx
-    cpu 8086
+    ;cpu 8086
+.8086
 plw3_1:
-%endif
+endif
 	mov	[bx+8],dx	;transfer address seg
 	dec	cx			;set nonzero flag and make cx = -1
 	ret
@@ -7896,24 +8168,27 @@
 ;	Uses AH,BX,CX,DX.
 
 parseql:
-	mov	byte [eqflag],0	;mark `=' as absent
+	mov	byte ptr [eqflag],0	;mark `=' as absent
 	cmp	al,'='
 	jne	peq1		;if no `=' operand
 	call skipwhite
 	mov	bx,[reg_cs]	;default segment
 	call getaddrX	;get the address into bx:(e)dx
 	mov	[eqladdr+0],dx
-%if PM
-    mov word [eqladdr+2],0
-	cmp byte [bAddr32],0
+if PM eq 1
+    mov word ptr [eqladdr+2],0
+	cmp byte ptr [bAddr32],0
     jz nohighofs
-    cpu 386
-    mov [eqladdr],edx
-    cpu 8086
+    ;cpu 386
+.386p
+    ;mov [eqladdr],edx
+    mov dword ptr [eqladdr],edx
+    ;cpu 8086
+.8086
 nohighofs:    
-%endif
+endif
 	mov	[eqladdr+4],bx
-	inc	byte [eqflag]
+	inc	byte ptr [eqflag]
 peq1:	
 	ret
 
@@ -7923,7 +8198,7 @@
 ;	Uses AX.
 
 seteq:
-	cmp	byte [eqflag],0
+	cmp	byte ptr [eqflag],0
 	jz	seq1		;if no `=' operand
 	mov	ax,[eqladdr+0]
 	mov	[reg_ip],ax
@@ -7931,24 +8206,25 @@
 	mov	[regh_eip],ax
 	mov	ax,[eqladdr+4]
 	mov	[reg_cs],ax
-	mov	byte [eqflag],0	;clear the flag
+	mov	byte ptr [eqflag],0	;clear the flag
 seq1:
 	ret
 
 ;--- get a valid offset for segment in BX
 
 getofsforbx:
-%if PM
+if PM eq 1
 	call	ispm
     jnz		gofbx_2
-    cmp		byte [machine],3
+    cmp		byte ptr [machine],3
     jb		gofbx_2
-    cpu 386
+    ;cpu 386
+.386p
     push	ax	;needed?
     call	getattrhigh
     pop		ax
     jz		gofbx_2
-    mov		byte [bAddr32],1
+    mov		byte ptr [bAddr32],1
     push	bx
     call	getdword
     push	bx
@@ -7956,25 +8232,28 @@
     pop		edx
     pop		bx
     ret
-    cpu 8086
+    ;cpu 8086
+.8086
 gofbx_2:    
-%endif
+endif
 	call getword
 	ret
 
-errorj10: jmp error
+errorj10:
+       jmp error
 
 ;--- a range is entered with the L/ength argument
 ;--- get a valid length for segment in BX
 ;--- L=0 means 64 kB (at least in 16bit mode)
 
 getlenforbx:    
-%if PM
+if PM eq 1
 	call ispm
     jnz	glfbx_1
-    cmp byte [machine],3
+    cmp byte ptr [machine],3
     jb glfbx_1
-    cpu 386
+    ;cpu 386
+.386p
     push	ecx
     lar		ecx,ebx
     test	ecx,400000h	;is segment 32bit?
@@ -7993,9 +8272,10 @@
     dec ecx
     add ecx, edx
     ret
-    cpu 8086
+    ;cpu 8086
+.8086
 glfbx_1:
-%endif
+endif
 	push dx
 	call getword
 	mov	cx,dx
@@ -8036,17 +8316,18 @@
 	pop	si			;restore si and cx
 	pop	cx
 	jcxz errorj10	;if a range is mandatory
-%if PM    
-	cmp byte [bAddr32],0	;can be 1 only on a 80386+
+if PM eq 1    
+	cmp byte ptr [bAddr32],0	;can be 1 only on a 80386+
     jz gr0
-    cpu 386
+    ;cpu 386
+.386p
 	dec	ecx
 	add	ecx,edx
 	jnc	gr1			;if no wraparound
 	or	ecx,-1		;go to end of segment
     jmp gr1
 gr0:
-%endif    
+endif    
 	dec	cx
 	add	cx,dx
 	jnc	gr1			;if no wraparound
@@ -8061,10 +8342,11 @@
 	cmp	al,'l'
 	je	gr3			;if a range is given
 ;	call skipwh0	;get next nonblank
-%if PM
-    cmp byte [machine],3
+if PM eq 1
+    cmp byte ptr [machine],3
     jb gr2_1
-    cpu 386
+    ;cpu 386
+.386p
 	push edx
 	call getofsforbx
 	mov	ecx,edx
@@ -8072,9 +8354,10 @@
     cmp edx,ecx
     ja errorj2
     jmp gr4
-    cpu 8086
+    ;cpu 8086
+.8086
 gr2_1:
-%endif
+endif
 	push dx
 	call getword
 	mov	cx,dx
@@ -8106,18 +8389,18 @@
 	call verifysegm	;make BX a writeable segment
     ret
 
-%if PM==0
+if PM eq 0
 errorj2:jmp	error
-%endif
+endif
 
 ; getaddrX differs from getaddr in that BX is not ensured
 ; to be writeable in pmode
 
 getaddrX:
 getaddr_1:
-%if PM
-	mov byte [bAddr32],0
-	cmp		byte [si-1],'$' ;a real-mode segment?
+if PM eq 1
+	mov byte ptr [bAddr32],0
+	cmp byte ptr [si-1],'$' ;a real-mode segment?
     jnz 	ga1_1
 	lodsb
 	call	ispm
@@ -8133,7 +8416,7 @@
     pop		ax
     jmp		ga1_2
 errorj2:jmp	error
-%endif
+endif
 ga1_1:
 	call	getofsforbx
 ga1_2:
@@ -8202,16 +8485,16 @@
 	push ax
     push di
     push cx
-    mov di,regnames
+    mov di, offset regnames
     mov cx,16
 	mov ah,[si]
     and ax,TOUPPER_W
-    cmp byte [si+1],'A'
+    cmp byte ptr [si+1],'A'
     jnc maybenotasymbol
     repnz scasw
     jnz notasymbol
     xor bx,bx
-	sub	di,regnames+2
+	sub	di, offset regnames+2
 getsymlow:    
 	mov	dx,[regs+di]
 	inc	si		;skip over second char
@@ -8226,7 +8509,7 @@
     mov al,[si+1]
     xchg al,ah
     and ax,TOUPPER_W
-    cmp ax,"IP"
+    cmp ax,"PI"
     jnz isnoteip
     mov di,14*2
     jmp iseip
@@ -8234,7 +8517,7 @@
     mov cx,8
     repnz scasw
     jnz notasymbol
-    sub di,regnames+2
+    sub di, offset regnames+2
 iseip:    
     mov bx,[regshi+di]
     inc si
@@ -8415,17 +8698,16 @@
 ;	Jump table for OP_IMM, OP_RM, OP_M, OP_R_MOD, OP_MOFFS, OP_R, OP_R_ADD,
 ;	and OP_AX.
 
-disjmp2	dw	dop01,dop04,dop29,dop29a,dop30,dop32,dop36,dop37
+disjmp2	dw	offset dop01,offset dop04,offset dop29,offset dop29a,offset dop30,offset dop32,offset dop36,offset dop37
 
 ;   jump table for displaying operands
 ;   must be in the order of OP_M64 ..
 
-optab
-	dw	dop38,dop38a,dop38b,dop39,dop42,dop41
-	dw	dop43,dop46,dop47,dop49,dop51,dop52
-	dw	dop53,dop54,dop56,dop58,dop59,dop59e,dop60
+optab	dw	offset dop38,offset dop38a,offset dop38b,offset dop39,offset dop42,offset dop41
+	dw	offset dop43,offset dop46,offset dop47,offset dop49,offset dop51,offset dop52
+	dw	offset dop53,offset dop54,offset dop56,offset dop58,offset dop59,offset dop59e,offset dop60
     
-	db	'1',0,'3',0,'DXCLSTCSDSESFSGSSS'	;simple strings
+	db	'1',0,'3',0,'DXCLSTCSDSESFSGSSS'	;simple strings ; ???
 
 OP_STR	equ	OP_1		;first string entry
 
@@ -8471,12 +8753,12 @@
 
 ;	Jump table for a certain place.
 
-disjmp	dw	disbad	;illegal instruction
-	dw	da6			;two byte instruction
-	dw	da7			;instruction group
-	dw	da8			;coprocessor instruction
-	dw	da9			;coprocessor instruction group
-	dw	da10		;instruction prefix (including 66h/67h)
+disjmp	dw	offset disbad		;illegal instruction
+	dw	offset da6		;two byte instruction
+	dw	offset da7		;instruction group
+	dw	offset da8		;coprocessor instruction
+	dw	offset da9		;coprocessor instruction group
+	dw	offset da10		;instruction prefix (including 66h/67h)
 
 ;	Table for 16-bit mod r/m addressing.  8 = BX, 4 = BP, 2 = SI, 1 = DI.
 
@@ -8485,12 +8767,12 @@
 ;	Tables of register names.
 ;	rgnam816/rgnam16/segrgnam/xregnam must be consecutive.
 
-rgnam816	dw 'AL','CL','DL','BL','AH','CH','DH','BH'
-rgnam16		dw 'AX','CX','DX','BX','SP','BP','SI','DI'
-segrgnam	dw 'ES','CS','SS','DS','FS','GS'
-xregnam		dw 'ST','MM','CR','DR','TR'
-sizetcnam	dw 'BY','WO','WO','DW','QW','FL','DO','TB','SH','LO','NE','FA'
-segrgaddr	dw reg_es,reg_cs,reg_ss,reg_ds
+rgnam816	dw 'LA','LC','LD','LB','HA','HC','HD','HB'
+rgnam16		dw 'XA','XC','XD','XB','PS','PB','IS','ID'
+segrgnam	dw 'SE','SC','SS','SD','SF','SG'
+xregnam		dw 'TS','MM','RC','RD','RT'
+sizetcnam	dw 'YB','OW','OW','WD','WQ','LF','OD','BT','HS','OL','EN','AF'
+segrgaddr	dw offset reg_es,offset reg_cs,offset reg_ss,offset reg_ds
 
 ;	Tables for handling of named prefixes.
 
@@ -8501,11 +8783,11 @@
 disasm:
 	mov	[savesp2],sp
     xor ax,ax
-	mov	word [dis_n],ax
-	mov	word [preflags],ax	;clear preflags and preused
-%if PM	  
+	mov	word ptr [dis_n],ax
+	mov	word ptr [preflags],ax	;clear preflags and preused
+if PM eq 1	  
 	mov [bCSAttr],al
-	cmp byte [machine],3
+	cmp byte ptr [machine],3
 	jb	disasm_1
 	call ispm
 	jnz disasm_1
@@ -8513,13 +8795,14 @@
 	call getattrhigh
 	mov [bCSAttr],ah
 	jz disasm_1
-	or byte [preflags], PRE32D | PRE32A
-;	or byte [preused], PRE32D | PRE32A
+	;or byte ptr [preflags], PRE32D | PRE32A
+	or byte ptr [preflags], PRE32D or PRE32A
+;	or byte ptr [preused], PRE32D | PRE32A
 disasm_1:
-%endif
-	mov	byte [segmnt],3		;initially use DS segment
-	mov	byte [rmsize],80h	;don't display any memory
-	mov	word [dismach],0	;no special machine needed, so far
+endif
+	mov	byte ptr [segmnt],3		;initially use DS segment
+	mov	byte ptr [rmsize],80h	;don't display any memory
+	mov	word ptr [dismach],0	;no special machine needed, so far
 	call disgetbyte			;get a byte of the instruction
 	cmp	al,9bh				;wait instruction (must be the first prefix)
 	jne	da2					;if not
@@ -8531,7 +8814,7 @@
 ;	instead.  We'll catch it later if the wait instruction is not going to
 ;	be part of a shared mnemonic.
 
-	or	byte [preflags],PREWAIT
+	or	byte ptr [preflags],PREWAIT
 
 ;	If we've found a prefix, we return here for the actual instruction
 ;	(or another prefix).
@@ -8592,8 +8875,8 @@
 ;	Coprocessor instruction.
 
 da8:
-	or	byte [disflags],DIS_I_SHOWSIZ
-	or	byte [dmflags],DM_COPR
+	or	byte ptr [disflags],DIS_I_SHOWSIZ
+	or	byte ptr [dmflags],DM_COPR
 	call getregmem
 	cmp	al,0c0h
 	jb	da7		;range 00-bfh is same as an instruction group
@@ -8616,18 +8899,20 @@
 ;	Instruction prefix.  At this point, bl = prefix bits; bh = segment
 
 da10:	
-%if 1
+if 1
 	mov al,bl
-    and bl,~(PRE32D | PRE32A)	;these flags are XORed!
-%endif
+    ;and bl,~(PRE32D | PRE32A)	;these flags are XORed!
+    and bl,not (PRE32D or PRE32A)	;these flags are XORed!
+endif
 	test bl,[preflags]
 	jnz	da12		;if there are duplicates
     or [preflags],bl
-%if 1
+if 1
     mov bl,al
-    and al,PRE32D | PRE32A
+    ;and al,PRE32D | PRE32A
+    and al,PRE32D or PRE32A
     xor [preflags],al
-%endif    
+endif    
 	test bl,PRESEG
 	jz	da11		;if not a segment
 	mov	[segmnt],bh	;save the segment
@@ -8644,16 +8929,17 @@
 da13:
 	push si
 	lea	si,[mnlist+bx]	;offset of mnemonic
-	cmp	si,mnlist+MNEM_BSWAP
+	cmp	si, offset mnlist+MNEM_BSWAP
 	jne	da13a			;if not BSWAP
 	call dischk32d
 	jz	da12			;if no operand-size prefix
 da13a:
 	call showop			;print out the op code (at line_out+28)
-	mov	word [sizeloc],0;clear out this flag
+	mov	word ptr [sizeloc],0;clear out this flag
 	pop	si				;recover list of operands
-	add	si,oplists-OPTYPES_BASE
-	cmp	byte [si],0
+	;add	si,oplists-OPTYPES_BASE
+	add	si,offset oplists-OPTYPES_BASE
+	cmp	byte ptr [si],0
 	je	da21			;if we're done
 
 ;	Loop over operands.  [si] = pointer to next operand type.
@@ -8661,20 +8947,20 @@
 ;	order as they appear in the disassembly output.
 
 da14:
-	mov	byte [disflags2],0	;clear out size-related flags
+	mov	byte ptr [disflags2],0	;clear out size-related flags
 	lodsb					;get the operand type
 	cmp	al,OP_SIZE
 	jb	da18				;if it's not size dependent
-	mov	byte [disflags2],DIS_I_KNOWSIZ	;indicate variable size
+	mov	byte ptr [disflags2],DIS_I_KNOWSIZ	;indicate variable size
 	cmp	al,OP_8
 	jae	da16		;if the size is fixed
 	cmp	al,OP_1632
 	jae	da15		;if word or dword
 	mov	ah,-1
-	test byte [instru],1
+	test byte ptr [instru],1
 	jz	da17		;if byte
 da15:
-	or	byte [preused],PRE32D	;mark this flag as used
+	or	byte ptr [preused],PRE32D	;mark this flag as used
 	mov	ah,[preflags]
 	and	ah,PRE32D	;this will be >0 for dword, =0 for word
 	jmp	da17		;done
@@ -8710,7 +8996,7 @@
 	call [optab+bx-2]	;otherwise, do something else
 
 da20:
-	cmp	byte [si],0
+	cmp	byte ptr [si],0
 	jz	da21		;if we're done
 	mov	al,','
 	stosb
@@ -8727,21 +9013,21 @@
 	jmp	da28		;if all flags were used
 da22:
 	mov	cx,N_WTAB
-	mov	bx,wtab1
+	mov	bx,offset wtab1
 	mov	dx,2*N_WTAB-2
 	mov	ah,PREWAIT
 	test al,ah
 	jnz	da23		;if there's a WAIT prefix hanging
 
 	mov	cx,N_LTAB
-	mov	bx,ltab1
+	mov	bx,offset ltab1
 	mov	dx,2*N_LTAB-2
 	mov	ah,PRE32D
 	test al,ah
 	jnz da23		;if it's not a 32-bit prefix that's hanging
 
 	mov	cx,N_LTABX
-	mov	bx,ltab1X
+	mov	bx,offset ltab1X
 	mov	dx,2*N_LTABX-2
 	mov	ah,PRE32A
 	test al,ah
@@ -8759,18 +9045,19 @@
 	jne	da23_1		;if not found in the list
 	add	di,dx		;replace the mnemonic with the 32-bit name
 	mov	si,[di]
-	add	si,mnlist
+	add	si, offset mnlist
 	call showop		;copy op mnemonic
 da23_0:    
 	pop	di
 	jmp	da21
 da23_1:
-%if PM
-	test bl,PRE32A | PRE32D	;is a 66/67 prefix unhandled?
+if PM eq 1
+	;test bl,PRE32A | PRE32D	;is a 66/67 prefix unhandled?
+	test bl,PRE32A or PRE32D	;is a 66/67 prefix unhandled?
     jz disbad2
-	test byte [bCSAttr],40h	;32bit code segment?
+	test byte ptr [bCSAttr],40h	;32bit code segment?
     jnz da23_0   			;then ignore those. 
-%endif    
+endif    
 disbad2:
 	jmp	disbad
 
@@ -8782,7 +9069,8 @@
 	jnz	disbad2		;if index > 256
 	push di
 	mov	cx,P_LEN
-	mov	di,prfxtab
+	;mov	di,prfxtab
+	mov	di,offset prfxtab
 	repne scasb
 	pop	di
 	jne	disbad2		;if it's not on the list
@@ -8794,7 +9082,7 @@
 	mov	al,':'
 	stosb
 	pop	di
-	or	byte [preused],PRESEG	;mark it as used
+	or	byte ptr [preused],PRESEG	;mark it as used
 	jmp	da21
 
 da25:
@@ -8807,19 +9095,20 @@
 	jnz	disbad2		;if not in the first 256 bytes
 	and	al,0feh		;clear the low bit
 	push di
-	mov	di,replist
+	;mov	di,replist
+	mov	di,offset replist
 	mov	cx,5
 	repne scasb
-	mov	si,mnlist+MNEM_REP
+	mov	si, offset mnlist+MNEM_REP
 	je	da27		;if one of the REP instructions
 	inc	cx
 	inc	cx
 	repne scasb
 	jne	disbad2		;if not one of the REPE/REPNE instructions
-	mov	si,mnlist+MNEM_REPE
-	test byte [preused],PREREPZ
+	mov	si, offset mnlist+MNEM_REPE
+	test byte ptr [preused],PREREPZ
 	jnz	da27		;if REPE
-	mov	si,mnlist+MNEM_REPNE
+	mov	si, offset mnlist+MNEM_REPNE
 	jmp	da27		;it's REPNE
 
 disbad3:
@@ -8830,14 +9119,14 @@
 	jz	disbad3		;if not a lock prefix, either
 	push di
 	mov	ax,[index]
-	mov	di,locktab
+	mov	di,offset locktab
 	mov	cx,N_LOCK
 	repne scasw
 	jne	disbad3		;if not in the approved list
-	test byte [preused],PRESEG
+	test byte ptr [preused],PRESEG
 	jz	disbad3		;if memory was not accessed
-	mov	si,mnlist+MNEM_LOCK
-	or	byte [preused],PRELOCK
+	mov	si, offset mnlist+MNEM_LOCK
+	or	byte ptr [preused],PRELOCK
 
 ;	Slip in another mnemonic.  SI = offset of mnemonic, what should be
 ;	DI is on the stack.
@@ -8886,13 +9175,13 @@
 	call hexword
 	mov	al,':'
 	stosb
-%if PM    
-    test byte [bCSAttr],40h
+if PM eq 1    
+    test byte ptr [bCSAttr],40h
     jz isnot32bit
 	mov	ax,[u_addr+2]
 	call hexword
 isnot32bit:    
-%endif    
+endif    
 	mov	ax,[u_addr]
 	call hexword
 	mov	al,' '
@@ -8927,10 +9216,11 @@
 	rep	stosb
 da30_1:    
 	pop	di
-	test byte [disflags],DIS_I_UNUSED
+	test byte ptr [disflags],DIS_I_UNUSED
 	jz	da32		;if we don't print ` (unused)'
-	mov	si,unused
-	cmp	byte [di-1],' '
+	;mov	si,unused
+	mov	si,offset unused
+	cmp	byte ptr [di-1],' '
 	jne	da31		;if there's already a space here
 	inc	si
 da31:
@@ -8940,7 +9230,7 @@
 
 da32:
 	push di
-	mov	di,index+2
+	mov	di,offset index+2
 	call showmach	;show the machine type, if needed
 	pop	di
 	jcxz da32f		;if no message
@@ -8962,10 +9252,10 @@
 	xor	al,DIS_F_SHOW + DIS_I_SHOW
 	test al,DIS_F_SHOW + DIS_I_SHOW
 	jnz	da32z		;if there is no memory location to show
-	cmp	byte [segmnt],3
+	cmp	byte ptr [segmnt],3
 	ja	da32z		;if FS or GS
 	mov	ax,line_out+79-10
-	cmp	byte [rmsize],0
+	cmp	byte ptr [rmsize],0
 	jl	da32h		;if byte
 	jz	da32g		;if word
 	sub	ax,4
@@ -8994,7 +9284,7 @@
 	mov	dl,[es:bx+2]	;avoid a "mov dx,[-1]"
 	mov	dh,[es:bx+3]
 	pop	es
-	cmp	byte [rmsize],0
+	cmp	byte ptr [rmsize],0
 	jl	da32j		;if byte
 	jz	da32i		;if word
 	xchg ax,dx
@@ -9021,7 +9311,7 @@
 	cmp	ax,0fbh
 	jne	da34		;if it was not `sti'
 da33:
-	mov	byte [disflags],0
+	mov	byte ptr [disflags],0
 	jmp	disasm
 da34:
 	ret
@@ -9033,7 +9323,7 @@
 	cmp	ah,0
 	jl	dop03		;if just a byte
 	pushf
-	test byte [disflags],DIS_I_SHOWSIZ
+	test byte ptr [disflags],DIS_I_SHOWSIZ
 	jz	dop01a		;if we don't need to show the size
 	call showsize
 	sub	di,4		;erase "PTR "
@@ -9064,9 +9354,9 @@
 dop05:
 	call showsize	;print out size
 dop06:
-	or	byte [preused],PRESEG;needed even if there's no segment override
+	or	byte ptr [preused],PRESEG;needed even if there's no segment override
 							;because handling of LOCK prefix relies on it
-	test byte [preflags],PRESEG
+	test byte ptr [preflags],PRESEG
 	jz	dop07			;if no segment override
 	call showseg		;print segment name
 	mov	al,':'
@@ -9074,13 +9364,13 @@
 dop07:
 	mov	al,[regmem]
 	and	al,0c7h
-	or	byte [preused],PRE32A
-	test byte [preflags],PRE32A
+	or	byte ptr [preused],PRE32A
+	test byte ptr [preflags],PRE32A
 	jz	dop08
 	jmp	dop18		;if 32-bit addressing
 dop08:
-	or	byte [disflags],DIS_I_SHOW	;we'd like to show this address
-	mov	word [addrr],0	;zero out the address initially
+	or	byte ptr [disflags],DIS_I_SHOW	;we'd like to show this address
+	mov	word ptr [addrr],0	;zero out the address initially
 	cmp	al,6
 	xchg ax,bx		;mov bx,ax
 	mov	al,'['
@@ -9092,15 +9382,15 @@
 	jnz	dop09		;if BX
 	test bl,4
 	jz	dop11		;if not BP
-	mov	ax,'BP'
+	mov	ax,'PB'
 	mov	cx,[reg_bp]
-	test byte [preflags],PRESEG
+	test byte ptr [preflags],PRESEG
 	jnz	dop10		;if segment override
-	dec	byte [segmnt]	;default is now SS
+	dec	byte ptr [segmnt]	;default is now SS
 	jmp	dop10
 
 dop09:	
-	mov	ax,'BX'		;BX
+	mov	ax,'XB'		;BX
 	mov	cx,[reg_bx]
 
 dop10:	
@@ -9111,7 +9401,7 @@
 	mov	al,'+'
 	stosb
 dop11:	
-	mov	ax,'SI'
+	mov	ax,'IS'
 	mov	cx,[reg_si]
 	test bl,1
 	jz	dop12		;if SI
@@ -9122,9 +9412,9 @@
 	add	[addrr],cx	;print it out, etc.
 	stosw
 dop13:
-	test byte [regmem],0c0h
+	test byte ptr [regmem],0c0h
 	jz	dop17		;if no displacement
-	test byte [regmem],80h
+	test byte ptr [regmem],80h
 	jnz	dop15		;if word displacement
 	call disgetbyte
 	cbw
@@ -9180,7 +9470,7 @@
 	cmp	al,0
 	jge	dop21		;if >= 0
 	neg	al
-	mov	byte [di],'-'
+	mov	byte ptr [di],'-'
 	inc	di
 dop21:
 	call hexbyte
@@ -9195,23 +9485,23 @@
 	cmp	al,4
 	jne	dop28		;if no SIB
 	mov	al,[sibbyte]
-%if 1               ;bugfix: make 'u' correctly handle [ESP],[ESP+x]
+if 1               ;bugfix: make 'u' correctly handle [ESP],[ESP+x]
     cmp al,24h
     jnz noesp
     mov al,4
     jmp dop28
 noesp:    
-%endif
+endif
 	and	al,7
 	cmp	al,5
 	jne	dop24		;if not [EBP]
-	test byte [regmem],0c0h
+	test byte ptr [regmem],0c0h
 	jnz	dop24		;if MOD != 0
 	call disp32		;show 32-bit displacement instead of [EBP]
 	jmp	dop25
 
 dop24:
-	mov	word [di],'[E'
+	mov	word ptr [di],'E['
 	inc	di
 	inc	di
 	call showreg16	;show 16bit register name (number in AL)
@@ -9226,7 +9516,7 @@
 	and	al,7
 	cmp	al,4
 	je	disbad1		;if illegal
-	mov	word [di],'[E'
+	mov	word ptr [di],'E['
 	inc	di
 	inc	di
 	call showreg16
@@ -9252,7 +9542,7 @@
 ;	32-bit addressing without SIB
 
 dop28:
-	mov	word [di],'[E'
+	mov	word ptr [di],'E['
 	inc	di
 	inc	di
 	call showreg16
@@ -9283,7 +9573,7 @@
 dop30:
 	call showsize	;print the size and save various things
 	mov	al,5
-	test byte [preflags],PRE32A
+	test byte ptr [preflags],PRE32A
 	jnz	dop31		;if 32-bit addressing
 	inc	ax
 dop31:
@@ -9304,7 +9594,7 @@
 	jl	dop35			;if byte register
 	jz	dop34			;if word register
 dop33a:
-	mov	byte [di],'E'	;enter here from OP_ECX
+	mov	byte ptr [di],'E'	;enter here from OP_ECX
 	inc	di
 dop34:
 	add	al,8
@@ -9337,21 +9627,21 @@
 ;	FLOAT mem (OP_MFLOAT).
 
 dop38a:
-	mov	ax,'FL'
+	mov	ax,'LF'
 	stosw
 	mov	al,'O'
 	stosb
-	mov	ax,'AT'
+	mov	ax,'TA'
 	jmp	dop38c
 
 ;	DOUBLE mem (OP_MDOUBLE).
 
 dop38b:
-	mov	ax,'DO'
+	mov	ax,'OD'
 	stosw
-	mov	ax,'UB'
+	mov	ax,'BU'
 	stosw
-	mov	ax,'LE'
+	mov	ax,'EL'
 dop38c:
 	stosw
 	call showptr
@@ -9366,7 +9656,8 @@
 	call getregmem
 	cmp	al,0c0h
 	jae	disbad1		;if it's a register reference
-	and	byte [disflags],~DIS_F_SHOW	;don't show this
+	;and	byte ptr [disflags],~DIS_F_SHOW	;don't show this
+	and	byte ptr [disflags],not DIS_F_SHOW	;don't show this
 	jmp	dop05
 
 ;	far memory (OP_FARMEM).
@@ -9377,7 +9668,7 @@
 	call showdwd
 	sub	di,4		;erase "PTR "
 dop41a:
-	mov	ax,'FA'		;store "FAR "
+	mov	ax,'AF'		;store "FAR "
 	stosw
 	mov	ax,'R '
 	stosw
@@ -9385,7 +9676,8 @@
 ;	mem (OP_MXX).
 
 dop42:
-	and	byte [disflags],~DIS_F_SHOW	;don't show this
+	;and	byte ptr [disflags],~DIS_F_SHOW	;don't show this
+	and	byte ptr [disflags],not DIS_F_SHOW	;don't show this
 dop42a:
 	call getregmem
 	cmp	al,0c0h
@@ -9431,10 +9723,10 @@
 	call dischk32d
 	jz	dop48		;if not 32-bit offset
 	push ax
-%if PM    
-    test byte [bCSAttr],40h	;for 32bit code segments
+if PM eq 1    
+    test byte ptr [bCSAttr],40h	;for 32bit code segments
     jnz dop47_1				;no need to display "DWORD "
-%endif
+endif
 	call showdwd
 	sub	di,4		;erase "PTR "
 dop47_1:    
@@ -9449,26 +9741,30 @@
 	jmp	hexword		;call hexword and return
 
 dop48:
-%if PM
-	test byte [bCSAttr],40h
+if PM eq 1
+	test byte ptr [bCSAttr],40h
     jnz dop48_1
-%endif    
+endif    
 	add	ax,[u_addr]
 	add	ax,[dis_n]
 	jmp	hexword		;call hexword and return
-%if PM
+if PM eq 1
 dop48_1:
-	cpu 386
+	;cpu 386
+.386p
 	movsx eax,ax
-    add eax,[u_addr]
-    add eax,[dis_n]
+    ;add eax,[u_addr]
+    add eax,dword ptr [u_addr]
+    ;add eax,[dis_n]
+    add eax,dword ptr [dis_n]
     push ax
     shr eax,16
     call hexword
     pop ax
     jmp hexword
-	cpu 8086
-%endif
+	;cpu 8086
+.8086
+endif
 
 ;	Check for ST(1) (OP_1CHK).
 
@@ -9489,11 +9785,11 @@
 	mov	al,[regmem]
 	and	al,7
 	xchg ax,bx		;mov bx,ax
-	mov	ax,'ST'
+	mov	ax,'TS'
 	stosw			;store ST(bl)
 	mov	al,'('
 	stosb
-	mov	ax,'0)'
+	mov	ax,')0'
 	or	al,bl
 	stosw
 	ret
@@ -9501,14 +9797,14 @@
 ;	CRx (OP_CR).
 
 dop52:
-	mov	bx,'CR'
+	mov	bx,'RC'
 	call getregmem_r
 	cmp	al,4
 	ja	disbad4		;if too large
 	jne	dop52a
-	mov	byte [dismach],5	;CR4 is new to the 586
+	mov	byte ptr [dismach],5	;CR4 is new to the 586
 dop52a:
-	cmp	word [index],SPARSE_BASE+22h
+	cmp	word ptr [index],SPARSE_BASE+22h
 	jne	dop55		;if not MOV CRx,xx
 	cmp	al,1
 	jne	dop55		;if not CR1
@@ -9519,7 +9815,7 @@
 
 dop53:
 	call getregmem_r
-	mov	bx,'DR'
+	mov	bx,'RD'
 	mov	cx,-1		;no max or illegal value
 	jmp	dop55
 
@@ -9531,9 +9827,9 @@
 	jb	disbad		;if too small
 	cmp	al,6
 	jae	dop54a		;if TR6-7
-	mov	byte [dismach],4	;TR3-5 are new to the 486
+	mov	byte ptr [dismach],4	;TR3-5 are new to the 486
 dop54a:
-	mov	bx,'TR'
+	mov	bx,'RT'
 
 dop55:
 	xchg ax,bx
@@ -9551,11 +9847,12 @@
 	jae	disbad		;if not a segment register
 	cmp	al,2
 	je dop57		;if SS
-	and	byte [disflags],~DIS_F_REPT	;clear flag:  don't repeat
+	;and	byte ptr [disflags],~DIS_F_REPT	;clear flag:  don't repeat
+	and	byte ptr [disflags],not DIS_F_REPT	;clear flag:  don't repeat
 dop57:
 	cmp	al,4
 	jb dop57a		;if not FS or GS
-	mov	byte [dismach],3;(no new 486-686 instructions involve seg regs)
+	mov	byte ptr [dismach],3;(no new 486-686 instructions involve seg regs)
 dop57a:
 	add	al,16
 	jmp	dop35		;go print it out
@@ -9593,30 +9890,32 @@
 ;	Set flag to always show size (OP_SHOSIZ).
 
 dop60:
-	or	byte [disflags],DIS_I_SHOWSIZ
+	or	byte ptr [disflags],DIS_I_SHOWSIZ
 dop60a:
 	pop	ax			;discard return address
 	jmp	da14		;next...
 
 disbad:
 	mov	sp,[savesp2]	;pop junk off stack
-	mov	word [dis_n],0
-	mov	word [preflags],0 ;clear preflags and preused
-	mov	byte [rmsize],80h	;don't display any memory
-	mov	word [dismach],0;forget about the machine type
-	and	byte [disflags],~DIS_I_SHOW	;and flags
+	mov	word ptr [dis_n],0
+	mov	word ptr [preflags],0 ;clear preflags and preused
+	mov	byte ptr [rmsize],80h	;don't display any memory
+	mov	word ptr [dismach],0;forget about the machine type
+	;and	byte ptr [disflags],~DIS_I_SHOW	;and flags
+	and	byte ptr [disflags],not DIS_I_SHOW	;and flags
 	call disgetbyte
-	mov	di,prefixlist
+	;mov	di,prefixlist
+	mov	di,offset prefixlist
 	mov	cx,10
 	repne scasb
 	je	dbad1		;if it's a named prefix
-	dec	word [dis_n]
+	dec	word ptr [dis_n]
 	mov	bx,MNEM_DB	;offset of 'DB' mnemonic
 	mov	si,OPLIST_Z	;this says OP_8+OP_IMM
 	jmp	da13
 
 dbad1:
-	or	byte [disflags],DIS_I_UNUSED	;print special flag
+	or	byte ptr [disflags],DIS_I_UNUSED	;print special flag
 	mov	bx,9
 	sub	bx,cx
 	shl	bx,1
@@ -9644,9 +9943,9 @@
 ;	GETREGMEM - Get the reg/mem part of the instruction
 
 getregmem:
-	test byte [preused],GOTREGM
+	test byte ptr [preused],GOTREGM
 	jnz	grm1		;if we have it already
-	or	byte [preused],GOTREGM
+	or	byte ptr [preused],GOTREGM
 	call disgetbyte	;get the byte
 	mov	[regmem],al	;save it away
 
@@ -9704,9 +10003,9 @@
 	mov	[sizeloc],di	;save where we're putting this
 	cmp	ah,0
 	jge	ssz1		;if word or dword
-	mov	ax,'BY'
+	mov	ax,'YB'
 	stosw
-	mov	ax,'TE'
+	mov	ax,'ET'
 	jmp	ssz3
 
 ssz1:
@@ -9715,15 +10014,15 @@
 	mov	al,'D'
 	stosb
 ssz2:
-	mov	ax,'WO'
+	mov	ax,'OW'
 	stosw
-	mov	ax,'RD'
+	mov	ax,'DR'
 ssz3:
 	stosw
 showptr:
 	mov	ax,' P'
 	stosw
-	mov	ax,'TR'
+	mov	ax,'RT'
 	stosw
 	mov	al,' '
 	stosb
@@ -9765,22 +10064,24 @@
 ;	Uses	al, di
 
 showmach:
-	mov	si,needsmsg		;candidate message
-	test byte [dmflags],DM_COPR
+	;mov	si,needsmsg		;candidate message
+	mov	si,offset needsmsg		;candidate message
+	test byte ptr [dmflags],DM_COPR
 	jz	sm1				;if not a coprocessor instruction
-	mov	byte [si+9],'7'	;change message text
+	mov	byte ptr [si+9],'7'	;change message text
 	mov	al,[mach_87]
-	cmp	byte [has_87],0
+	cmp	byte ptr [has_87],0
 	jnz	sm2				;if it has a coprocessor
 	mov	al,[machine]
 	cmp	al,[dismach]
 	jb	sm3				;if we display the message
-	mov	si,needsmath	;print this message instead
+	;mov	si,needsmath	;print this message instead
+	mov	si,offset needsmath	;print this message instead
 	mov	cx,needsmath_L
 	ret
 
 sm1:
-	mov	byte [si+9],'6'	;reset message text
+	mov	byte ptr [si+9],'6'	;reset message text
 	mov	al,[machine]
 sm2:
 	cmp	al,[dismach]
@@ -9795,12 +10096,14 @@
 ;	Check for obsolete instruction.
 
 sm4:
-	mov	si,obsolete	;candidate message
+	;mov	si,obsolete	;candidate message
+	mov	si,offset obsolete	;candidate message
 	mov	ax,[di-2]	;get info on this instruction
 	mov	cx,5
 	repne scasw
 	jne	sm5			;if no matches
-	mov	di,obsmach + 5 - 1
+	;mov	di,obsmach + 5 - 1
+	mov	di,offset obsmach + 5 - 1
 	sub	di,cx
 	xor	cx,cx		;clear CX:  no message
 	mov	al,[mach_87]
@@ -9817,10 +10120,10 @@
 
 disgetbyte:
 	push ds
-%if PM
-	test byte [bCSAttr],40h
+if PM eq 1
+	test byte ptr [bCSAttr],40h
     jnz disgb_1
-%endif    
+endif    
 	push si
 	mov	si,[u_addr]
 	mov	ds,[u_addr+4]
@@ -9828,21 +10131,25 @@
 	lodsb 			;get the byte
     pop si
 	pop	ds
-	inc	word [dis_n]	;indicate that we've gotten this byte
+	inc	word ptr [dis_n]	;indicate that we've gotten this byte
 	ret
-%if PM    
-	cpu 386
+if PM eq 1    
+	;cpu 386
+.386p
 disgb_1:
 	push esi
 	lds	esi,[u_addr]
-	add	esi,[cs:dis_n]	;index to the right byte
-	a32 lodsb
+	;add	esi,[cs:dis_n]	;index to the right byte
+	add	esi,dword ptr cs:[dis_n]	;index to the right byte
+	;a32 lodsb
+	lodsb
 	pop	esi
 	pop	ds
-	inc	dword [dis_n]	;indicate that we've gotten this byte
+	inc	dword ptr [dis_n]	;indicate that we've gotten this byte
     ret
-    cpu 8086
-%endif    
+    ;cpu 8086
+.8086
+endif    
 
 ;	DISGETWORD - Get word for disassembler.
 ;	Entry	None
@@ -9851,10 +10158,10 @@
 
 disgetword:
 	push ds
-%if PM
-	test byte [bCSAttr],40h
+if PM eq 1
+	test byte ptr [bCSAttr],40h
     jnz disgw_1
-%endif    
+endif    
 	push si		;save si
 	mov	si,[u_addr]
 	mov	ds,[u_addr+4]
@@ -9862,21 +10169,25 @@
 	lodsw
 	pop	si		;restore things
 	pop	ds
-	add	word [dis_n],2
+	add	word ptr [dis_n],2
 	ret
-%if PM 
-	cpu 386
+if PM eq 1 
+	;cpu 386
+.386p
 disgw_1:    
 	push esi
 	lds	esi,[u_addr]
-	add	esi,[cs:dis_n]	;index to the right byte
-	a32 lodsw
+	;add	esi,[cs:dis_n]	;index to the right byte
+	add	esi,dword ptr cs:[dis_n]	;index to the right byte
+	;a32 lodsw
+	lodsw
 	pop	esi
 	pop	ds
-	add	dword [dis_n],2
+	add	dword ptr [dis_n],2
 	ret
-    cpu 8086
-%endif
+    ;cpu 8086
+.8086
+endif
 
 ;	DISSHOWBYTES - Show bytes for the disassembler.
 ;	Entry	BX	Number of bytes (must be > 0)
@@ -9884,10 +10195,10 @@
 ;	Uses	BX, SI.
 
 disshowbytes:
-%if PM
-	test byte [bCSAttr],40h
+if PM eq 1
+	test byte ptr [bCSAttr],40h
     jnz dissb_1
-%endif
+endif
 	mov	si,[u_addr]
 	mov	ds,[u_addr+4]
 dsb1:
@@ -9899,21 +10210,25 @@
 	pop	ds
 	mov	[u_addr],si
 	ret
-%if PM
-	cpu 386
+if PM eq 1
+	;cpu 386
+.386p
 dissb_1:
 	lds	esi,[u_addr]
 dsb2:
-	a32 lodsb
+	;a32 lodsb
+	lodsb
 	call hexbyte
 	dec	bx
 	jnz	dsb2
 	push ss
 	pop	ds
-	mov	[u_addr],esi
+	;mov	[u_addr],esi
+	mov	dword ptr [u_addr],esi
 	ret
-    cpu 8086
-%endif    
+    ;cpu 8086
+.8086
+endif    
 
 ;	MOVEOVER - Move the line to the right.
 ;	Entry	DI	Last address + 1 of line so far
@@ -9922,7 +10237,7 @@
 ;	Uses	SI
 
 moveover:
-	cmp	word [sizeloc],0
+	cmp	word ptr [sizeloc],0
 	je	mo1		;if sizeloc not saved
 	add	[sizeloc],cx
 
@@ -9943,19 +10258,19 @@
 ;	DISCHK32D - Check for 32 bit operand size prefix (66h).
 
 dischk32d:
-	or	byte [preused],PRE32D
-	test byte [preflags],PRE32D
+	or	byte ptr [preused],PRE32D
+	test byte ptr [preflags],PRE32D
 	ret
 
 ;	DUMPREGS - Dump registers.
 
 dumpregs:
-	mov	si,regs
-	mov	bx,regnames
+	mov	si,offset regs
+	mov	bx,offset regnames
 	mov	di,line_out
-	mov bp,regshi
+	mov bp, offset regshi
 	mov	cx,8			;print all 8 std regs (16-bit)
-    test [regsdmp],byte 1
+    test [regsdmp],byte ptr 1
     jz no386_2
     mov cl,6			;room for 6 std regs (32-bit) only
 no386_2:
@@ -9964,7 +10279,7 @@
 	call trimputs
 	pop	bx
 	mov	di,line_out
-    test [regsdmp],byte 1
+    test [regsdmp],byte ptr 1
     jnz no386_3
 	mov	cl,4			;print 4 segment regs
 	call dmpr1
@@ -9983,23 +10298,24 @@
 	mov	di,line_out
     mov cl,6		;print ds, es, ss, cs, fs, gs
     call dmpr1_1
-    mov	bp,regh_eip
+    mov	bp,offset regh_eip
 no386_31:
     mov	cl,1
     call dmpr1		;print (E)IP
-	test [regsdmp],byte 1
+	test [regsdmp],byte ptr 1
     jnz	no386_32
 	call dmpflags	;print flags in 8086 mode
 no386_32:    
 	call trimputs
 	mov	ax,[reg_ip]
-	mov	di,u_addr
+	mov	di,offset u_addr
 	stosw
 	mov	ax,[regh_eip]
 	stosw
 	mov	ax,[reg_cs]
 	stosw
-	mov	byte [disflags],DIS_F_REPT | DIS_F_SHOW
+	;mov	byte [disflags],DIS_F_REPT | DIS_F_SHOW
+	mov	byte ptr [disflags],DIS_F_REPT or DIS_F_SHOW
 	call disasm
 	mov	ax,[regh_eip]
 	mov	[u_addr+2],ax
@@ -10011,7 +10327,7 @@
 ;	Function to print multiple register entries.
 
 dmpr1:
-	test [regsdmp],byte 1
+	test [regsdmp],byte ptr 1
     jnz dmpr1X
 dmpr1_1:
     mov	ax,[bx]
@@ -10056,19 +10372,21 @@
 
 ;fregnames 
 ;	db "CW", 2, "SW", 2, "TW", 2, "IP", 4, "CS", 2, "OO", 4, "OS", 2
-fregnames
+fregnames:
 	db "CW", "SW", "TW"
     db "OPC=", "IP=", "DP="
 dEmpty db "<empty>              "
 
 dumpregsF:
 	mov	di,line_out
-	mov	si,fregnames
+	mov	si,offset fregnames
     sub sp,7*2+8*10
     mov bp,sp
-    cpufpu 8086
+    ;cpufpu 8086
+.8087
     fnsave [bp]
-    cpu 8086
+    ;cpu 8086
+.8086
     mov cx,3
 nextfpr:    
 	movsw
@@ -10123,7 +10441,7 @@
 	mov	di,line_out
 	mov cx,8
 nextst:    
-    mov ax,"ST"
+    mov ax,"TS"
     stosw
     mov al,8
     sub al,cl
@@ -10139,14 +10457,15 @@
     jnz notinval
     push si
     push cx
-	mov si, dEmpty
+	;mov si, dEmpty
+	mov si, offset dEmpty
     mov cx, 21
     rep movsb
     pop cx
     pop si
     jmp regoutdone
 notinval:
-%if PM
+if PM eq 1
 	push cx
     
 	push di
@@ -10154,7 +10473,7 @@
 	call FloatToStr
     add di,21
     pop cx
-%else
+else
     push cx
     mov ax,[bp+8]
     call hexword
@@ -10169,7 +10488,7 @@
     mov ax,[bp+0]
     call hexword
     pop cx
-%endif    
+endif    
 regoutdone:
     mov al,' '
     stosb
@@ -10183,9 +10502,11 @@
 	add bp,10
     loop nextst
     mov bp,sp
-    cpufpu 8086
+    ;cpufpu 8086
+.8087
     frstor [bp]
-    cpu 8086
+    ;cpu 8086
+.8086
     add sp,7*2+8*10
 	ret
 
@@ -10193,7 +10514,7 @@
 
 dmpflags:
 	mov	bx,[reg_fl]
-	mov	si,flgbits
+	mov	si,offset flgbits
 	mov	cx,8
 dmpf1:	mov	ax,[si+16]
 	test	bx,[si]
@@ -10208,8 +10529,8 @@
 	ret
 
 flgbits	dw	800h,400h,200h,80h,40h,10h,4,1
-flgnams	dw	'NV','UP','DI','PL','NZ','NA','PO','NC'
-flgnons	dw	'OV','DN','EI','NG','ZR','AC','PE','CY'
+flgnams	dw	'VN','PU','ID','LP','ZN','AN','OP','CN'
+flgnons	dw	'VO','ND','IE','GN','RZ','CA','EP','YC'
 
 ;	SHOWSTRING - Print nonempty null-terminated string.
 
@@ -10270,7 +10591,8 @@
 
 trimputs:
 	dec	di
-	cmp	byte [di],' '
+	;cmp	byte [di],' '
+	cmp	byte ptr [di],' '
 	je	trimputs
 	inc	di
 
@@ -10304,25 +10626,27 @@
     ret
 
 gethwefl:
-    cmp byte [machine],3
+    cmp byte ptr [machine],3
     jb gethwefl_1
-    cpu 386
+    ;cpu 386
+.386p
     pushfd
     pop ax
-    pop word [regh_efl]
-    cpu 8086
+    pop word ptr [regh_efl]
+    ;cpu 8086
+.8086
 gethwefl_1:
 	ret
 
 createdummytask:
 
-	mov di, regs
+	mov di, offset regs
     mov cx, 16*2	;(8 std, 6 seg, ip, fl) * 2
     xor ax, ax
     rep stosw
-    mov word [reg_ip],100h
+    mov word ptr [reg_ip],100h
     pushf
-    pop word [reg_fl]
+    pop word ptr [reg_fl]
     call gethwefl
 
     mov ah,48h		;get largest free block
@@ -10333,7 +10657,7 @@
     jc  ct_done
     
     push bx
-	mov	di,reg_ds	;fill segment registers ds,es,ss,cs
+	mov	di,offset reg_ds	;fill segment registers ds,es,ss,cs
 	stosw
 	stosw
 	stosw
@@ -10365,12 +10689,13 @@
 	mov	si,[es:ALASAP]
 	clc			;works around OS/2 bug
 	int	21h
-	mov	word [es:TPIVOFS],int22
+	mov	word ptr [es:TPIVOFS],offset int22
 	mov	[es:TPIVSEG],cs
-    cmp byte [bInit],0
+    cmp byte ptr [bInit],0
     jnz nomemtouch
-    inc byte [bInit]
-    mov [es:100h],byte 0C3h	;place opcode for 'RET' at CS:IP
+    inc byte ptr [bInit]
+    ;mov [es:100h],byte ptr 0C3h	;place opcode for 'RET' at CS:IP
+    mov byte ptr es:[100h],byte ptr 0C3h	;place opcode for 'RET' at CS:IP
 nomemtouch:
     mov [pspdbe],es
     mov ax,es
@@ -10378,7 +10703,7 @@
     mov es,ax
     inc ax
     mov [es:0001],ax
-    mov byte [es:0008],0
+    mov byte ptr [es:0008],0
     push cs
     pop es
     mov bx,cs
@@ -10386,7 +10711,7 @@
 ct_done:    
     ret
 
-%if PM
+if PM eq 1
 
 ;--- hook int 2Fh if a DPMI host is found
 ;--- for Win9x and DosEmu host
@@ -10397,57 +10722,63 @@
 ;--- modifies AX, BX, CX, DX, DI
 
 hook2f:
-    cmp word [oldi2f+2],0
+    cmp word ptr [oldi2f+2],0
     jnz hook2f_2
 	mov ax,1687h			;DPMI host installed?
     int 2Fh
     and ax,ax
     jnz hook2f_2
-    mov [dpmientry+0],di	;true host DPMI entry
-    mov [dpmientry+2],es
-    mov [dpmiwatch+0],di
-    mov [dpmiwatch+2],es
-	cmp byte [bNoHook2F],0	;can int 2Fh be hooked?
+    mov word ptr [dpmientry+0],di	;true host DPMI entry
+    mov word ptr [dpmientry+2],es
+    mov word ptr [dpmiwatch+0],di
+    mov word ptr [dpmiwatch+2],es
+	cmp byte ptr [bNoHook2F],0	;can int 2Fh be hooked?
     jnz hook2f_2
-	mov word [dpmiwatch+0],mydpmientry
-	mov word [dpmiwatch+2],cs
+	;mov word [dpmiwatch+0],mydpmientry
+	mov word ptr [dpmiwatch+0],offset mydpmientry
+	mov word ptr [dpmiwatch+2],cs
 	mov ax,352Fh
     int 21h
-    mov [oldi2f+0],bx
-    mov [oldi2f+2],es
-    mov dx,debug2F
+    ;mov [oldi2f+0],bx
+    mov word ptr [oldi2f+0],bx
+    ;mov [oldi2f+2],es
+    mov word ptr [oldi2f+2],es
+    mov dx,offset debug2F
     mov ax,252Fh
     int 21h
 hook2f_1:
 	push ds
     pop es
-%if DISPHOOK
+if DISPHOOK
 	mov ax,cs
-    mov di,dpmihookcsip
+    ;mov di,dpmihookcsip
+    mov di,offset dpmihookcsip
     call hexword
     inc di
-    mov ax,mydpmientry
+    ;mov ax,mydpmientry
+    mov ax,offset mydpmientry
     call hexword
-    mov dx,dpmihook
+    ;mov dx,dpmihook
+    mov dx,offset dpmihook
     call int21ah9
-%endif
+endif
 hook2f_2:
 	push ds
     pop es
 	ret
-%endif
+endif
 
 ;	I/O buffers.  (End of permanently resident part.)
 
 end1:
 line_in		db	255,0,CR	;length = 257
-line_out	equ	end1+258	;length = 1 + 263
-real_end	equ	end1+258+264
+line_out	equ	offset end1+258	;length = 1 + 263
+real_end	equ	offset end1+258+264
 staksiz		equ	200h
 
 initcont:    
     int 21h			;free rest of DOS memory
-	mov	byte [line_out-1],'0'	;initialize line_out
+	mov	byte ptr [line_out-1],'0'	;initialize line_out
 	call ll3		;load a program if one has been given at the command line
 	jmp	cmd3		;done
 
@@ -10487,7 +10818,7 @@
 	and	dl,81h		;check if console device
 	cmp	dl,81h
 	jne	init1		;if not the console input
-	mov	byte [notatty],0	;it _is_ a tty
+	mov	byte ptr [notatty],0	;it _is_ a tty
 
 ;	Check DOS version
 
@@ -10497,17 +10828,17 @@
 	xchg al,ah
 	cmp	ax,31fh
 	jb	init2		;if version < 3.3, then don't use new INT 25h method
-	inc	byte [usepacket]
-%if VDD
+	inc	byte ptr [usepacket]
+if VDD
     cmp ah,5
     jnz isnotnt
     mov ax,3306h
     int 21h
     cmp bx,3205h
     jnz isnotnt
-    mov si,szDebxxVdd	;DS:SI->"DEBXXVDD.DLL"
-    mov bx,szDispatch	;DS:BX->"Dispatch"
-    mov di,szInit		;ES:DI->"Init"
+    mov si,offset szDebxxVdd	;DS:SI->"DEBXXVDD.DLL"
+    mov bx,offset szDispatch	;DS:BX->"Dispatch"
+    mov di,offset szInit		;ES:DI->"Init"
     RegisterModule
     jc init2
     mov [hVdd], ax
@@ -10516,11 +10847,11 @@
 szDispatch	db "Dispatch",0
 szInit		db "Init",0
 isnotnt:
-%endif
+endif
     cmp ax,070Ah
     jb  init2
 isntordos71:
-	inc	byte [usepacket]
+	inc	byte ptr [usepacket]
 
 ;	Determine the processor type.  This is adapted from code in the
 ;	Pentium<tm> Family User's Manual, Volume 3:  Architecture and
@@ -10545,7 +10876,7 @@
 ;	Bits 12-15 of the flags register are always clear on the
 ;	Intel 286 processor in real-address mode.
 
-	mov	byte [machine],2
+	mov	byte ptr [machine],2
 	pushf			;get original flags into AX
 	pop	ax
 	or	ax,0f000h	;try to set bits 12-15
@@ -10563,11 +10894,13 @@
 
 ;	It is now safe to use 32-bit opcode/operands.
 
-	cpufpu	386
-
-	inc	byte [machine]
+	;cpufpu	386
+.387
+.386
+	inc	byte ptr [machine]
 	mov	bx,sp		;save current stack pointer to align
-	and	sp,~3		;align stack to avoid AC fault
+	;and	sp,~3		;align stack to avoid AC fault
+	and	sp,not 3		;align stack to avoid AC fault
 	pushfd			;push original EFLAGS
 	pop	eax			;get original EFLAGS
 	mov	ecx,eax		;save original EFLAGS in CX
@@ -10584,7 +10917,7 @@
 ;	which indicates the presence of a processor with the ability
 ;	to use the CPUID instruction.
 
-	inc	byte [machine]	;it's a 486
+	inc	byte ptr [machine]	;it's a 486
 	mov	eax,ecx		;get original EFLAGS
 	xor	eax,200000h	;flip (XOR) ID bit in EFLAGS
 	push eax		;save new EFLAGS value on stack
@@ -10599,7 +10932,8 @@
 
 ;	Execute CPUID instruction.
 
-	cpu	586
+	;cpu	586
+.586p
 
 	xor	eax,eax		;set up input for CPUID instruction
 	cpuid
@@ -10622,7 +10956,8 @@
 	popfd			;restore AC bit in EFLAGS first
 	mov	sp,bx		;restore original stack pointer
 
-	cpufpu	8086 	;back to 1980s technology
+	;cpufpu	8086 	;back to 1980s technology
+.8087
     
 ;	Next determine the type of FPU in a system and set the mach_87
 ;	variable with the appropriate value.  All registers are used by
@@ -10641,13 +10976,13 @@
 init6:
 	mov	al,[machine]
 	mov	[mach_87],al	;by default, set mach_87 to machine
-    inc byte [has_87]
+    inc byte ptr [has_87]
     cmp al,5			;a Pentium or above always will have a FPU
     jnc init7
-    dec byte [has_87]
+    dec byte ptr [has_87]
 
 	fninit				;reset FP status word
-	mov	word [fp_status],5a5ah	;restore temp word to nonzero value
+	mov	word ptr [fp_status],5a5ah	;restore temp word to nonzero value
 	fnstsw	[fp_status]	;save FP status word
 	mov	ax,[fp_status]	;check FP status word
 	cmp	al,0
@@ -10658,24 +10993,26 @@
 	and	ax,103fh		;see if selected parts look OK
 	cmp	ax,3fh
 	jne	init7			;if no FPU present
-	inc	byte [has_87]	;there's an FPU
+	inc	byte ptr [has_87]	;there's an FPU
 
 ;	If we're using a 386, check for 287 vs. 387 by checking whether
 ;	+infinity = -infinity.
 
-	cmp	byte [machine],3
+	cmp	byte ptr [machine],3
 	jne	init7		;if not a 386
 	fld1			;must use default control from FNINIT
 	fldz			;form infinity
-	fdivp	ST1		;1 / 0 = infinity
-	fld	ST0			;form negative infinity
+	;fdivp	ST1		;1 / 0 = infinity
+	fdivp	st(1),st(0)	;1 / 0 = infinity
+	;fld	ST0		;form negative infinity
+	fld	st(0)		;form negative infinity
 	fchs
 	fcompp			;see if they are the same and remove them
 	fstsw	[fp_status]	;look at status from FCOMPP
 	mov	ax,[fp_status]
 	sahf
 	jnz	init7			;if they are different, then it's a 387
-	dec	byte [mach_87]	;otherwise, it's a 287
+	dec	byte ptr [mach_87]	;otherwise, it's a 287
 
 ;	Interpret switches and erase them from the command line.
 
@@ -10715,7 +11052,8 @@
 
 ;	Print a help message
 
-init10:	mov	dx,imsg1	;command-line help message
+;init10:	mov	dx,imsg1	;command-line help message
+init10:	mov	dx,offset imsg1	;command-line help message
 	call	int21ah9	;print string
 	int	20h		;done
 
@@ -10728,7 +11066,8 @@
 ;	||| Other switches may go here.
 
 	mov	[imsg2a],al
-	mov	dx,imsg2	;Invalid switch
+	;mov	dx,imsg2	;Invalid switch
+	mov	dx,offset imsg2	;Invalid switch
 	call	int21ah9	;print string
 	mov	ax,4c01h	;Quit and return error status
 	int	21h
@@ -10743,8 +11082,10 @@
 ;	Set up interrupt vectors.
 
 	mov	cx,4
-	mov	si,inttab
-    mov di,intsave
+	;mov	si,inttab
+	mov	si,offset inttab
+    ;mov di,intsave
+    mov di,offset intsave
 init13:	
 	lodsb
     mov ah,35h
@@ -10760,67 +11101,67 @@
 	loop init13
 
 	push es
-%if MCB
+if MCB
 	mov ah,52h		;get list of lists
     int 21h
     mov ax,[es:bx-2]	;start of MCBs
     mov [wMCB],ax
-%endif
+endif
 	mov ah,34h
     int 21h
-    mov word [pInDOS+0],bx
-    mov word [pInDOS+2],es
-%if PM
+    mov word ptr [pInDOS+0],bx
+    mov word ptr [pInDOS+2],es
+if PM eq 1
     mov [InDosSegm],es
-%endif
+endif
     pop es
     
 ;-- get address of DOS swappable DATA area
 ;-- to be used to get/set PSP and thus avoid DOS calls
 ;-- will not work for DOS < 3
 
-%if USESDA
+if USESDA
 	push ds
     mov ax,5D06h
     int 21h
     mov ax,ds
     pop ds
     jc noSDA
-    mov word [pSDA+0],si
-    mov word [pSDA+2],ax
-%if PM    
+    mov word ptr [pSDA+0],si
+    mov word ptr [pSDA+2],ax
+if PM eq 1    
     mov [SDASegm],ax
-%endif    
+endif    
 noSDA:
-%endif
+endif
 
-
-%if PM
+if PM eq 1
 
 ;--- Windows 9x and DosEmu are among those hosts which handle some
 ;--- V86 Ints internally without first calling the interrupt chain.
 ;--- This causes various sorts of troubles and incompatibilities.
 
-%if WIN9XSUPP
+if WIN9XSUPP
     mov ax,1600h	;running in a win9x dos box?
     int 2Fh
     and al,al
     jnz no2fhook
-%endif
-%if DOSEMU
+endif
+if DOSEMU
     mov ax,0F000h
     mov es,ax
     mov di,0FFF5h
-    mov si,dDosEmuDate
+    ;mov si,dDosEmuDate
+    mov si,offset dDosEmuDate
     mov cx,4
     repe cmpsw		;running in DosEmu?
     jz no2fhook
-%endif
+endif
 	jmp dpmihostchecked
 no2fhook:    
-    inc byte [bNoHook2F]
+    inc byte ptr [bNoHook2F]
 dpmihostchecked:
-%endif
+endif
 
 	push ds
     pop es
@@ -10828,10 +11169,10 @@
 ;	Save and modify termination address and the parent PSP field.
 
 	mov	si,TPIVOFS
-	mov	di,psp22
+	mov	di,offset psp22
 	movsw
 	movsw
-	mov	word [si-4],debug22
+	mov	word ptr [si-4],offset debug22
 	mov	[si-2],cs
 	mov	si,16h
 	movsw
@@ -10842,7 +11183,8 @@
 ;	shrink DEBUG and set its stack
     
 	mov	ax,real_end + staksiz + 15
-	and	ax,~15		;new stack pointer
+	;and	ax,~15		;new stack pointer
+	and	ax,not 15		;new stack pointer
     mov sp,ax
 	dec	ax
 	dec	ax
@@ -10854,3 +11196,9 @@
 	mov bx,ax
     mov ah,4Ah
     jmp initcont
+
+_TEXT ends
+
+DGROUP group _TEXT
+
+      end __start
--- orig/debugtbl.inc	2023-01-14 02:58:17.713774131 +0300
+++ contrib/debugtbl.inc	2023-01-08 21:56:03.585624042 +0300
@@ -336,372 +336,372 @@
 ;	This is the list of assembler mnemonics.
 
 mnlist:
-	mne <0000h, "AA", "A"+80h>
-	mne <0003h, "AA", "D"+80h>
-	mne <0007h, "AA", "M"+80h>
-	mne 000bh, "AA", "S"+80h
-	mne 000eh, "AD", "C"+80h
-	mne 001ch, "AD", "D"+80h
-	mne 002ah, "AN", "D"+80h
-	mne 0038h, "ARP", "L"+80h
-	mne 003ch, "BOUN", "D"+80h
-	mne 0040h, "BS", "F"+80h
-	mne 0044h, "BS", "R"+80h
-	mne 0048h, "BSWA", "P"+80h
-	mne 004dh, "B", "T"+80h
-	mne 0054h, "BT", "C"+80h
-	mne 005dh, "BT", "R"+80h
-	mne 0066h, "BT", "S"+80h
-	mne 006fh, "CAL", "L"+80h
-	mne 0078h, "CB", "W"+80h
-	mne 0126h, "CD", "Q"+80h
-	mne 007dh, "CL", "C"+80h
-	mne 0080h, "CL", "D"+80h
-	mne 0083h, "CL", "I"+80h
-	mne 0086h, "CLT", "S"+80h
-	mne 008ah, "CM", "C"+80h
-	mne 008dh, "CMOV", "A"+80h
-	mne 0091h, "CMOVA", "E"+80h
-	mne 0095h, "CMOV", "B"+80h
-	mne 0099h, "CMOVB", "E"+80h
-	mne 009dh, "CMOV", "C"+80h
-	mne 00a1h, "CMOV", "E"+80h
-	mne 00a5h, "CMOV", "G"+80h
-	mne 00a9h, "CMOVG", "E"+80h
-	mne 00adh, "CMOV", "L"+80h
-	mne 00b1h, "CMOVL", "E"+80h
-	mne 00b5h, "CMOVN", "A"+80h
-	mne 00b9h, "CMOVNA", "E"+80h
-	mne 00bdh, "CMOVN", "B"+80h
-	mne 00c1h, "CMOVNB", "E"+80h
-	mne 00c5h, "CMOVN", "C"+80h
-	mne 00c9h, "CMOVN", "E"+80h
-	mne 00cdh, "CMOVN", "G"+80h
-	mne 00d1h, "CMOVNG", "E"+80h
-	mne 00d5h, "CMOVN", "L"+80h
-	mne 00d9h, "CMOVNL", "E"+80h
-	mne 00ddh, "CMOVN", "O"+80h
-	mne 00e1h, "CMOVN", "P"+80h
-	mne 00e5h, "CMOVN", "S"+80h
-	mne 00e9h, "CMOVN", "Z"+80h
-	mne 00edh, "CMOV", "O"+80h
-	mne 00f1h, "CMOV", "P"+80h
-	mne 00f5h, "CMOVP", "E"+80h
-	mne 00f9h, "CMOVP", "O"+80h
-	mne 00fdh, "CMOV", "S"+80h
-	mne 0101h, "CMOV", "Z"+80h
-	mne 0105h, "CM", "P"+80h
-	mne 0110h, "CMPS", "B"+80h
-	mne 0114h, "CMPS", "D"+80h
-	mne 0113h, "CMPS", "W"+80h
-	mne 0118h, "CMPXCH", "G"+80h
-	mne 011dh, "CMPXCHG8", "B"+80h
-	mne 0121h, "CPUI", "D"+80h
-	mne 05d4h, "C", "S"+80h
-	mne 0125h, "CW", "D"+80h
-	mne 0079h, "CWD", "E"+80h
-	mne 012ah, "DA", "A"+80h
-	mne 012dh, "DA", "S"+80h
-	mne 0130h, "D", "B"+80h
-	mne 0132h, "D", "D"+80h
-	mne 0134h, "DE", "C"+80h
-	mne 013ah, "DI", "V"+80h
-	mne 05d8h, "D", "S"+80h
-	mne 013dh, "D", "W"+80h
-	mne 013fh, "ENTE", "R"+80h
-	mne 05d2h, "E", "S"+80h
-	mne 0143h, "F2XM", "1"+80h
-	mne 0147h, "FAB", "S"+80h
-	mne 014bh, "FAD", "D"+80h
-	mne 0156h, "FADD", "P"+80h
-	mne 0162h, "FBL", "D"+80h
-	mne 0165h, "FBST", "P"+80h
-	mne 0168h, "FCH", "S"+80h
-	mne 016ch, "FCLE", "X"+80h
-	mne 0171h, "FCMOV", "A"+80h
-	mne 0176h, "FCMOVA", "E"+80h
-	mne 017bh, "FCMOV", "B"+80h
-	mne 0180h, "FCMOVB", "E"+80h
-	mne 0185h, "FCMOV", "E"+80h
-	mne 018ah, "FCMOVN", "A"+80h
-	mne 018fh, "FCMOVNA", "E"+80h
-	mne 0194h, "FCMOVN", "B"+80h
-	mne 0199h, "FCMOVNB", "E"+80h
-	mne 019eh, "FCMOVN", "E"+80h
-	mne 01a3h, "FCMOVN", "U"+80h
-	mne 01a8h, "FCMOVN", "Z"+80h
-	mne 01adh, "FCMOV", "U"+80h
-	mne 01b2h, "FCMOV", "Z"+80h
-	mne 01b7h, "FCO", "M"+80h
-	mne 01c2h, "FCOM", "I"+80h
-	mne 01cbh, "FCOMI", "P"+80h
-	mne 01d4h, "FCOM", "P"+80h
-	mne 01dfh, "FCOMP", "P"+80h
-	mne 01e3h, "FCO", "S"+80h
-	mne 01e8h, "FDECST", "P"+80h
-	mne 01ech, "FDIS", "I"+80h
-	mne 01f1h, "FDI", "V"+80h
-	mne 01fch, "FDIV", "P"+80h
-	mne 0208h, "FDIV", "R"+80h
-	mne 0213h, "FDIVR", "P"+80h
-	mne 021fh, "FEN", "I"+80h
-	mne 0224h, "FFRE", "E"+80h
-	mne 015dh, "FIAD", "D"+80h
-	mne 0228h, "FICO", "M"+80h
-	mne 022dh, "FICOM", "P"+80h
-	mne 0203h, "FIDI", "V"+80h
-	mne 021ah, "FIDIV", "R"+80h
-	mne 0232h, "FIL", "D"+80h
-	mne 028dh, "FIMU", "L"+80h
-	mne 0239h, "FINCST", "P"+80h
-	mne 023dh, "FINI", "T"+80h
-	mne 0242h, "FIS", "T"+80h
-	mne 0247h, "FIST", "P"+80h
-	mne 02fdh, "FISU", "B"+80h
-	mne 0314h, "FISUB", "R"+80h
-	mne 024eh, "FL", "D"+80h
-	mne 0258h, "FLD", "1"+80h
-	mne 0274h, "FLDC", "W"+80h
-	mne 0278h, "FLDEN", "V"+80h
-	mne 0260h, "FLDL2", "E"+80h
-	mne 025ch, "FLDL2", "T"+80h
-	mne 0268h, "FLDLG", "2"+80h
-	mne 026ch, "FLDLN", "2"+80h
-	mne 0264h, "FLDP", "I"+80h
-	mne 0270h, "FLD", "Z"+80h
-	mne 027bh, "FMU", "L"+80h
-	mne 0286h, "FMUL", "P"+80h
-	mne 016dh, "FNCLE", "X"+80h
-	mne 01edh, "FNDIS", "I"+80h
-	mne 0220h, "FNEN", "I"+80h
-	mne 023eh, "FNINI", "T"+80h
-	mne 0275h, "FNLDC", "W"+80h
-	mne 0292h, "FNO", "P"+80h
-	mne 02afh, "FNSAV", "E"+80h
-	mne 02b7h, "FNSETP", "M"+80h
-	mne 02ddh, "FNSTC", "W"+80h
-	mne 02e1h, "FNSTEN", "V"+80h
-	mne 02e5h, "FNSTS", "W"+80h
-	mne 0296h, "FPATA", "N"+80h
-	mne 029ah, "FPRE", "M"+80h
-	mne 029eh, "FPREM", "1"+80h
-	mne 02a3h, "FPTA", "N"+80h
-	mne 02a7h, "FRNDIN", "T"+80h
-	mne 02abh, "FRSTO", "R"+80h
-	mne 05dah, "F", "S"+80h
-	mne 02aeh, "FSAV", "E"+80h
-	mne 02b2h, "FSCAL", "E"+80h
-	mne 02b6h, "FSETP", "M"+80h
-	mne 02bch, "FSI", "N"+80h
-	mne 02c1h, "FSINCO", "S"+80h
-	mne 02c6h, "FSQR", "T"+80h
-	mne 02cah, "FS", "T"+80h
-	mne 02dch, "FSTC", "W"+80h
-	mne 02e0h, "FSTEN", "V"+80h
-	mne 02d2h, "FST", "P"+80h
-	mne 02e4h, "FSTS", "W"+80h
-	mne 02ebh, "FSU", "B"+80h
-	mne 02f6h, "FSUB", "P"+80h
-	mne 0302h, "FSUB", "R"+80h
-	mne 030dh, "FSUBR", "P"+80h
-	mne 0319h, "FTS", "T"+80h
-	mne 031dh, "FUCO", "M"+80h
-	mne 0326h, "FUCOM", "I"+80h
-	mne 032fh, "FUCOMI", "P"+80h
-	mne 0338h, "FUCOM", "P"+80h
-	mne 0341h, "FUCOMP", "P"+80h
-	mne 0346h, "FWAI", "T"+80h
-	mne 0349h, "FXA", "M"+80h
-	mne 034dh, "FXC", "H"+80h
-	mne 0354h, "FXTRAC", "T"+80h
-	mne 0358h, "FYL2", "X"+80h
-	mne 035ch, "FYL2XP", "1"+80h
-	mne 05dch, "G", "S"+80h
-	mne 0360h, "HL", "T"+80h
-	mne 0363h, "IDI", "V"+80h
-	mne 0366h, "IMU", "L"+80h
-	mne 0378h, "I", "N"+80h
-	mne 037dh, "IN", "C"+80h
-	mne 0383h, "INS", "B"+80h
-	mne 0388h, "INS", "D"+80h
-	mne 0387h, "INS", "W"+80h
-	mne 038dh, "IN", "T"+80h
-	mne 0392h, "INT", "O"+80h
-	mne 0395h, "INV", "D"+80h
-	mne 0399h, "INVLP", "G"+80h
-	mne 039dh, "IRE", "T"+80h
-	mne 039eh, "IRET", "D"+80h
-	mne 03a2h, "J", "A"+80h
-	mne 03a8h, "JA", "E"+80h
-	mne 03aeh, "J", "B"+80h
-	mne 03b4h, "JB", "E"+80h
-	mne 03bah, "J", "C"+80h
-	mne 03c0h, "JCX", "Z"+80h
-	mne 03c5h, "J", "E"+80h
-	mne 03c1h, "JECX", "Z"+80h
-	mne 03cbh, "J", "G"+80h
-	mne 03d1h, "JG", "E"+80h
-	mne 03d7h, "J", "L"+80h
-	mne 03ddh, "JL", "E"+80h
-	mne 045bh, "JM", "P"+80h
-	mne 03e3h, "JN", "A"+80h
-	mne 03e9h, "JNA", "E"+80h
-	mne 03efh, "JN", "B"+80h
-	mne 03f5h, "JNB", "E"+80h
-	mne 03fbh, "JN", "C"+80h
-	mne 0401h, "JN", "E"+80h
-	mne 0407h, "JN", "G"+80h
-	mne 040dh, "JNG", "E"+80h
-	mne 0413h, "JN", "L"+80h
-	mne 0419h, "JNL", "E"+80h
-	mne 041fh, "JN", "O"+80h
-	mne 0425h, "JN", "P"+80h
-	mne 042bh, "JN", "S"+80h
-	mne 0431h, "JN", "Z"+80h
-	mne 0437h, "J", "O"+80h
-	mne 043dh, "J", "P"+80h
-	mne 0443h, "JP", "E"+80h
-	mne 0449h, "JP", "O"+80h
-	mne 044fh, "J", "S"+80h
-	mne 0455h, "J", "Z"+80h
-	mne 0466h, "LAH", "F"+80h
-	mne 0469h, "LA", "R"+80h
-	mne 046dh, "LD", "S"+80h
-	mne 047fh, "LE", "A"+80h
-	mne 0482h, "LEAV", "E"+80h
-	mne 0474h, "LE", "S"+80h
-	mne 0477h, "LF", "S"+80h
-	mne 0486h, "LGD", "T"+80h
-	mne 047bh, "LG", "S"+80h
-	mne 048ah, "LID", "T"+80h
-	mne 048eh, "LLD", "T"+80h
-	mne 0492h, "LMS", "W"+80h
-	mne 0496h, "LOC", "K"+80h
-	mne 0498h, "LODS", "B"+80h
-	mne 049ch, "LODS", "D"+80h
-	mne 049bh, "LODS", "W"+80h
-	mne 04a0h, "LOO", "P"+80h
-	mne 04a4h, "LOOP", "D"+80h
-	mne 04abh, "LOOP", "E"+80h
-	mne 04afh, "LOOPE", "D"+80h
-	mne 04aeh, "LOOPE", "W"+80h
-	mne 04bbh, "LOOPN", "E"+80h
-	mne 04bfh, "LOOPNE", "D"+80h
-	mne 04beh, "LOOPNE", "W"+80h
-	mne 04b8h, "LOOPN", "Z"+80h
-	mne 04c4h, "LOOPNZ", "D"+80h
-	mne 04c3h, "LOOPNZ", "W"+80h
-	mne 04a3h, "LOOP", "W"+80h
-	mne 04a8h, "LOOP", "Z"+80h
-	mne 04b4h, "LOOPZ", "D"+80h
-	mne 04b3h, "LOOPZ", "W"+80h
-	mne 04c8h, "LS", "L"+80h
-	mne 0470h, "LS", "S"+80h
-	mne 04cch, "LT", "R"+80h
-	mne 04d0h, "MO", "V"+80h
-	mne 04f5h, "MOVS", "B"+80h
-	mne 04f9h, "MOVS", "D"+80h
-	mne 04f8h, "MOVS", "W"+80h
-	mne 04fdh, "MOVS", "X"+80h
-	mne 0504h, "MOVZ", "X"+80h
-	mne 050bh, "MU", "L"+80h
-	mne 050eh, "NE", "G"+80h
-	mne 0512h, "NO", "P"+80h
-	mne 0515h, "NO", "T"+80h
-	mne 0519h, "O", "R"+80h
-	mne 0527h, "OR", "G"+80h
-	mne 0529h, "OU", "T"+80h
-	mne 052eh, "OUTS", "B"+80h
-	mne 0533h, "OUTS", "D"+80h
-	mne 0532h, "OUTS", "W"+80h
-	mne 0538h, "PO", "P"+80h
-	mne 0549h, "POP", "A"+80h
-	mne 054ah, "POPA", "D"+80h
-	mne 054fh, "POP", "F"+80h
-	mne 0550h, "POPF", "D"+80h
-	mne 0554h, "PUS", "H"+80h
-	mne 056dh, "PUSH", "A"+80h
-	mne 056eh, "PUSHA", "D"+80h
-	mne 0573h, "PUSH", "F"+80h
-	mne 0574h, "PUSHF", "D"+80h
-	mne 0578h, "RC", "L"+80h
-	mne 0580h, "RC", "R"+80h
-	mne 0598h, "RDMS", "R"+80h
-	mne 059ch, "RE", "P"+80h
-	mne 059eh, "REP", "E"+80h
-	mne 05a0h, "REPN", "E"+80h
-	mne 05a2h, "RE", "T"+80h
-	mne 05a7h, "RET", "F"+80h
-	mne 05a8h, "RETF", "D"+80h
-	mne 0588h, "RO", "L"+80h
-	mne 0590h, "RO", "R"+80h
-	mne 05aeh, "RS", "M"+80h
-	mne 05b2h, "SAH", "F"+80h
-	mne 05b5h, "SA", "L"+80h
-	mne 05bdh, "SA", "R"+80h
-	mne 05eeh, "SB", "B"+80h
-	mne 05fch, "SCAS", "B"+80h
-	mne 0600h, "SCAS", "D"+80h
-	mne 05ffh, "SCAS", "W"+80h
-	mne 05c5h, "SE", "G"+80h
-	mne 0604h, "SET", "A"+80h
-	mne 0608h, "SETA", "E"+80h
-	mne 060ch, "SET", "B"+80h
-	mne 0610h, "SETB", "E"+80h
-	mne 0614h, "SET", "C"+80h
-	mne 0618h, "SET", "E"+80h
-	mne 061ch, "SET", "G"+80h
-	mne 0620h, "SETG", "E"+80h
-	mne 0624h, "SET", "L"+80h
-	mne 0628h, "SETL", "E"+80h
-	mne 062ch, "SETN", "A"+80h
-	mne 0630h, "SETNA", "E"+80h
-	mne 0634h, "SETN", "B"+80h
-	mne 0638h, "SETNB", "E"+80h
-	mne 063ch, "SETN", "C"+80h
-	mne 0640h, "SETN", "E"+80h
-	mne 0644h, "SETN", "G"+80h
-	mne 0648h, "SETNG", "E"+80h
-	mne 064ch, "SETN", "L"+80h
-	mne 0650h, "SETNL", "E"+80h
-	mne 0654h, "SETN", "O"+80h
-	mne 0658h, "SETN", "P"+80h
-	mne 065ch, "SETN", "S"+80h
-	mne 0660h, "SETN", "Z"+80h
-	mne 0664h, "SET", "O"+80h
-	mne 0668h, "SET", "P"+80h
-	mne 066ch, "SETP", "E"+80h
-	mne 0670h, "SETP", "O"+80h
-	mne 0674h, "SET", "S"+80h
-	mne 0678h, "SET", "Z"+80h
-	mne 067ch, "SGD", "T"+80h
-	mne 05deh, "SH", "L"+80h
-	mne 0684h, "SHL", "D"+80h
-	mne 05e6h, "SH", "R"+80h
-	mne 068bh, "SHR", "D"+80h
-	mne 0680h, "SID", "T"+80h
-	mne 0692h, "SLD", "T"+80h
-	mne 0696h, "SMS", "W"+80h
-	mne 05d6h, "S", "S"+80h
-	mne 069ah, "ST", "C"+80h
-	mne 069dh, "ST", "D"+80h
-	mne 06a0h, "ST", "I"+80h
-	mne 06a3h, "STOS", "B"+80h
-	mne 06a7h, "STOS", "D"+80h
-	mne 06a6h, "STOS", "W"+80h
-	mne 06abh, "ST", "R"+80h
-	mne 06afh, "SU", "B"+80h
-	mne 06bdh, "TES", "T"+80h
-	mne 06c6h, "VER", "R"+80h
-	mne 06cah, "VER", "W"+80h
-	mne 06ceh, "WAI", "T"+80h
-	mne 06d1h, "WBINV", "D"+80h
-	mne 06d5h, "WRMS", "R"+80h
-	mne 06d9h, "XAD", "D"+80h
-	mne 06deh, "XCH", "G"+80h
-	mne 06e9h, "XLA", "T"+80h
-	mne 06ech, "XLAT", "B"+80h
-	mne 06efh, "XO", "R"+80h
+	mne 0000h, "AA", "A"
+	mne 0003h, "AA", "D"
+	mne 0007h, "AA", "M"
+	mne 000bh, "AA", "S"
+	mne 000eh, "AD", "C"
+	mne 001ch, "AD", "D"
+	mne 002ah, "AN", "D"
+	mne 0038h, "ARP", "L"
+	mne 003ch, "BOUN", "D"
+	mne 0040h, "BS", "F"
+	mne 0044h, "BS", "R"
+	mne 0048h, "BSWA", "P"
+	mne 004dh, "B", "T"
+	mne 0054h, "BT", "C"
+	mne 005dh, "BT", "R"
+	mne 0066h, "BT", "S"
+	mne 006fh, "CAL", "L"
+	mne 0078h, "CB", "W"
+	mne 0126h, "CD", "Q"
+	mne 007dh, "CL", "C"
+	mne 0080h, "CL", "D"
+	mne 0083h, "CL", "I"
+	mne 0086h, "CLT", "S"
+	mne 008ah, "CM", "C"
+	mne 008dh, "CMOV", "A"
+	mne 0091h, "CMOVA", "E"
+	mne 0095h, "CMOV", "B"
+	mne 0099h, "CMOVB", "E"
+	mne 009dh, "CMOV", "C"
+	mne 00a1h, "CMOV", "E"
+	mne 00a5h, "CMOV", "G"
+	mne 00a9h, "CMOVG", "E"
+	mne 00adh, "CMOV", "L"
+	mne 00b1h, "CMOVL", "E"
+	mne 00b5h, "CMOVN", "A"
+	mne 00b9h, "CMOVNA", "E"
+	mne 00bdh, "CMOVN", "B"
+	mne 00c1h, "CMOVNB", "E"
+	mne 00c5h, "CMOVN", "C"
+	mne 00c9h, "CMOVN", "E"
+	mne 00cdh, "CMOVN", "G"
+	mne 00d1h, "CMOVNG", "E"
+	mne 00d5h, "CMOVN", "L"
+	mne 00d9h, "CMOVNL", "E"
+	mne 00ddh, "CMOVN", "O"
+	mne 00e1h, "CMOVN", "P"
+	mne 00e5h, "CMOVN", "S"
+	mne 00e9h, "CMOVN", "Z"
+	mne 00edh, "CMOV", "O"
+	mne 00f1h, "CMOV", "P"
+	mne 00f5h, "CMOVP", "E"
+	mne 00f9h, "CMOVP", "O"
+	mne 00fdh, "CMOV", "S"
+	mne 0101h, "CMOV", "Z"
+	mne 0105h, "CM", "P"
+	mne 0110h, "CMPS", "B"
+	mne 0114h, "CMPS", "D"
+	mne 0113h, "CMPS", "W"
+	mne 0118h, "CMPXCH", "G"
+	mne 011dh, "CMPXCHG8", "B"
+	mne 0121h, "CPUI", "D"
+	mne 05d4h, "C", "S"
+	mne 0125h, "CW", "D"
+	mne 0079h, "CWD", "E"
+	mne 012ah, "DA", "A"
+	mne 012dh, "DA", "S"
+	mne 0130h, "D", "B"
+	mne 0132h, "D", "D"
+	mne 0134h, "DE", "C"
+	mne 013ah, "DI", "V"
+	mne 05d8h, "D", "S"
+	mne 013dh, "D", "W"
+	mne 013fh, "ENTE", "R"
+	mne 05d2h, "E", "S"
+	mne 0143h, "F2XM", "1"
+	mne 0147h, "FAB", "S"
+	mne 014bh, "FAD", "D"
+	mne 0156h, "FADD", "P"
+	mne 0162h, "FBL", "D"
+	mne 0165h, "FBST", "P"
+	mne 0168h, "FCH", "S"
+	mne 016ch, "FCLE", "X"
+	mne 0171h, "FCMOV", "A"
+	mne 0176h, "FCMOVA", "E"
+	mne 017bh, "FCMOV", "B"
+	mne 0180h, "FCMOVB", "E"
+	mne 0185h, "FCMOV", "E"
+	mne 018ah, "FCMOVN", "A"
+	mne 018fh, "FCMOVNA", "E"
+	mne 0194h, "FCMOVN", "B"
+	mne 0199h, "FCMOVNB", "E"
+	mne 019eh, "FCMOVN", "E"
+	mne 01a3h, "FCMOVN", "U"
+	mne 01a8h, "FCMOVN", "Z"
+	mne 01adh, "FCMOV", "U"
+	mne 01b2h, "FCMOV", "Z"
+	mne 01b7h, "FCO", "M"
+	mne 01c2h, "FCOM", "I"
+	mne 01cbh, "FCOMI", "P"
+	mne 01d4h, "FCOM", "P"
+	mne 01dfh, "FCOMP", "P"
+	mne 01e3h, "FCO", "S"
+	mne 01e8h, "FDECST", "P"
+	mne 01ech, "FDIS", "I"
+	mne 01f1h, "FDI", "V"
+	mne 01fch, "FDIV", "P"
+	mne 0208h, "FDIV", "R"
+	mne 0213h, "FDIVR", "P"
+	mne 021fh, "FEN", "I"
+	mne 0224h, "FFRE", "E"
+	mne 015dh, "FIAD", "D"
+	mne 0228h, "FICO", "M"
+	mne 022dh, "FICOM", "P"
+	mne 0203h, "FIDI", "V"
+	mne 021ah, "FIDIV", "R"
+	mne 0232h, "FIL", "D"
+	mne 028dh, "FIMU", "L"
+	mne 0239h, "FINCST", "P"
+	mne 023dh, "FINI", "T"
+	mne 0242h, "FIS", "T"
+	mne 0247h, "FIST", "P"
+	mne 02fdh, "FISU", "B"
+	mne 0314h, "FISUB", "R"
+	mne 024eh, "FL", "D"
+	mne 0258h, "FLD", "1"
+	mne 0274h, "FLDC", "W"
+	mne 0278h, "FLDEN", "V"
+	mne 0260h, "FLDL2", "E"
+	mne 025ch, "FLDL2", "T"
+	mne 0268h, "FLDLG", "2"
+	mne 026ch, "FLDLN", "2"
+	mne 0264h, "FLDP", "I"
+	mne 0270h, "FLD", "Z"
+	mne 027bh, "FMU", "L"
+	mne 0286h, "FMUL", "P"
+	mne 016dh, "FNCLE", "X"
+	mne 01edh, "FNDIS", "I"
+	mne 0220h, "FNEN", "I"
+	mne 023eh, "FNINI", "T"
+	mne 0275h, "FNLDC", "W"
+	mne 0292h, "FNO", "P"
+	mne 02afh, "FNSAV", "E"
+	mne 02b7h, "FNSETP", "M"
+	mne 02ddh, "FNSTC", "W"
+	mne 02e1h, "FNSTEN", "V"
+	mne 02e5h, "FNSTS", "W"
+	mne 0296h, "FPATA", "N"
+	mne 029ah, "FPRE", "M"
+	mne 029eh, "FPREM", "1"
+	mne 02a3h, "FPTA", "N"
+	mne 02a7h, "FRNDIN", "T"
+	mne 02abh, "FRSTO", "R"
+	mne 05dah, "F", "S"
+	mne 02aeh, "FSAV", "E"
+	mne 02b2h, "FSCAL", "E"
+	mne 02b6h, "FSETP", "M"
+	mne 02bch, "FSI", "N"
+	mne 02c1h, "FSINCO", "S"
+	mne 02c6h, "FSQR", "T"
+	mne 02cah, "FS", "T"
+	mne 02dch, "FSTC", "W"
+	mne 02e0h, "FSTEN", "V"
+	mne 02d2h, "FST", "P"
+	mne 02e4h, "FSTS", "W"
+	mne 02ebh, "FSU", "B"
+	mne 02f6h, "FSUB", "P"
+	mne 0302h, "FSUB", "R"
+	mne 030dh, "FSUBR", "P"
+	mne 0319h, "FTS", "T"
+	mne 031dh, "FUCO", "M"
+	mne 0326h, "FUCOM", "I"
+	mne 032fh, "FUCOMI", "P"
+	mne 0338h, "FUCOM", "P"
+	mne 0341h, "FUCOMP", "P"
+	mne 0346h, "FWAI", "T"
+	mne 0349h, "FXA", "M"
+	mne 034dh, "FXC", "H"
+	mne 0354h, "FXTRAC", "T"
+	mne 0358h, "FYL2", "X"
+	mne 035ch, "FYL2XP", "1"
+	mne 05dch, "G", "S"
+	mne 0360h, "HL", "T"
+	mne 0363h, "IDI", "V"
+	mne 0366h, "IMU", "L"
+	mne 0378h, "I", "N"
+	mne 037dh, "IN", "C"
+	mne 0383h, "INS", "B"
+	mne 0388h, "INS", "D"
+	mne 0387h, "INS", "W"
+	mne 038dh, "IN", "T"
+	mne 0392h, "INT", "O"
+	mne 0395h, "INV", "D"
+	mne 0399h, "INVLP", "G"
+	mne 039dh, "IRE", "T"
+	mne 039eh, "IRET", "D"
+	mne 03a2h, "J", "A"
+	mne 03a8h, "JA", "E"
+	mne 03aeh, "J", "B"
+	mne 03b4h, "JB", "E"
+	mne 03bah, "J", "C"
+	mne 03c0h, "JCX", "Z"
+	mne 03c5h, "J", "E"
+	mne 03c1h, "JECX", "Z"
+	mne 03cbh, "J", "G"
+	mne 03d1h, "JG", "E"
+	mne 03d7h, "J", "L"
+	mne 03ddh, "JL", "E"
+	mne 045bh, "JM", "P"
+	mne 03e3h, "JN", "A"
+	mne 03e9h, "JNA", "E"
+	mne 03efh, "JN", "B"
+	mne 03f5h, "JNB", "E"
+	mne 03fbh, "JN", "C"
+	mne 0401h, "JN", "E"
+	mne 0407h, "JN", "G"
+	mne 040dh, "JNG", "E"
+	mne 0413h, "JN", "L"
+	mne 0419h, "JNL", "E"
+	mne 041fh, "JN", "O"
+	mne 0425h, "JN", "P"
+	mne 042bh, "JN", "S"
+	mne 0431h, "JN", "Z"
+	mne 0437h, "J", "O"
+	mne 043dh, "J", "P"
+	mne 0443h, "JP", "E"
+	mne 0449h, "JP", "O"
+	mne 044fh, "J", "S"
+	mne 0455h, "J", "Z"
+	mne 0466h, "LAH", "F"
+	mne 0469h, "LA", "R"
+	mne 046dh, "LD", "S"
+	mne 047fh, "LE", "A"
+	mne 0482h, "LEAV", "E"
+	mne 0474h, "LE", "S"
+	mne 0477h, "LF", "S"
+	mne 0486h, "LGD", "T"
+	mne 047bh, "LG", "S"
+	mne 048ah, "LID", "T"
+	mne 048eh, "LLD", "T"
+	mne 0492h, "LMS", "W"
+	mne 0496h, "LOC", "K"
+	mne 0498h, "LODS", "B"
+	mne 049ch, "LODS", "D"
+	mne 049bh, "LODS", "W"
+	mne 04a0h, "LOO", "P"
+	mne 04a4h, "LOOP", "D"
+	mne 04abh, "LOOP", "E"
+	mne 04afh, "LOOPE", "D"
+	mne 04aeh, "LOOPE", "W"
+	mne 04bbh, "LOOPN", "E"
+	mne 04bfh, "LOOPNE", "D"
+	mne 04beh, "LOOPNE", "W"
+	mne 04b8h, "LOOPN", "Z"
+	mne 04c4h, "LOOPNZ", "D"
+	mne 04c3h, "LOOPNZ", "W"
+	mne 04a3h, "LOOP", "W"
+	mne 04a8h, "LOOP", "Z"
+	mne 04b4h, "LOOPZ", "D"
+	mne 04b3h, "LOOPZ", "W"
+	mne 04c8h, "LS", "L"
+	mne 0470h, "LS", "S"
+	mne 04cch, "LT", "R"
+	mne 04d0h, "MO", "V"
+	mne 04f5h, "MOVS", "B"
+	mne 04f9h, "MOVS", "D"
+	mne 04f8h, "MOVS", "W"
+	mne 04fdh, "MOVS", "X"
+	mne 0504h, "MOVZ", "X"
+	mne 050bh, "MU", "L"
+	mne 050eh, "NE", "G"
+	mne 0512h, "NO", "P"
+	mne 0515h, "NO", "T"
+	mne 0519h, "O", "R"
+	mne 0527h, "OR", "G"
+	mne 0529h, "OU", "T"
+	mne 052eh, "OUTS", "B"
+	mne 0533h, "OUTS", "D"
+	mne 0532h, "OUTS", "W"
+	mne 0538h, "PO", "P"
+	mne 0549h, "POP", "A"
+	mne 054ah, "POPA", "D"
+	mne 054fh, "POP", "F"
+	mne 0550h, "POPF", "D"
+	mne 0554h, "PUS", "H"
+	mne 056dh, "PUSH", "A"
+	mne 056eh, "PUSHA", "D"
+	mne 0573h, "PUSH", "F"
+	mne 0574h, "PUSHF", "D"
+	mne 0578h, "RC", "L"
+	mne 0580h, "RC", "R"
+	mne 0598h, "RDMS", "R"
+	mne 059ch, "RE", "P"
+	mne 059eh, "REP", "E"
+	mne 05a0h, "REPN", "E"
+	mne 05a2h, "RE", "T"
+	mne 05a7h, "RET", "F"
+	mne 05a8h, "RETF", "D"
+	mne 0588h, "RO", "L"
+	mne 0590h, "RO", "R"
+	mne 05aeh, "RS", "M"
+	mne 05b2h, "SAH", "F"
+	mne 05b5h, "SA", "L"
+	mne 05bdh, "SA", "R"
+	mne 05eeh, "SB", "B"
+	mne 05fch, "SCAS", "B"
+	mne 0600h, "SCAS", "D"
+	mne 05ffh, "SCAS", "W"
+	mne 05c5h, "SE", "G"
+	mne 0604h, "SET", "A"
+	mne 0608h, "SETA", "E"
+	mne 060ch, "SET", "B"
+	mne 0610h, "SETB", "E"
+	mne 0614h, "SET", "C"
+	mne 0618h, "SET", "E"
+	mne 061ch, "SET", "G"
+	mne 0620h, "SETG", "E"
+	mne 0624h, "SET", "L"
+	mne 0628h, "SETL", "E"
+	mne 062ch, "SETN", "A"
+	mne 0630h, "SETNA", "E"
+	mne 0634h, "SETN", "B"
+	mne 0638h, "SETNB", "E"
+	mne 063ch, "SETN", "C"
+	mne 0640h, "SETN", "E"
+	mne 0644h, "SETN", "G"
+	mne 0648h, "SETNG", "E"
+	mne 064ch, "SETN", "L"
+	mne 0650h, "SETNL", "E"
+	mne 0654h, "SETN", "O"
+	mne 0658h, "SETN", "P"
+	mne 065ch, "SETN", "S"
+	mne 0660h, "SETN", "Z"
+	mne 0664h, "SET", "O"
+	mne 0668h, "SET", "P"
+	mne 066ch, "SETP", "E"
+	mne 0670h, "SETP", "O"
+	mne 0674h, "SET", "S"
+	mne 0678h, "SET", "Z"
+	mne 067ch, "SGD", "T"
+	mne 05deh, "SH", "L"
+	mne 0684h, "SHL", "D"
+	mne 05e6h, "SH", "R"
+	mne 068bh, "SHR", "D"
+	mne 0680h, "SID", "T"
+	mne 0692h, "SLD", "T"
+	mne 0696h, "SMS", "W"
+	mne 05d6h, "S", "S"
+	mne 069ah, "ST", "C"
+	mne 069dh, "ST", "D"
+	mne 06a0h, "ST", "I"
+	mne 06a3h, "STOS", "B"
+	mne 06a7h, "STOS", "D"
+	mne 06a6h, "STOS", "W"
+	mne 06abh, "ST", "R"
+	mne 06afh, "SU", "B"
+	mne 06bdh, "TES", "T"
+	mne 06c6h, "VER", "R"
+	mne 06cah, "VER", "W"
+	mne 06ceh, "WAI", "T"
+	mne 06d1h, "WBINV", "D"
+	mne 06d5h, "WRMS", "R"
+	mne 06d9h, "XAD", "D"
+	mne 06deh, "XCH", "G"
+	mne 06e9h, "XLA", "T"
+	mne 06ech, "XLAT", "B"
+	mne 06efh, "XO", "R"
 
 end_mnlist:
 
--- orig/fptostr.inc	2023-01-14 03:00:10.608185843 +0300
+++ contrib/fptostr.inc	2023-01-08 21:56:03.585624042 +0300
@@ -84,8 +84,10 @@
     and bl, 0fh		;bits 0-3
     je pot2
 	lea ebx, [ebx+ebx*4]
-	fld tword [ebx*2-10+ten_1]
-	fmulp st1, st0
+	;fld tword [ebx*2-10+ten_1]
+	fld [ebx*2-10+ten_1]
+	;fmulp st1, st0
+	fmulp st(1), st(0)
 pot2:    
 
     mov bl, al
@@ -93,23 +95,29 @@
     and bl, 0fh		;bits 4-7
 	je pot3
 	lea ebx, [ebx+ebx*4]
-	fld tword [ebx*2-10+ten_16]
-	fmulp st1, st0
+	;fld tword [ebx*2-10+ten_16]
+	fld [ebx*2-10+ten_16]
+	;fmulp st1, st0
+	fmulp st(1), st(0)
 pot3:    
 
     mov bl, ah
     and bl, 1fh		;bits 8-12
 	je pot4
 	lea ebx, [ebx+ebx*4]
-	fld tword [ebx*2-10+ten_256]
-	fmulp st1, st0
+	;fld tword [ebx*2-10+ten_256]
+	fld [ebx*2-10+ten_256]
+	;fmulp st1, st0
+	fmulp st(1), st(0)
 pot4:    
 	cmp ecx, 0		;.IF (SDWORD PTR ecx < 0)
 	jge pot5
-	fdivp st1, st0
+	;fdivp st1, st0
+	fdivp st(1), st(0)
     ret
 pot5:    
-	fmulp st1, st0
+	;fmulp st1, st0
+	fmulp st(1), st(0)
     ret
 
 ;PowerOf10 ENDP
@@ -133,7 +141,8 @@
 	; packed BCD form in ten bytes, with two digits per byte.  The top 
 	; byte has the sign, which we ignore.
 
-    fbstp [bp-12]
+    ;fbstp [bp-12]
+    fbstp tbyte ptr [bp-12]
 
 	; Now we need to unpack the BCD to ASCII.
 
@@ -177,13 +186,13 @@
     push si
     push di
     
-%define pfpin	bp+4
-%define szDbl	bp+6
-%define iExp 	bp-4
-%define mystat  bp-6
-%define fpin	bp-16
-%define stat	bp-18
-%define szTemp	bp-40
+pfpin	equ [bp+4]
+szDbl	equ [bp+6]
+iExp 	equ [bp-4]
+mystat  equ [bp-6]
+fpin	equ [bp-16]
+stat	equ [bp-18]
+szTemp	equ [bp-40]
 
 ;    LOCAL iExp: DWORD
 ;    LOCAL mystat: WORD
@@ -194,10 +203,10 @@
 
 ; Special case zero.  fxtract fails for zero.
 	
+    ;mov si, [pfpin]
+    mov si, pfpin
 
-    mov si, [pfpin]
-    
-    lea di, [fpin]
+    lea di, fpin
     xor dx, dx
     mov cx, 5
 ftsn1:    
@@ -206,7 +215,7 @@
     stosw
     loop ftsn1
     
-    mov di, [szDbl]
+    mov di, szDbl
 	and dx,dx
     jnz notnull
     mov al,'0'
@@ -216,9 +225,11 @@
 
 ; Check for a negative number.
 
-	test byte [fpin+9],80h
+	;test byte [fpin+9],80h
+	test byte ptr fpin+9,80h
     jz ispositive
-    and byte [fpin+9], 07fh		; change to positive
+    ;and byte [fpin+9], 07fh		; change to positive
+    and byte ptr fpin+9, 07fh		; change to positive
     mov al,'-'        			; store a minus sign
     stosb
 ispositive:
@@ -226,12 +237,16 @@
 ; Initialize the floating point unit and load our value onto the stack.
 
     fclex
-    fstcw [stat]
-    mov word [mystat], 027fh
-    fldcw word [mystat]
-
-    fld tword [fpin]
-    fld st0
+    fstcw stat
+    ;mov word [mystat], 027fh
+    mov word ptr mystat, 027fh
+    ;fldcw word [mystat]
+    fldcw word ptr mystat
+
+    ;fld tword [fpin]
+    fld tbyte ptr fpin
+    ;fld st0
+    fld st(0)
 
 ; Compute the closest power of 10 below the number.  We can't get an
 ; exact value because of rounding.  We could get close by adding in
@@ -244,10 +259,12 @@
 ; what we want.
 
     fxtract				; ST=> mantissa, exponent, fpin
-    fstp st0			; drop the mantissa
+    ;fstp st0			; drop the mantissa
+    fstp st(0)			; drop the mantissa
     fldlg2				; push log10(2)
-    fmulp st1, st0		; ST = log10(fpin), fpin
-    fistp dword [iExp]	; ST = fpin
+    ;fmulp st1, st0		; ST = log10(fpin), fpin
+    fmulp st(1), st(0)		; ST = log10(fpin), fpin
+    fistp dword ptr iExp	; ST = fpin
 
 ; An 8-byte double can carry almost 16 digits of precision.  Actually, it's
 ; 15.9 digits, so some numbers close to 1E17 will be wrong in the bottom
@@ -256,11 +273,13 @@
 ; A 10-byte double can carry almost 19 digits, but fbstp only stores the
 ; guaranteed 18.  If you're doing 10-byte doubles, change the '16' to '18'.
 
-	cmp dword [iExp],18
+	cmp dword ptr iExp,18
     jnc notbelow18
-    fld st0			; ST = fpin, fpin
+    ;fld st0			; ST = fpin, fpin
+    fld st(0)			; ST = fpin, fpin
     frndint			; ST = int(fpin), fpin
-    fcomp st1		; ST = fpin, status set
+    ;fcomp st1		; ST = fpin, status set
+    fcomp st(1)		; ST = fpin, status set
     fstsw ax
     test ah, FP_EQUALTO
     jz notequal
@@ -268,21 +287,22 @@
 ; We have an integer!  Lucky day.  Go convert it into a temp buffer.
 
 	push di
-	lea di, [szTemp]
+	lea di, szTemp
 	call FloatToBCD
     pop di
 
 	mov eax, 17
-	mov ecx, [iExp]
+	mov ecx, iExp
 	sub eax, ecx
 	inc cx
-	lea si, [szTemp]
+	lea si, szTemp
     add si, ax
 
 ; The off-by-one order of magnitude problem below can hit us here.  
 ; We just trim off the possible leading zero.
 
-	cmp byte [si],'0'
+	;cmp byte [si],'0'
+	cmp byte ptr [si],'0'
     jnz not0digit
     inc si
 	dec cx
@@ -299,36 +319,39 @@
 ; Have fbstp round to 17 places.
 
     mov eax, 16			; experiment
-    sub eax, [iExp]		; adjust exponent to 17
+    sub eax, iExp		; adjust exponent to 17
     call PowerOf10
 
 ; Either we have exactly 17 digits, or we have exactly 16 digits.  We can
 ; detect that condition and adjust now.
 
-    fcom qword [ten16]
+    ;fcom qword [ten16]
+    fcom qword ptr [ten16]
     ; x0xxxx00 means top of stack > ten16
     ; x0xxxx01 means top of stack < ten16
     ; x1xxxx00 means top of stack = ten16
     fstsw ax
     test ah,1
     jz notset1
-    fmul qword [ten]
-    dec dword [iExp]
+    ;fmul qword [ten]
+    fmul qword ptr [ten]
+    ;dec dword [iExp]
+    dec dword ptr iExp
 notset1:      
 
 ; Go convert to BCD.
 
 	push di
-	lea  di, [szTemp]
+	lea  di, szTemp
     call FloatToBCD
     pop di
 
-    lea si, [szTemp+1]		; point to converted buffer
+    lea si, szTemp+1		; point to converted buffer
 
 ; If the exponent is between -15 and 16, we should express this as a number
 ; without scientific notation.
 
-    mov ecx, [iExp]
+    mov ecx, iExp
     push ecx
     add ecx,15
     cmp ecx,15+16
@@ -355,14 +378,15 @@
     mov al,'.'
     stosb
     mov ecx, 16
-    sub ecx, [iExp]
+    sub ecx, iExp
 fts3:      
     rep movsb
 
 ; Trim off trailing zeros.
 
 nextitem2:
-	cmp byte [di-1],'0'
+	;cmp byte [di-1],'0'
+	cmp byte ptr [di-1],'0'
     jnz fts1
     dec di
     jmp nextitem2
@@ -370,7 +394,8 @@
 
 ; If we cleared out all the decimal digits, kill the decimal point, too.
 
-	cmp byte [di-1], '.'
+	;cmp byte [di-1], '.'
+	cmp byte ptr [di-1], '.'
     jnz fts2
 	dec di
 fts2:    
@@ -386,37 +411,38 @@
 ; past it.
 
     movsb				; copy the first digit
-    mov byte [di], '.'		; plop in a decimal point
+    ;mov byte [di], '.'		; plop in a decimal point
+    mov byte ptr [di], '.'		; plop in a decimal point
     inc di
     movsd				; copy four more digits
     movsw				; copy two more digits
 
-%if 0
+if 0
 
 ; The printf %g specified trims off trailing zeros here.  I dislike
 ; this, so I've disabled it.  Comment out the if 0 and endif if you
 ; want this.
 
 fts61:
-	cmp byte [di-1],'0'
+	cmp byte ptr [di-1],'0'
     jz fts62
     dec di
     jmp fts61
 fts62:    
-%endif
+endif
 
 ; Shove in the exponent.  If you support 10-byte reals, remember to
 ; allow 4 digits for the exponent.
 
-    mov byte [di], 'e'	; start the exponent
-    mov ax, [iExp]
+    mov byte ptr [di], 'e'	; start the exponent
+    mov ax, iExp
     and ax, ax
     jns fts7
-    mov byte [di+1], '-'
+    mov byte ptr [di+1], '-'
     neg ax
     jmp fts8
 fts7:    
-    mov byte [edi+1], '+'
+    mov byte ptr [edi+1], '+'
 fts8:      
 
     mov cx, 10
@@ -441,11 +467,11 @@
 ; Clean up and go home.
 
 ftsExit:
-    fldcw [stat]		; restore control word
+    fldcw stat		; restore control word
     fwait
 ftsExit2:
 	mov ax,di
-    sub ax,[szDbl]
+    sub ax,szDbl
     mov cx,21
     sub cx,ax
     mov al,' '
@@ -458,12 +484,13 @@
 
 ;FloatToStr ENDP
 
-%define pfpin
-%define szDbl
-%define iExp
-%define mystat
-%define fpin
-%define stat
-%define szTemp
+pfpin equ
+szDbl equ
+iExp  equ
+mystat equ
+fpin equ
+stat equ
+szTemp equ
 
-	cpufpu 8086
+;	cpufpu 8086
+.8086
